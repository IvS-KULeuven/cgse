{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Tip</p> <p>See the navigation links in the header or side-bar.</p> <p>Click  (top left) on mobile.</p>"},{"location":"#welcome","title":"Welcome","text":"<p>Welcome to the CGSE framework documentation.</p> <p>Get started or go straight to the Tutorial</p>"},{"location":"#what-is-the-cgse","title":"What is the CGSE?","text":"<p>The CGSE is short for Common-EGSE, a framework for managing and running test equipment in a lab. The EGSE stands for  Electrical Ground Support Equipment, and this includes all equipment that is used to test or calibration an instrument.</p> <ul> <li>computers: a server running the CGSE and archiving test data and a client to control the test equipment</li> <li>temperature controllers: control heaters and monitor temperature sensors</li> <li>mechanisms: control mechanisms like hexapods or linear stages </li> <li>optics: control optical equipment like lasers and attenuators</li> <li>any other device that can be connected through an Ethernet or USB connection and with a open API.</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":"<p>All you need to get started using and building the CGSE.</p>"},{"location":"getting_started/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9.x (we do not yet support higher versions, but are working to extend the list)</li> <li>macOS or Linux</li> </ul>"},{"location":"getting_started/#virtual-environment","title":"Virtual environment","text":"<p>You should always work inside a virtual environment to somehow containerize your project such that it doesn't  pollute your global environment and you can run different projects next to each other. Create and activate a new  virtual environment as follows. It should be Python &gt;= 3.9</p> <pre><code>$ python -m venv venv\n$ source venv/bin/activate\n</code></pre>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>The easiest way to install the CGSE is to use the <code>pip</code> command. Since the CGSE is a monorepo and consists of  several packages, you will need to make your choice which package you need for your project. You can however start  with the <code>cgse-common</code> which contains all common code that is generic and useful as a basis for other packages.</p> <pre><code>$ pip install cgse-common\n</code></pre> <p>Check the list of packages that are part of the CGSE repo and can be installed with <code>pip</code>. The  packages are described in more detail in the sections Libs and Projects.</p>"},{"location":"getting_started/#set-up-your-environment","title":"Set up your environment","text":"<p>To check your installation and set up your environment, here are a few tips.</p> <p>The version of the core packages and any plugin packages can be verified as follows. The version you installed will  probably be higher and more lines will appear when other packages are installed.</p> <pre><code>$ py -m egse.version\nCGSE version in Settings: 0.5.0\nInstalled version for cgse-common= 0.5.0\n</code></pre> <p>Check your environment with the command below. This will probably print out some warning since you have not defined  the expected environment variables yet. There are two mandatory environment variables: <code>PROJECT</code> and <code>SITE_ID</code>. The  former shall contain the name of your project without spaces and preferably a single word or an acronym like PLATO,  ARIEL, MARVEL, MERCATOR. The latter is the name of the site or lab where the tests will be performed. Good names are  KUL, ESA, LAB23.</p> <p>The other environment variables follow the pattern <code>&lt;PROJECT&gt;_...</code>, i.e. they all start with the project name as  defined  in the PROJECT environment variable. You should define at least <code>&lt;PROJECT&gt;_DATA_STORAGE_LOCATION</code>. The configuration  data and log file location will be derived from it unless they are explicitly set themselves. </p> <p>Let's define the three expected environment variables:</p> <pre><code>$ export PROJECT=ARIEL\n$ export SITE_ID=VACUUM_LAB\n$ export ARIEL_DATA_STORAGE_LOCATION=~/data\n</code></pre> <p>Rerunning the above command now gives:</p> <pre><code>$ py -m egse.env\nEnvironment variables:\n    PROJECT = ARIEL\n    SITE_ID = VACUUM_LAB\n    ARIEL_DATA_STORAGE_LOCATION = /Users/rik/data\n    ARIEL_CONF_DATA_LOCATION = not set\n    ARIEL_CONF_REPO_LOCATION = not set\n    ARIEL_LOG_FILE_LOCATION = not set\n    ARIEL_LOCAL_SETTINGS = not set\n\nGenerated locations and filenames\n    get_data_storage_location() = '/Users/rik/data/VACUUM_LAB'  \u27f6 ERROR: The data storage location doesn't exist!\n    get_conf_data_location() = '/Users/rik/data/VACUUM_LAB/conf'  \u27f6 ERROR: The configuration data location doesn't exist!\n    get_conf_repo_location() = None  \u27f6 ERROR: The configuration repository location doesn't exist!\n    get_log_file_location() = '/Users/rik/data/VACUUM_LAB/log'  \u27f6 ERROR: The log files location doesn't exist!\n    get_local_settings() = None  \u27f6 ERROR: The local settings file is not defined or doesn't exist!\n\nuse the '--full' flag to get a more detailed report, '--doc' for help on the variables.\n</code></pre> <p>Note</p> <p>The folders that do not exist (and are not None) can be created by adding the option <code>--mkdir</code> to the above  command.</p>"},{"location":"getting_started/#check-your-settings","title":"Check your Settings","text":"<p>Settings contains the static configuration of your system, test setup, equipment, including the System Under Test  (SUT). You can test your settings with the command below. Let's first also set the <code>ARIEL_LOCALSETTINGS</code> environment  variables:</p> <p><pre><code>$ export ARIEL_LOCAL_SETTINGS=~/cgse/local_settings_ariel_vacuum_lab.yaml\n$ py -m egse.settings\nSettings\n\u251c\u2500\u2500 PACKAGES\n\u2502   \u2514\u2500\u2500 CGSE_COMMON: Common classes, functions, decorators, etc. for the CGSE\n\u251c\u2500\u2500 SITE\n\u2502   \u251c\u2500\u2500 ID: VACUUM_LAB\n\u2502   \u251c\u2500\u2500 SSH_SERVER: localhost\n\u2502   \u2514\u2500\u2500 SSH_PORT: 22\n\u2514\u2500\u2500 PROCESS\n    \u2514\u2500\u2500 METRICS_INTERVAL: 10\nMemoized locations:\n['/Users/rik/tmp/gettings-started/venv/lib/python3.9/site-packages/cgse_common/settings.yaml', \n'/Users/rik/cgse/local_settings_ariel_vacuum_lab.yaml']\n</code></pre> These Settings will grow when you add more packages to your installation or when you define settings yourself in the  local settings file.</p>"},{"location":"help/","title":"Help","text":"<p>The best way to get help for something that you couldn't find in the documentation on this site, is to contact one of  the authors.</p>"},{"location":"help/#bugs-and-feature-requests","title":"Bugs and Feature requests","text":"<p>Report any bugs or issues through GitHub on the CGSE issues page.  </p>"},{"location":"initialize/","title":"Initialize your project","text":"<p>So, we have seen how to get started with some basic commands and only the <code>cgse-common</code> package. It's time now to initialize your project properly with all the necessary services.</p>"},{"location":"initialize/#set-up-your-environment","title":"Set up your environment","text":"<p>I assume you are in the same environment that we have set up in the previous section where also the <code>cgse-common</code> package was installed. We will install another package that will provide us with the full functionality of the <code>cgse</code> command. Install the <code>cgse-tools</code> and <code>cgse-core</code> packages which depends on <code>cgse-core</code> and will also install that package.</p> <pre><code>$ pip install cgse-tools cgse-core\n</code></pre> <p>You should now have at least the follow three packages installed in your virtual environment:</p> <pre><code>$ pip list | grep cgse\ncgse-common       0.5.0\ncgse-core         0.5.0\ncgse-tools        0.5.0\n</code></pre>"},{"location":"initialize/#the-cgse-command","title":"The <code>cgse</code> command","text":"<p>The two new packages that have been installed (<code>cgse-core</code> and <code>cgse-tools</code>) provide the <code>cgse</code> command that we will use to initialize your environment, but this command is also used to inspect different parts of the system, manage core services and device drivers, etc.</p> <p>When you run the <code>cgse</code> command without any arguments, it will show something like this:</p> <pre><code>$ cgse\n\n Usage: cgse [OPTIONS] COMMAND [ARGS]...\n\n The main cgse command to inspect, configure, monitor the core services and device control servers.\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --install-completion          Install completion for the current shell.                                                                                      \u2502\n\u2502 --show-completion             Show completion for the current shell, to copy it or customize the installation.                                               \u2502\n\u2502 --help                        Show this message and exit.                                                                                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 version   Prints the version of the cgse-core and other registered packages.                                                                                 \u2502\n\u2502 init      Initialize your project.                                                                                                                           \u2502\n\u2502 top       A top-like interface for core services and device control servers.                                                                                 \u2502\n\u2502 core      handle core services: start, stop, status                                                                                                          \u2502\n\u2502 show      Show information about settings, environment, setup, ...                                                                                           \u2502\n\u2502 check     Check installation, settings, required files, etc.                                                                                                 \u2502\n\u2502 dev-x     device-x is an imaginary device that serves as an example                                                                                          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>The <code>cgse</code> command is actually an app that is the starting point for a number of commands that can be used to maintain the system, manage and inspect services and devices. For example, to check the version of the different components, use:</p> <pre><code>$ cgse version\nCGSE-COMMON installed version = 0.5.0 \u2014 Software framework to support hardware testing\nCGSE-CORE installed version = 0.5.0 \u2014 Core services for the CGSE framework\nCGSE-TOOLS installed version = 0.5.0 \u2014 Tools for CGSE\n</code></pre> <p>We will for now concentrate on the <code>init</code> command. This command will guide us through a number of steps to define the location of our device data, configuration data, etc. We will basically define some environment variables that are used by the CGSE framework. The PROJECT is he name of the project your will be working on, the SITE_ID is the identifier for the LAB or Setup that you are using to perform the tests. As you see below, the environment variables all start with the project name allowing you to work on different projects simultaneously. If you accept all the defaults, the result of the <code>cgse init</code> command will look something like this:</p> <pre><code>$ cgse init --project marvel\nPlease note default values are given between [brackets].\nWhat is the name of the project [MARVEL] ?:\nWhat is the site identifier ?: lab02\nWhere can the project data be stored [~/data/MARVEL/LAB02/] ?:\nWhere will the configuration data be located [~/data/MARVEL/LAB02/conf/] ?:\nWhere will the logging messages be stored [~/data/MARVEL/LAB02/log/] ?:\nWhere shall I create a local settings YAML file [~/data/MARVEL/LAB02/local_settings.yaml] ?:\nShall I add the environment to your ~/bash_profile ? [y/n]: n\n\n# -&gt; Add the following lines to your bash profile or equivalent\n\nexport PROJECT=MARVEL\nexport SITE_ID=LAB02\nexport MARVEL_DATA_STORAGE_LOCATION=~/data/MARVEL/LAB02/\nexport MARVEL_CONF_DATA_LOCATION=~/data/MARVEL/LAB02/conf/\nexport MARVEL_LOG_FILE_LOCATION=~/data/MARVEL/LAB02/log/\nexport MARVEL_LOCAL_SETTINGS=~/data/MARVEL/LAB02/local_settings.yaml\n</code></pre> <p>If you answered 'Y' to the last question, you should log in to the shell again with <code>exec bash -login</code> or a similar command for other shells, or you should start a new terminal to activate the environment variables.</p> <p>Add this point you are ready to go and start the core services and any device control servers that you need. You can explore other commands of the <code>cgse</code> app in the user guide.</p>"},{"location":"package_list/","title":"Packages in the CGSE","text":"<p>The CGSE is a monorepo and consists of numerous packages. Each of these packages are individually installable from  PyPI. We maintain a list here with all the packages in the monorepo.</p> Package Description <code>cgse-common</code> The common code used by all other packages <code>cgse-core</code> The core services <code>cgse-coordinates</code> Coordinate reference Frames <code>cgse-gui</code> GUI components and styles (PyQt5) <code>cgse-tools</code> Plugin that adds functions to the <code>cgse</code> command <code>symetrie-hexapod</code> Device drivers for the Sym\u00e9trie Hexapods <code>keithley-tempcontrol</code> Device driver for the Keithley temperature controller <code>plato-fits</code> FITS driver with PLATO specific format <code>plato-hdf5</code> HDF5 driver with PLATO specific format <code>plato-spw</code> SpaceWire driver with PATO specific packets <p>The following is a non-exhaustive list of known external packages that work well with the CGSE  in terms of commanding and monitoring.</p> Package Description <code>cgse-dummy</code> Provides a dummy device driver to demonstrate plugins, commands and how to develop an external package for the CGSE."},{"location":"roadmap/","title":"Roadmap","text":"<p>Don't worry, the feature set will grow..</p>"},{"location":"roadmap/#features","title":"Features","text":""},{"location":"roadmap/#the-cgse-command","title":"The <code>cgse</code> Command","text":"<p>Provide a <code>cgse</code> command that is extensible with new commands and command groups:</p> <ul> <li> a command to initialise your environment.</li> <li> a command to check versions of installed packages.</li> <li> a command to check your installation, settings, setups, environment ..</li> <li> a command group to handle core services</li> <li> a command to list running CGSE processes.</li> <li> device drivers shall be able to plug in their own command groups.</li> </ul>"},{"location":"roadmap/#settings-setup-and-the-environment","title":"Settings, Setup and the environment","text":"<ul> <li> A modular/decomposed <code>settings.yaml</code> file.</li> <li> A clear set of environment variables.</li> <li> automatic submit of new Setups to GitHub.</li> <li> a TUI for inspecting the loaded Setup.</li> </ul>"},{"location":"roadmap/#common-functionality","title":"Common functionality","text":"<ul> <li> Reference Frames and coordinate transformations -&gt; Graphs</li> <li> Metrics for all devices will be handled using InfluxDB</li> <li> Use of Grafana to visualize the metrics</li> </ul>"},{"location":"roadmap/#devices","title":"Devices","text":"<ul> <li> The Sym\u00e9trie Hexapods: PUNA, ZONDA, JORAN</li> <li> The Keithley Data Acquisition Multimeter</li> <li> The Lakeshore temperature controller</li> </ul>"},{"location":"roadmap/#projects","title":"Projects","text":"<ul> <li> Ariel HDF5 format plugin</li> <li> Ariel FITS format plugin</li> </ul>"},{"location":"roadmap/#guis-and-tuis","title":"GUIs and TUIs","text":"<ul> <li> A Process Manager TUI</li> <li> <code>tui-executor</code> integration</li> </ul>"},{"location":"roadmap/#removals","title":"Removals","text":"<ul> <li> The <code>get_common_egse_root()</code> is of no use anymore and needs to be removed or replaced in    some cases.</li> </ul>"},{"location":"roadmap/#testing","title":"Testing","text":"<ul> <li> Add proper unit tests for all packages \u2013 using <code>pytest</code></li> <li> Add a CI test suite</li> <li> Use GitHub Actions for running tests before merging</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Welcome to the CGSE Tutorial!</p> <p>By the end of this page you should have a solid understanding of the core features of the CGSE.</p>"},{"location":"api/","title":"API","text":"<p>This is a API-level reference to the CGSE API. Click the links to your left (or in the   menu) to open a reference for each module.</p> <p>If you are new to the CGSE, you may want to read the Gettings Started  first.</p>"},{"location":"api/bits/","title":"egse.bits","text":"<p>This module contains a number of convenience functions to work with bits, bytes and integers.</p> <p>Functions:</p> Name Description <code>beautify_binary</code> <p>Returns a binary representation of the given value. The bits are presented</p> <code>bit_set</code> <p>Return True if the bit is set.</p> <code>bits_set</code> <p>Return True if all the bits are set.</p> <code>clear_bit</code> <p>Set bit to 0 for the given value.</p> <code>clear_bits</code> <p>Set the given bits in value to 0.</p> <code>crc_calc</code> <p>Calculate the checksum for (part of) the data.</p> <code>extract_bits</code> <p>Extracts a specified number of bits from an integer starting at a given position.</p> <code>humanize_bytes</code> <p>Represents the size <code>n</code> in human readable form, i.e. as byte, KiB, MiB, GiB, ...</p> <code>s16</code> <p>Return the signed equivalent of a hex or binary number.</p> <code>s32</code> <p>Return the signed equivalent of a hex or binary number.</p> <code>set_bit</code> <p>Set bit to 1 for the given value.</p> <code>set_bits</code> <p>Set the given bits in value to 1.</p> <code>toggle_bit</code> <p>Toggle the bit in the given value.</p>"},{"location":"api/bits/#egse.bits.beautify_binary","title":"beautify_binary","text":"<pre><code>beautify_binary(value, sep=' ', group=8, prefix='', size=0)\n</code></pre> <p>Returns a binary representation of the given value. The bits are presented in groups of 8 bits for clarity by default (can be changed with the <code>group</code> keyword).</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the value to beautify</p> required <code>sep</code> <code>str</code> <p>the separator character to be used, default is a space</p> <code>' '</code> <code>group</code> <code>int</code> <p>the number of bits to group together, default is 8</p> <code>8</code> <code>prefix</code> <code>str</code> <p>a string to prefix the result, default is ''</p> <code>''</code> <code>size</code> <code>int</code> <p>number of digits</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>a binary string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; status = 2**14 + 2**7\n&gt;&gt;&gt; assert beautify_binary(status) == \"01000000 10000000\"\n</code></pre>"},{"location":"api/bits/#egse.bits.bit_set","title":"bit_set","text":"<pre><code>bit_set(value, bit)\n</code></pre> <p>Return True if the bit is set.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the value to check</p> required <code>bit</code> <code>int</code> <p>the index of the bit to check, starting from 0 at the LSB</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the bit is set (1).</p>"},{"location":"api/bits/#egse.bits.bits_set","title":"bits_set","text":"<pre><code>bits_set(value, *args)\n</code></pre> <p>Return True if all the bits are set.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the value to check</p> required <code>args</code> <p>a set of indices of the bits to check, starting from 0 at the LSB</p> <code>()</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if all the bits are set (1).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert bits_set(0b0101_0000_1011, [0, 1, 3, 8, 10])\n&gt;&gt;&gt; assert bits_set(0b0101_0000_1011, [3, 8])\n&gt;&gt;&gt; assert not bits_set(0b0101_0000_1011, [1, 2, 3])\n</code></pre>"},{"location":"api/bits/#egse.bits.clear_bit","title":"clear_bit","text":"<pre><code>clear_bit(value, bit)\n</code></pre> <p>Set bit to 0 for the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the integer value that needs a bit set or unset</p> required <code>bit</code> <code>int</code> <p>the index of the bit to set/unset, starting from 0 at the LSB</p> required <p>Returns:</p> Type Description <code>int</code> <p>the changed value.</p>"},{"location":"api/bits/#egse.bits.clear_bits","title":"clear_bits","text":"<pre><code>clear_bits(value, bits)\n</code></pre> <p>Set the given bits in value to 0.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the value where the given bits shall be changed</p> required <code>bits</code> <code>tuple</code> <p>a tuple with start and stop bits</p> required <p>Returns:</p> Type Description <code>int</code> <p>the changed value</p>"},{"location":"api/bits/#egse.bits.crc_calc","title":"crc_calc","text":"<pre><code>crc_calc(data, start, len)\n</code></pre> <p>Calculate the checksum for (part of) the data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>the data for which the checksum needs to be calculated</p> required <code>start</code> <code>int</code> <p>offset into the data array [byte]</p> required <code>len</code> <code>int</code> <p>number of bytes to incorporate into the calculation</p> required <p>Returns:</p> Type Description <code>int</code> <p>the calculated checksum.</p> Reference <p>The description of the CRC calculation for RMAP is given in the ECSS document Space Engineering: SpaceWire - Remote Memory Access Protocol, section A.3 on page 80 [ECSS\u2010E\u2010ST\u201050\u201052C].</p>"},{"location":"api/bits/#egse.bits.extract_bits","title":"extract_bits","text":"<pre><code>extract_bits(value, start_position, num_bits)\n</code></pre> <p>Extracts a specified number of bits from an integer starting at a given position.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The input integer.</p> required <code>start_position</code> <code>int</code> <p>The starting bit position (0-based index).</p> required <code>num_bits</code> <code>int</code> <p>The number of bits to extract.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The extracted bits as an integer.</p>"},{"location":"api/bits/#egse.bits.humanize_bytes","title":"humanize_bytes","text":"<pre><code>humanize_bytes(n, base=2, precision=3)\n</code></pre> <p>Represents the size <code>n</code> in human readable form, i.e. as byte, KiB, MiB, GiB, ...</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>number of byte</p> required <code>base</code> <code>(int, str)</code> <p>binary (2) or decimal (10)</p> <code>2</code> <code>precision</code> <code>int</code> <p>the number of decimal places [default=3]</p> <code>3</code> <p>Returns:</p> Type Description <code>str</code> <p>a human readable size, like 512 byte or 2.300 TiB</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when base is different from 2 (binary) or 10 (decimal).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert humanize_bytes(55) == \"55 bytes\"\n&gt;&gt;&gt; assert humanize_bytes(1024) == \"1.000 KiB\"\n&gt;&gt;&gt; assert humanize_bytes(1000, base=10) == \"1.000 kB\"\n&gt;&gt;&gt; assert humanize_bytes(1000000000) == '953.674 MiB'\n&gt;&gt;&gt; assert humanize_bytes(1000000000, base=10) == '1.000 GB'\n&gt;&gt;&gt; assert humanize_bytes(1073741824) == '1.000 GiB'\n&gt;&gt;&gt; assert humanize_bytes(1024**5 - 1, precision=0) == '1024 TiB'\n</code></pre> Note <p>Please note that, by default, I use the IEC standard (International Engineering Consortium) which is in <code>base=2</code> (binary), i.e. 1024 bytes = 1.0 KiB. If you need SI units (International System of Units), you need to specify <code>base=10</code> (decimal), i.e. 1000 bytes = 1.0 kB.</p>"},{"location":"api/bits/#egse.bits.s16","title":"s16","text":"<pre><code>s16(value)\n</code></pre> <p>Return the signed equivalent of a hex or binary number.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>an integer value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The negative equivalent of a twos-complement binary number.</p> <p>Examples:</p> <p>Since integers in Python are objects and stored in a variable number of bits, Python doesn't know the concept of twos-complement for negative integers. For example, this 16-bit number</p> <pre><code>&gt;&gt;&gt; 0b1000_0000_0001_0001\n32785\n</code></pre> <p>which in twos-complement is actually a negative value:</p> <pre><code>&gt;&gt;&gt; s16(0b1000_0000_0001_0001)\n-32751\n</code></pre> <p>The 'bin()' fuction will return a strange representation of this number:</p> <pre><code>&gt;&gt;&gt; bin(-32751)\n'-0b111111111101111'\n</code></pre> <p>when we however mask the value we get:</p> <pre><code>&gt;&gt;&gt; bin(-32751 &amp; 0b1111_1111_1111_1111)\n'0b1000000000010001'\n</code></pre> See <p>Twos complement in Python and         Pythons representation of negative integers and         Signed equivalent of a twos-complement hex-value and         SO Twos complement in Python.</p>"},{"location":"api/bits/#egse.bits.s32","title":"s32","text":"<pre><code>s32(value)\n</code></pre> <p>Return the signed equivalent of a hex or binary number.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>an integer value.</p> required <p>Returns:</p> Type Description <p>The negative equivalent of a twos-complement binary number.</p> <p>Examples:</p> <p>Since integers in Python are objects and stored in a variable number of bits, Python doesn't know the concept of twos-complement for negative integers. For example, this 32-bit number</p> <pre><code>&gt;&gt;&gt; 0b1000_0000_0000_0000_0000_0000_0001_0001\n2147483665\n</code></pre> <p>which in twos-complement is actually a negative value:</p> <pre><code>&gt;&gt;&gt; s32(0b1000_0000_0000_0000_0000_0000_0001_0001)\n-2147483631\n</code></pre>"},{"location":"api/bits/#egse.bits.set_bit","title":"set_bit","text":"<pre><code>set_bit(value, bit)\n</code></pre> <p>Set bit to 1 for the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the integer value that needs a bit set or unset</p> required <code>bit</code> <code>int</code> <p>the index of the bit to set/unset, starting from 0 at the LSB</p> required <p>Returns:</p> Type Description <code>int</code> <p>the changed value.</p>"},{"location":"api/bits/#egse.bits.set_bits","title":"set_bits","text":"<pre><code>set_bits(value, bits)\n</code></pre> <p>Set the given bits in value to 1.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the value where the given bits shall be changed</p> required <code>bits</code> <code>tuple</code> <p>a tuple with start and stop bits</p> required <p>Returns:</p> Type Description <code>int</code> <p>the changed value.</p>"},{"location":"api/bits/#egse.bits.toggle_bit","title":"toggle_bit","text":"<pre><code>toggle_bit(value, bit)\n</code></pre> <p>Toggle the bit in the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the integer value that needs a bit toggled</p> required <code>bit</code> <code>int</code> <p>the index of the bit to toggle, starting from 0 at the LSB</p> required <p>Returns:</p> Type Description <code>int</code> <p>the changed value.</p>"},{"location":"api/calibration/","title":"egse.calibration","text":"<p>This module provides functions to calibrate sensor values.</p> <p>Functions:</p> Name Description <code>apply_gain_offset</code> <p>Applies the given gain and offset to the given counts.</p> <code>callendar_van_dusen</code> <p>Solves the Callendar - van Dusen equation for temperature.</p> <code>chebychev</code> <p>Solves the Chebychev equation for temperature.</p> <code>counts_to_resistance</code> <p>Converts the given counts for the given sensor to resistance.</p> <code>counts_to_temperature</code> <p>Converts the given counts for the given sensor to temperature.</p> <code>resistance_to_temperature</code> <p>Converts the given resistance for the given sensor to temperature.</p> <code>solve_temperature</code> <p>Solves the temperature from the temperature -&gt; resistance polynomial.</p>"},{"location":"api/calibration/#egse.calibration.apply_gain_offset","title":"apply_gain_offset","text":"<pre><code>apply_gain_offset(counts, gain, offset)\n</code></pre> <p>Applies the given gain and offset to the given counts.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>float</code> <p>Uncalibrated, raw data [ADU]</p> required <code>gain</code> <code>float</code> <p>Gain to apply</p> required <code>offset</code> <code>float</code> <p>Offset to apply</p> required <p>Returns:</p> Type Description <code>float</code> <p>Counts after applying the given gain and offset.</p>"},{"location":"api/calibration/#egse.calibration.callendar_van_dusen","title":"callendar_van_dusen","text":"<pre><code>callendar_van_dusen(\n    resistance, ref_resistance, standard, setup\n)\n</code></pre> <p>Solves the Callendar - van Dusen equation for temperature.</p> <p>Parameters:</p> Name Type Description Default <code>resistance</code> <code>float</code> <p>Resistance [Ohm] for which to calculate the temperature</p> required <code>ref_resistance</code> <code>float</code> <p>Resistance [Ohm] for a temperature of 0\u00b0C</p> required <code>standard</code> <code>str</code> <p>Sensor standard</p> required <code>setup</code> <code>Setup</code> <p>Setup</p> required <p>Returns:</p> Type Description <code>float</code> <p>Temperature [\u00b0C] corresponding to the given resistance.</p>"},{"location":"api/calibration/#egse.calibration.chebychev","title":"chebychev","text":"<pre><code>chebychev(resistance, sensor_info)\n</code></pre> <p>Solves the Chebychev equation for temperature.</p> <p>Implemented as specified in the calibration certificate of the LakeShore Cernox sensors.</p> <p>Parameters:</p> Name Type Description Default <code>resistance</code> <code>float</code> <p>Resistance [Ohm] for which to calculate the temperature</p> required <code>sensor_info</code> <code>navdict</code> <p>Calibration information</p> required <p>Returns:</p> Type Description <code>float</code> <p>Temperature [\u00b0C] corresponding to the given resistance.</p>"},{"location":"api/calibration/#egse.calibration.counts_to_resistance","title":"counts_to_resistance","text":"<pre><code>counts_to_resistance(sensor_name, counts, sensor_info)\n</code></pre> <p>Converts the given counts for the given sensor to resistance.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_name</code> <code>str</code> <p>Sensor name</p> required <code>counts</code> <code>float</code> <p>Uncalibrated, raw data [ADU]</p> required <code>sensor_info</code> <code>NavigableDict</code> <p>Calibration information for the given sensor (type)</p> required <p>Returns:</p> Type Description <code>float</code> <p>Resistance [Ohm] for the given sensor.</p>"},{"location":"api/calibration/#egse.calibration.counts_to_temperature","title":"counts_to_temperature","text":"<pre><code>counts_to_temperature(\n    sensor_name, counts, sensor_info, setup\n)\n</code></pre> <p>Converts the given counts for the given sensor to temperature.</p> <p>This conversion can be done as follows:</p> <pre><code>- (1) Directly from counts to temperature, by applying the gain and offset;\n- (2) Directly from counts to temperature, by applying a function;\n- (3) From counts, via resistance, to temperature.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sensor_name</code> <code>str</code> <p>Sensor name</p> required <code>counts</code> <code>float</code> <p>Uncalibrated, raw data [ADU]</p> required <code>sensor_info</code> <code>NavigableDict</code> <p>Calibration information for the given sensor (type)</p> required <code>setup</code> <code>Setup</code> <p>Setup</p> required <p>Returns:</p> Type Description <code>float</code> <p>Calibrated temperature [\u00b0C] for the given sensor</p>"},{"location":"api/calibration/#egse.calibration.resistance_to_temperature","title":"resistance_to_temperature","text":"<pre><code>resistance_to_temperature(\n    sensor_name, resistance, sensor_info, setup\n)\n</code></pre> <p>Converts the given resistance for the given sensor to temperature.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_name</code> <code>str</code> <p>Sensor name</p> required <code>resistance</code> <code>float</code> <p>Resistance [Ohm]</p> required <code>sensor_info</code> <code>NavigableDict</code> <p>Calibration information for the given sensor (type)</p> required <code>setup</code> <code>Setup</code> <p>Setup</p> required <p>Returns:</p> Type Description <code>floaf</code> <p>Temperature [\u00b0C] for the given sensor.</p>"},{"location":"api/calibration/#egse.calibration.solve_temperature","title":"solve_temperature","text":"<pre><code>solve_temperature(\n    temperature_to_resistance_coefficients, resistance\n)\n</code></pre> <p>Solves the temperature from the temperature -&gt; resistance polynomial.</p> <p>For the given temperature -&gt; resistance polynomial and the given resistance, we determine what the corresponding temperature is by:</p> <ul> <li>Finding the roots of polynomial(temperature) = resistance;</li> <li>Discarding the roots with an imaginary component;</li> <li>Selecting the remaining root in the relevant temperature regime (here: [-200\u00b0C, 200\u00b0C]).</li> </ul>"},{"location":"api/command/","title":"egse.command","text":"<p>This module defines a number of classes and helper functions to define and work with commands that operate hardware devices. The goal is to be able to define / create commands transparently from a YAML file without having to write (too much) code.</p>"},{"location":"api/command/#egse.command--definitions","title":"Definitions","text":"<p>command</p> <p>a string that is sent to a device over an interface like TCP/IP or USB. This string is generated by the get_cmd_string() method of the Command class.</p> <p>The string contains format like syntax that looks like an f-string, but is interpreted differently. See further: How to format device command strings.</p> <p>Command</p> <p>the base class for commands. This class contains the definition of the command and provides methods to parse and check arguments. The Command can be 'called' or 'executed' in which case a number of actions are performed based on the provided arguments.</p> <p>CommandExecution</p> <p>this class contains all the information needed to execute a command, without actually executing it. A CommandExecution contains the command definition and the parameters for the execution. It is mainly served as a communication mechanism to the control servers, i.e. the client side (Proxy) defines a command execution and the server then executes the command.</p> <p>CommandError</p> <p>a catch-all exception for unrecoverable errors in this module</p> <p>InvalidArgumentsError</p> <p>a CommandError raised when the arguments provided are themselve invalid or if the number of arguments is not matching expectations</p> <p>The basic interface is:</p> <pre><code>cmd = Command(name     = &lt;command name&gt;,\n              cmd      = &lt;command string&gt;,\n              response = &lt;callable to retreive a response&gt;,\n              wait     = &lt;callable to wait a specific time/delay&gt;)\n</code></pre> <p>where:</p> <ul> <li>name: a name for the command, this is just needed for reporting, not used in commanding</li> <li>cmd: the command string to send or execute, see further for details</li> <li>response: send a second command to read or get a response on the 'cmd' sent</li> <li>wait: a function object that will wait for a specific duration,   e.g. <code>partial(time.sleep, 10)</code>.</li> </ul>"},{"location":"api/command/#egse.command--formatting-device-command-strings","title":"Formatting device command strings","text":"<p>The <code>cmd</code> argument is a string that contains placeholders (replacement fields) for future arguments that will be passed when calling the Command. The replacement fields are marked with curly braces and are mandatory. When a name is provided in the curly braces, the argument shall be provided as a keyword argument, otherwise a positional argument is expected. In the current implementation the <code>cmd</code> can only contain either positional arguments or keyword argument, not a mix of both.</p> <p>The replacement fields may also have a format specifier to specify a precise format for that field.</p> <p>Examples</p> <pre><code>moveAbsolute = Command(\n    name = \"moveAbsolute\",\n    cmd  = \"&amp;2 Q70=0 Q71={tx:.6f} Q72={ty:.6f} Q73={tz:.6f} \"\n           \"Q74={rx:.6f} Q75={ry:.6f} Q76={rz:.6f} Q20=11\"\n)\n\nresponse = moveAbsolute(1, 1, 1, 0, 0, 20)\nresponse = moveAbsolute(tx=1, ty=1, tz=1, rx=0, ry=0, rz=20)\n</code></pre>"},{"location":"api/command/#egse.command--questions","title":"Questions","text":"<p>Do we need additional hooks into this commanding?</p> <ul> <li>add a meaning to the check, what is it and what is it used for?</li> <li>add a output processor possibility. A callback function that will process the   output value before returning it by the call.</li> <li>provide an execute method for the CommandExecution that executes the command   with the saved parameters</li> </ul> <p>Classes:</p> Name Description <code>ClientServerCommand</code> <code>Command</code> <p>A Command is basically a string that is send to a device and for which the</p> <code>CommandError</code> <p>A Command Exception as a base class for this module.</p> <code>CommandExecution</code> <p>This class contains all the information that is needed to execute a command</p> <code>InvalidArgumentsError</code> <p>The arguments provided are invalid</p> <code>InvalidCommandExecution</code> <p>A invalid command execution.</p> <p>Functions:</p> Name Description <code>dry_run</code> <p>This decorator prepares the function to handle a dry run.</p> <code>get_function</code> <p>Returns a function (unbound method) from a given class.</p> <code>get_method</code> <p>Returns a bound method from a given class instance.</p> <code>load_commands</code> <p>Loads the command definitions from the given <code>command_settings</code> and builds an internal</p> <code>parse_format_string</code> <p>Parse and decode the format string.</p>"},{"location":"api/command/#egse.command.ClientServerCommand","title":"ClientServerCommand","text":"<pre><code>ClientServerCommand(\n    name,\n    cmd,\n    response=None,\n    wait=None,\n    check=None,\n    description=None,\n    device_method=None,\n)\n</code></pre> <p>               Bases: <code>Command</code></p> <p>Methods:</p> Name Description <code>client_call</code> <p>This method is called at the client side. It is used by the Proxy</p> <code>server_call</code> <p>This method is called at the server side. It is used by the CommandProtocol class in the</p>"},{"location":"api/command/#egse.command.ClientServerCommand.client_call","title":"client_call","text":"<pre><code>client_call(other, *args, **kwargs)\n</code></pre> <p>This method is called at the client side. It is used by the Proxy as a generic command to send a command execution to the server.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>a sub-class of the Proxy class</p> required <code>args</code> <p>arguments that will be passed on to this command when executed</p> <code>()</code> <code>kwargs</code> <p>keyword arguments that will be passed on to this command when executed</p> <code>{}</code> <p>Returns:</p> Type Description <p>the response that is returned by calling the command (at the server side).</p>"},{"location":"api/command/#egse.command.ClientServerCommand.server_call","title":"server_call","text":"<pre><code>server_call(other, *args, **kwargs)\n</code></pre> <p>This method is called at the server side. It is used by the CommandProtocol class in the <code>execute</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>a sub-class of the CommandProtocol</p> required <code>args</code> <p>arguments are passed on to the response method</p> <code>()</code> <code>kwargs</code> <p>keyword arguments are passed on to the response method</p> <code>{}</code> <p>Returns:</p> Type Description <p>0 on success and -1 on failure.</p>"},{"location":"api/command/#egse.command.Command","title":"Command","text":"<pre><code>Command(\n    name,\n    cmd,\n    response=None,\n    wait=None,\n    check=None,\n    description=None,\n    device_method=None,\n)\n</code></pre> <p>A Command is basically a string that is send to a device and for which the device returns a response.</p> <p>The command string can contain placeholders that will be filled when the command is 'called'.</p> <p>The arguments that are given will be filled into the formatted string. Arguments can be positional or keyword arguments, not both.</p>"},{"location":"api/command/#egse.command.CommandError","title":"CommandError","text":"<p>               Bases: <code>Error</code></p> <p>A Command Exception as a base class for this module.</p>"},{"location":"api/command/#egse.command.CommandExecution","title":"CommandExecution","text":"<pre><code>CommandExecution(cmd, *args, **kwargs)\n</code></pre> <p>This class contains all the information that is needed to execute a command with a set of parameters/arguments. The command is however not executed automatically. That is the responsibility of the caller to actually execute the command with the given parameters.</p> Developer info <p>you can see this as a partial (functools) which defines the command and its arguments, but doesn't execute until explicitly called. You can execute the command by calling the <code>cmd</code> with the given arguments:</p> <pre><code>ce = CommandExecution(cmd, 20.0)\n...\nresponse = ce.run()\n</code></pre>"},{"location":"api/command/#egse.command.InvalidArgumentsError","title":"InvalidArgumentsError","text":"<p>               Bases: <code>CommandError</code></p> <p>The arguments provided are invalid</p>"},{"location":"api/command/#egse.command.InvalidCommandExecution","title":"InvalidCommandExecution","text":"<pre><code>InvalidCommandExecution(exc, cmd, *args, **kwargs)\n</code></pre> <p>               Bases: <code>CommandExecution</code></p> <p>A invalid command execution.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <p>the Exception that was raised and describes the problem</p> required <code>cmd</code> <p>the Command object</p> required <code>*args</code> <p>the positional arguments that were given</p> <code>()</code> <code>**kwargs</code> <p>the keyword arguments that were given</p> <code>{}</code>"},{"location":"api/command/#egse.command.dry_run","title":"dry_run","text":"<pre><code>dry_run(func)\n</code></pre> <p>This decorator prepares the function to handle a dry run.</p> <p>A dry run is used to check the logic of an instrument commanding script without actually executing the instrument commands. The commands are instead added to the command sequence in the global state.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>the function that needs to be executed</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A wrapper around the given function.</p>"},{"location":"api/command/#egse.command.get_function","title":"get_function","text":"<pre><code>get_function(parent_class, method_name)\n</code></pre> <p>Returns a function (unbound method) from a given class.</p> <p>Parameters:</p> Name Type Description Default <code>parent_class</code> <p>the class that provides the method</p> required <code>method_name</code> <code>str</code> <p>name of the method that is requested</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>the method [type: function].</p> Note <p>The function returned is an unbound class instance method and therefore this function expects as its first argument the class instance, i.e. self, when you call it as a function.</p>"},{"location":"api/command/#egse.command.get_method","title":"get_method","text":"<pre><code>get_method(parent_obj, method_name)\n</code></pre> <p>Returns a bound method from a given class instance.</p> <p>Parameters:</p> Name Type Description Default <code>parent_obj</code> <p>the class instance that provides the method</p> required <code>method_name</code> <code>str</code> <p>name of the method that is requested</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>the method [type: method].</p> Note <p>The method returned is an bound class instance method and therefore this method does not expects as its first argument the class instance, i.e. self, when you call this as a function.</p>"},{"location":"api/command/#egse.command.load_commands","title":"load_commands","text":"<pre><code>load_commands(\n    protocol_class,\n    command_settings,\n    command_class,\n    device_class,\n)\n</code></pre> <p>Loads the command definitions from the given <code>command_settings</code> and builds an internal dictionary containing the command names as keys and the corresponding <code>Command</code> class objects as values.</p> <p>The <code>command_settings</code> is usually loaded from a YAML configuration file containing the command definitions for the device.</p> <p>Parameters:</p> Name Type Description Default <code>protocol_class</code> <p>the CommandProtocol or a sub-class</p> required <code>command_settings</code> <p>a dictionary containing the command definitions for this device</p> required <code>command_class</code> <p>the type of command to create, a subclass of Command</p> required <code>device_class</code> <p>the type of the base device class from which the methods are loaded</p> required"},{"location":"api/command/#egse.command.parse_format_string","title":"parse_format_string","text":"<pre><code>parse_format_string(fstring)\n</code></pre> <p>Parse and decode the format string.</p>"},{"location":"api/config/","title":"egse.config","text":"<p>This module provides convenience functions to properly configure the CGSE and to find paths and resources.</p> <p>Classes:</p> Name Description <code>WorkingDirectory</code> <p>WorkingDirectory is a context manager to temporarily change the working directory while</p> <p>Functions:</p> Name Description <code>find_dir</code> <p>Find the first folder that matches the given pattern.</p> <code>find_dirs</code> <p>Generator for returning directory paths from a walk started at <code>root</code> and matching pattern.</p> <code>find_file</code> <p>Find the path to the given file starting from the root directory of the</p> <code>find_files</code> <p>Generator for returning file paths from a top folder, matching the pattern.</p> <code>find_first_occurrence_of_dir</code> <p>Returns the full path of the directory that first matches the pattern. The directory hierarchy is</p> <code>find_root</code> <p>Find the root folder based on the files in <code>tests</code>.</p> <code>get_common_egse_root</code> <p>Returns the absolute path to the installation directory for the Common-EGSE.</p> <code>get_resource_dirs</code> <p>Define directories that contain resources like images, icons, and data files.</p> <code>get_resource_path</code> <p>Searches for a data file (resource) with the given name.</p> <code>set_logger_levels</code> <p>Set the logging level for the given loggers.</p>"},{"location":"api/config/#egse.config.WorkingDirectory","title":"WorkingDirectory","text":"<pre><code>WorkingDirectory(path)\n</code></pre> <p>WorkingDirectory is a context manager to temporarily change the working directory while executing some code.</p> <p>This context manager has a property <code>path</code> which returns the absolute path of the current directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>(str, Path)</code> <p>the folder to change to within this context</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>when the given path doesn't exist.</p> Example <pre><code>with WorkingDirectory(find_dir(\"/egse/images\")) as wdir:\n    for file in wdir.path.glob('*'):\n        assert file.exists()  # do something with the image files\n</code></pre> <p>Attributes:</p> Name Type Description <code>path</code> <p>Resolve and return the current Path of the context.</p>"},{"location":"api/config/#egse.config.WorkingDirectory.path","title":"path  <code>property</code>","text":"<pre><code>path\n</code></pre> <p>Resolve and return the current Path of the context.</p>"},{"location":"api/config/#egse.config.find_dir","title":"find_dir","text":"<pre><code>find_dir(pattern, root=None)\n</code></pre> <p>Find the first folder that matches the given pattern.</p> <p>Note that if there are more folders that match the pattern in the distribution, this function only returns the first occurrence that is found, which might not be what you want. To be sure only one folder is returned, use the <code>find_dirs()</code> function and check if there is just one item returned in the list.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>pattern to match (use * for wildcard)</p> required <code>root</code> <code>str</code> <p>the top level folder to search [default=common-egse-root]</p> <code>None</code> <p>Returns:</p> Type Description <code>Path | None</code> <p>the first occurrence of the directory pattern or None when not found.</p>"},{"location":"api/config/#egse.config.find_dirs","title":"find_dirs","text":"<pre><code>find_dirs(pattern, root=None)\n</code></pre> <p>Generator for returning directory paths from a walk started at <code>root</code> and matching pattern.</p> <p>The pattern can contain the asterisk '*' as a wildcard.</p> <p>The pattern can contain a directory separator '/' which means the last part of the path needs to match these folders.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>pattern to match (use * for wildcard)</p> required <code>root</code> <code>str</code> <p>the top level folder to search [default=common-egse-root]</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Generator</code> <code>None</code> <p>Paths of folders matching pattern, from root.</p> Example <pre><code>&gt;&gt;&gt; for folder in find_dirs(\"/egse/images\"):\n...     assert folder.match('*/egse/images')\n\n&gt;&gt;&gt; folders = list(find_dirs(\"/egse/images\"))\n&gt;&gt;&gt; assert len(folders)\n</code></pre>"},{"location":"api/config/#egse.config.find_file","title":"find_file","text":"<pre><code>find_file(name, root=None, in_dir=None)\n</code></pre> <p>Find the path to the given file starting from the root directory of the distribution.</p> <p>Note that if there are more files with the given name found in the distribution, this function only returns the first file that is found, which might not be what you want. To be sure only one file is returned, use the <code>find_files()</code> function and check if there is just one file returned in the list.</p> <p>When the file shall be in a specific directory, use the <code>in_dir</code> keyword. This requires that the path ends with the given string in <code>in_dir</code>.</p> <pre><code>&gt;&gt;&gt; file_pattern = 'EtherSpaceLink*.dylib'\n&gt;&gt;&gt; in_dir = 'lib/CentOS-7'\n&gt;&gt;&gt; file = find_file(file_pattern, in_dir=in_dir)\n&gt;&gt;&gt; assert file.match(\"*/lib/CentOS-7/EtherSpace*\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the file</p> required <code>root</code> <code>str</code> <p>the top level folder to search [default=common-egse-root]</p> <code>None</code> <code>in_dir</code> <code>str</code> <p>the 'leaf' directory in which the file shall be</p> <code>None</code> <p>Returns:</p> Type Description <code>Path | None</code> <p>the first occurrence of the file or None when not found.</p>"},{"location":"api/config/#egse.config.find_files","title":"find_files","text":"<pre><code>find_files(pattern, root=None, in_dir=None)\n</code></pre> <p>Generator for returning file paths from a top folder, matching the pattern.</p> <p>The top folder can be specified as e.g. <code>__file__</code> in which case the parent of that file will be used as the top root folder. Note that when you specify '.' as the root argument the current working directory will be taken as the root folder, which is probably not what you intended.</p> <p>When the file shall be in a specific directory, use the <code>in_dir</code> keyword. This requires that the path ends with the given string in <code>in_dir</code>.</p> <pre><code>&gt;&gt;&gt; file_pattern = 'EtherSpaceLink*.dylib'\n&gt;&gt;&gt; in_dir = 'lib/CentOS-7'\n&gt;&gt;&gt; for file in find_files(file_pattern, in_dir=in_dir):\n...     assert file.match(\"*lib/CentOS-7/EtherSpaceLink*\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str) </code> <p>sorting pattern (use * for wildcard)</p> required <code>root</code> <code>str</code> <p>the top level folder to search [default=common-egse-root]</p> <code>None</code> <code>in_dir</code> <code>str</code> <p>the 'leaf' directory in which the file shall be</p> <code>None</code> <p>Returns:</p> Type Description <p>Paths of files matching pattern, from root.</p>"},{"location":"api/config/#egse.config.find_first_occurrence_of_dir","title":"find_first_occurrence_of_dir","text":"<pre><code>find_first_occurrence_of_dir(pattern, root=None)\n</code></pre> <p>Returns the full path of the directory that first matches the pattern. The directory hierarchy is traversed in alphabetical order. The pattern is matched first against all directories in the root folder, if there is no match, the first folder in root is traversed until a match is found. If no match is found, the second folder in root is traversed.</p> <p>Note that the pattern may contain parent directories, like <code>/egse/data/icons</code> or <code>egse/*/icons</code>, in which case the full pattern is matched.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>a filename pattern</p> required <code>root</code> <code>Path | str</code> <p>the root folder to start the hierarchical search</p> <code>None</code> <p>Returns:</p> Type Description <code>Path | None</code> <p>The full path of the matched pattern or None if no match could be found.</p>"},{"location":"api/config/#egse.config.find_root","title":"find_root","text":"<pre><code>find_root(path, tests=(), default=None)\n</code></pre> <p>Find the root folder based on the files in <code>tests</code>.</p> <p>The algorithm crawls backward over the directory structure until one of the items in <code>tests</code> is matched. and it will return that directory as a <code>Path</code>.</p> <p>When no root folder can be determined, the <code>default</code> parameter is returned as a Path (or None).</p> <p>When nothing is provided in <code>tests</code>, all matches will fail and the <code>default</code> parameter will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, PurePath] | None</code> <p>folder from which the search is started</p> required <code>tests</code> <code>Tuple[str, ...]</code> <p>names (files or dirs) to test for existence</p> <code>()</code> <code>default</code> <code>str</code> <p>returned when no root is found</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[PurePath, None]</code> <p>a Path which is the root folder.</p>"},{"location":"api/config/#egse.config.get_common_egse_root","title":"get_common_egse_root  <code>cached</code>","text":"<pre><code>get_common_egse_root(path=None)\n</code></pre> <p>Returns the absolute path to the installation directory for the Common-EGSE.</p> <p>The algorithm first tries to determine the path from the environment variable <code>PLATO_COMMON_EGSE_PATH</code>. If this environment variable doesn't exist, the algorithm tries to determine the path automatically from (1) the git root if it is a git repository, or (2) from the location of this module assuming the installation is done from the GitHub distribution.</p> <p>When the optional argument <code>path</code> is given, that directory will be used to start the search for the root folder.</p> <p>At this moment the algorithm does not cache the <code>egse_path</code> in order to speed up the successive calls to this function.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>a directory as a Path or str [optional]</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Optional[PurePath]</code> <p>the absolute path to the Common-EGSE installation directory or None</p>"},{"location":"api/config/#egse.config.get_resource_dirs","title":"get_resource_dirs","text":"<pre><code>get_resource_dirs(root_dir=None)\n</code></pre> <p>Define directories that contain resources like images, icons, and data files.</p> <p>Resource directories can have the following names: <code>resources</code>, <code>data</code>, <code>icons</code>, or <code>images</code>. This function checks if any of the resource directories exist in the project root directory, in the <code>root_dir</code> that is given as an argument or in the <code>src/egse</code> sub-folder.</p> <p>So, the directories that are searched for the resource folders are:</p> <ul> <li><code>root_dir</code> or the project's root directory</li> <li>the <code>src/egse</code> sub-folder of one of the above</li> </ul> <p>For all existing directories the function returns the absolute path.</p> <p>Parameters:</p> Name Type Description Default <code>root_dir</code> <code>str</code> <p>the directory to search for resource folders</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Path]</code> <p>a list of absolute Paths.</p>"},{"location":"api/config/#egse.config.get_resource_path","title":"get_resource_path","text":"<pre><code>get_resource_path(name, resource_root_dir=None)\n</code></pre> <p>Searches for a data file (resource) with the given name.</p> <p>When <code>resource_root_dir</code> is not given, the search for resources will start at the root folder of the project (using the function <code>get_common_egse_root()</code>). Any other root directory can be given, e.g. if you want to start the search from the location of your source code file, use <code>Path(__file__).parent</code> as the <code>resource_root_dir</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the resource that is requested</p> required <code>resource_root_dir</code> <code>str</code> <p>the root directory where the search for resources should be started</p> <code>None</code> <p>Returns:</p> Type Description <code>PurePath</code> <p>the absolute path of the data file with the given name. The first name that matches is returned. If no file with the given name or path exists, a FileNotFoundError is raised.</p>"},{"location":"api/config/#egse.config.set_logger_levels","title":"set_logger_levels","text":"<pre><code>set_logger_levels(logger_levels=None)\n</code></pre> <p>Set the logging level for the given loggers.</p>"},{"location":"api/control/","title":"egse.control","text":"<p>This module defines the abstract class for any Control Server and some convenience functions.</p> <p>Classes:</p> Name Description <code>ControlServer</code> <p>Base class for all device control servers and for the Storage Manager and Configuration Manager.</p> <p>Functions:</p> Name Description <code>is_control_server_active</code> <p>Checks if the Control Server is running.</p>"},{"location":"api/control/#egse.control.ControlServer","title":"ControlServer","text":"<pre><code>ControlServer()\n</code></pre> <p>Base class for all device control servers and for the Storage Manager and Configuration Manager.</p> <p>A Control Server reads commands from a ZeroMQ socket and executes these commands by calling the <code>execute()</code> method of the commanding protocol class.</p> <p>The subclass shall define the following:</p> <ul> <li>Define the device protocol class -&gt; <code>self.device_protocol</code></li> <li>Bind the command socket to the device protocol -&gt; <code>self.dev_ctrl_cmd_sock</code></li> <li>Register the command socket in the poll set -&gt; <code>self.poller</code></li> </ul> <p>Methods:</p> Name Description <code>after_serve</code> <p>This method needs to be overridden by the subclass if certain actions need to be executed after the control</p> <code>before_serve</code> <p>This method needs to be overridden by the subclass if certain actions need to be executed before the control</p> <code>get_average_execution_times</code> <p>Returns the average execution times of all functions that have been monitored by this process.</p> <code>get_commanding_port</code> <p>Returns the commanding port used by the Control Server.</p> <code>get_communication_protocol</code> <p>Returns the communication protocol used by the Control Server.</p> <code>get_ip_address</code> <p>Returns the IP address of the current host.</p> <code>get_monitoring_port</code> <p>Returns the monitoring port used by the Control Server.</p> <code>get_process_status</code> <p>Returns the process status of the Control Server.</p> <code>get_service_port</code> <p>Returns the service port used by the Control Server.</p> <code>get_storage_mnemonic</code> <p>Returns the storage mnemonics used by the Control Server.</p> <code>handle_scheduled_tasks</code> <p>Executes or reschedules tasks in the <code>serve()</code> event loop.</p> <code>is_storage_manager_active</code> <p>Checks if the Storage Manager is active.</p> <code>notify_listeners</code> <p>Notifies registered listeners about an event.</p> <code>quit</code> <p>Interrupts the Control Server.</p> <code>register_as_listener</code> <p>Registers a listener with the specified proxy.</p> <code>register_to_storage_manager</code> <p>Registers this Control Server to the Storage Manager.</p> <code>schedule_task</code> <p>Schedules a task to run in the control server event loop.</p> <code>serve</code> <p>Activation of the Control Server.</p> <code>set_hk_delay</code> <p>Sets the delay time for housekeeping.</p> <code>set_logging_level</code> <p>Sets the logging level to the given level.</p> <code>set_mon_delay</code> <p>Sets the delay time for monitoring.</p> <code>set_scheduled_task_delay</code> <p>Sets the delay time between successive executions of scheduled tasks.</p> <code>store_housekeeping_information</code> <p>Sends housekeeping information to the Storage Manager.</p> <code>unregister_as_listener</code> <p>Removes a registered listener from the specified proxy.</p> <code>unregister_from_storage_manager</code> <p>Unregisters the Control Server from the Storage Manager.</p>"},{"location":"api/control/#egse.control.ControlServer.after_serve","title":"after_serve","text":"<pre><code>after_serve()\n</code></pre> <p>This method needs to be overridden by the subclass if certain actions need to be executed after the control server has been deactivated.</p>"},{"location":"api/control/#egse.control.ControlServer.before_serve","title":"before_serve","text":"<pre><code>before_serve()\n</code></pre> <p>This method needs to be overridden by the subclass if certain actions need to be executed before the control server is activated.</p>"},{"location":"api/control/#egse.control.ControlServer.get_average_execution_times","title":"get_average_execution_times","text":"<pre><code>get_average_execution_times()\n</code></pre> <p>Returns the average execution times of all functions that have been monitored by this process.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the average execution times of all functions that have been monitored by this process. The dictionary keys are the function names, and the values are the average execution times in ms.</p>"},{"location":"api/control/#egse.control.ControlServer.get_commanding_port","title":"get_commanding_port  <code>abstractmethod</code>","text":"<pre><code>get_commanding_port()\n</code></pre> <p>Returns the commanding port used by the Control Server.</p> <p>Returns:</p> Type Description <code>int</code> <p>Commanding port used by the Control Server, as specified in the settings.</p>"},{"location":"api/control/#egse.control.ControlServer.get_communication_protocol","title":"get_communication_protocol  <code>abstractmethod</code>","text":"<pre><code>get_communication_protocol()\n</code></pre> <p>Returns the communication protocol used by the Control Server.</p> <p>Returns:</p> Type Description <code>str</code> <p>Communication protocol used by the Control Server, as specified in the settings.</p>"},{"location":"api/control/#egse.control.ControlServer.get_ip_address","title":"get_ip_address","text":"<pre><code>get_ip_address()\n</code></pre> <p>Returns the IP address of the current host.</p>"},{"location":"api/control/#egse.control.ControlServer.get_monitoring_port","title":"get_monitoring_port  <code>abstractmethod</code>","text":"<pre><code>get_monitoring_port()\n</code></pre> <p>Returns the monitoring port used by the Control Server.</p> <p>Returns:</p> Type Description <code>int</code> <p>Monitoring port used by the Control Server, as specified in the settings.</p>"},{"location":"api/control/#egse.control.ControlServer.get_process_status","title":"get_process_status","text":"<pre><code>get_process_status()\n</code></pre> <p>Returns the process status of the Control Server.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the process status of the Control Server.</p>"},{"location":"api/control/#egse.control.ControlServer.get_service_port","title":"get_service_port  <code>abstractmethod</code>","text":"<pre><code>get_service_port()\n</code></pre> <p>Returns the service port used by the Control Server.</p> <p>Returns:</p> Type Description <code>int</code> <p>Service port used by the Control Server, as specified in the settings.</p>"},{"location":"api/control/#egse.control.ControlServer.get_storage_mnemonic","title":"get_storage_mnemonic","text":"<pre><code>get_storage_mnemonic()\n</code></pre> <p>Returns the storage mnemonics used by the Control Server.</p> <p>This is a string that will appear in the filename with the housekeeping information of the device, as a way of identifying the device.  If this is not implemented in the subclass, then the class name will be used.</p> <p>Returns:</p> Type Description <code>str</code> <p>Storage mnemonics used by the Control Server, as specified in the settings.</p>"},{"location":"api/control/#egse.control.ControlServer.handle_scheduled_tasks","title":"handle_scheduled_tasks","text":"<pre><code>handle_scheduled_tasks()\n</code></pre> <p>Executes or reschedules tasks in the <code>serve()</code> event loop.</p>"},{"location":"api/control/#egse.control.ControlServer.is_storage_manager_active","title":"is_storage_manager_active","text":"<pre><code>is_storage_manager_active()\n</code></pre> <p>Checks if the Storage Manager is active.</p> <p>This method has to be implemented by the subclass if you need to store information.</p> <p>Note: You might want to set a specific timeout when checking for the Storage Manager.</p> <p>Note: If this method returns True, the following methods shall also be implemented by the subclass:</p> <ul> <li>register_to_storage_manager()</li> <li>unregister_from_storage_manager()</li> <li>store_housekeeping_information()</li> </ul> <p>Returns:</p> Type Description <code>bool</code> <p>True if the Storage Manager is active; False otherwise.</p>"},{"location":"api/control/#egse.control.ControlServer.notify_listeners","title":"notify_listeners","text":"<pre><code>notify_listeners(event_id=0, context=None)\n</code></pre> <p>Notifies registered listeners about an event.</p> <p>This function creates an Event object with the provided <code>event_id</code> and <code>context</code> and notifies all registered listeners with the created event.</p> <p>Parameters:</p> Name Type Description Default <code>event_id</code> <code>int</code> <p>The identifier for the event. Defaults to 0.</p> <code>0</code> <code>context</code> <code>dict</code> <p>Additional context information associated with the event. Defaults to None.</p> <code>None</code> Note <p>The notification is performed by the <code>notify_listeners</code> method of the <code>listeners</code> object associated with this instance. The notification is executed in a daemon thread to avoid blocking the commanding chain.</p>"},{"location":"api/control/#egse.control.ControlServer.quit","title":"quit","text":"<pre><code>quit()\n</code></pre> <p>Interrupts the Control Server.</p>"},{"location":"api/control/#egse.control.ControlServer.register_as_listener","title":"register_as_listener","text":"<pre><code>register_as_listener(proxy, listener)\n</code></pre> <p>Registers a listener with the specified proxy.</p> <p>This function attempts to add the provided listener to the specified proxy. It employs a retry mechanism to handle potential ConnectionError exceptions, making up to 5 attempts to add the listener.</p> <p>Parameters:</p> Name Type Description Default <code>proxy</code> <code>Type</code> <p>A callable object representing the proxy to which the listener will be added.</p> required <code>listener</code> <code>dict</code> <p>The listener to be registered. Should be a dictionary containing listener details.</p> required <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the connection to the proxy encounters issues even after multiple retry attempts.</p> Note <p>The function runs in a separate daemon thread to avoid blocking the main thread.</p>"},{"location":"api/control/#egse.control.ControlServer.register_to_storage_manager","title":"register_to_storage_manager","text":"<pre><code>register_to_storage_manager()\n</code></pre> <p>Registers this Control Server to the Storage Manager.</p> <p>By doing so, the housekeeping information of the device will be sent to the Storage Manager, which will store the information in a dedicated CSV file.</p> <p>This method has to be overwritten by the subclasses if they have housekeeping information that must be stored.</p> <p>Subclasses need to overwrite this method if they have housekeeping information to be stored.</p> <p>The following   information is required for the registration:</p> <ul> <li>origin: Storage mnemonic, which can be retrieved from <code>self.get_storage_mnemonic()</code></li> <li>persistence_class: Persistence layer (one of the TYPES in egse.storage.persistence)</li> <li>prep: depending on the type of the persistence class (see respective documentation)</li> </ul> <p>The <code>egse.storage</code> module provides a convenience method that can be called from the method in the subclass:</p> <pre><code>&gt;&gt;&gt; from egse.storage import register_to_storage_manager  # noqa\n</code></pre> Note <p>the <code>egse.storage</code> module might not be available, it is provided by the <code>cgse-core</code> package.</p>"},{"location":"api/control/#egse.control.ControlServer.schedule_task","title":"schedule_task","text":"<pre><code>schedule_task(callback, after=0.0, when=None)\n</code></pre> <p>Schedules a task to run in the control server event loop.</p> <p>The <code>callback</code> function will be executed as soon as possible in the <code>serve()</code> event loop.</p> <p>Some simple scheduling options are available:</p> <ul> <li>after: the task will only execute 'x' seconds after the time of scheduling. I.e.   the task will be rescheduled until time &gt; scheduled time + 'x' seconds.</li> <li>when: the task will only execute when the condition is True.</li> </ul> <p>The <code>after</code> and the <code>when</code> arguments can be combined.</p> Note <ul> <li>This function is intended to be used in order to prevent a deadlock.</li> <li>Since the <code>callback</code> function is executed in the <code>serve()</code> event loop, it shall not block!</li> </ul>"},{"location":"api/control/#egse.control.ControlServer.serve","title":"serve","text":"<pre><code>serve()\n</code></pre> <p>Activation of the Control Server.</p> <p>This comprises the following steps:</p> <ul> <li>Executing the <code>before_serve</code> method;</li> <li>Checking if the Storage Manager is active and registering the Control Server to it;</li> <li>Start listening  for keyboard interrupts;</li> <li>Start accepting (listening to) commands;</li> <li>Start sending out monitoring information;</li> <li>Start sending out housekeeping information;</li> <li>Start listening for quit commands;</li> <li>After a quit command has been received:<ul> <li>Unregister from the Storage Manager;</li> <li>Execute the <code>after_serve</code> method;</li> <li>Close all sockets;</li> <li>Clean up all threads.</li> </ul> </li> </ul>"},{"location":"api/control/#egse.control.ControlServer.set_hk_delay","title":"set_hk_delay","text":"<pre><code>set_hk_delay(seconds)\n</code></pre> <p>Sets the delay time for housekeeping.</p> <p>The delay time is the time between two successive executions of the <code>get_housekeeping()</code> function of the device protocol.</p> <p>It might happen that the delay time that is set is longer than what you requested. That is the case when the execution of the <code>get_housekeeping()</code> function takes longer than the requested delay time. That should prevent the server from blocking when a too short delay time is requested.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Number of seconds between the housekeeping calls</p> required <p>Returns:</p> Type Description <code>float</code> <p>Delay that was set [ms].</p>"},{"location":"api/control/#egse.control.ControlServer.set_logging_level","title":"set_logging_level","text":"<pre><code>set_logging_level(level)\n</code></pre> <p>Sets the logging level to the given level.</p> <p>Allowed logging levels are:</p> <ul> <li>\"CRITICAL\" or \"FATAL\" or 50</li> <li>\"ERROR\" or 40</li> <li>\"WARNING\" or \"WARN\" or 30</li> <li>\"INFO\" or 20</li> <li>\"DEBUG\" or 10</li> <li>\"NOTSET\" or 0</li> </ul> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | str</code> <p>Logging level to use, specified as either a string or an integer</p> required"},{"location":"api/control/#egse.control.ControlServer.set_mon_delay","title":"set_mon_delay","text":"<pre><code>set_mon_delay(seconds)\n</code></pre> <p>Sets the delay time for monitoring.</p> <p>The delay time is the time between two successive executions of the <code>get_status()</code> function of the device protocol.</p> <p>It might happen that the delay time that is set is longer than what you requested. That is the case when the execution of the <code>get_status()</code> function takes longer than the requested delay time. That should prevent the server from blocking when a too short delay time is requested.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Number of seconds between the monitoring calls</p> required <p>Returns:</p> Type Description <code>float</code> <p>Delay that was set [ms].</p>"},{"location":"api/control/#egse.control.ControlServer.set_scheduled_task_delay","title":"set_scheduled_task_delay","text":"<pre><code>set_scheduled_task_delay(seconds)\n</code></pre> <p>Sets the delay time between successive executions of scheduled tasks.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <p>the time interval between two successive executions [seconds]</p> required"},{"location":"api/control/#egse.control.ControlServer.store_housekeeping_information","title":"store_housekeeping_information","text":"<pre><code>store_housekeeping_information(data)\n</code></pre> <p>Sends housekeeping information to the Storage Manager.</p> <p>This method has to be overwritten by the subclasses if they want the device housekeeping information to be saved.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>a dictionary containing parameter name and value of all device housekeeping. There is also a timestamp that represents the date/time when the HK was received from the device.</p> required"},{"location":"api/control/#egse.control.ControlServer.unregister_as_listener","title":"unregister_as_listener","text":"<pre><code>unregister_as_listener(proxy, listener)\n</code></pre> <p>Removes a registered listener from the specified proxy.</p> <p>This function attempts to remove the provided listener from the specified proxy. It employs a retry mechanism to handle potential ConnectionError exceptions, making up to 5 attempts to add the listener.</p> <p>Parameters:</p> Name Type Description Default <code>proxy</code> <code>Type</code> <p>A callable object representing the proxy from which the listener will be removed.</p> required <code>listener</code> <code>dict</code> <p>The listener to be removed. Should be a dictionary containing listener details.</p> required <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the connection to the proxy encounters issues even after multiple retry attempts.</p> Note <p>The function runs in a separate thread but will block until the de-registration is finished. The reason being that this method is usually called in a <code>after_serve</code> block so it needs to finish before the ZeroMQ context is destroyed.</p>"},{"location":"api/control/#egse.control.ControlServer.unregister_from_storage_manager","title":"unregister_from_storage_manager","text":"<pre><code>unregister_from_storage_manager()\n</code></pre> <p>Unregisters the Control Server from the Storage Manager.</p> <p>This method has to be overwritten by the subclasses.</p> <p>The following information is required for the registration:</p> <ul> <li>origin: Storage mnemonic, which can be retrieved from <code>self.get_storage_mnemonic()</code></li> </ul> <p>The <code>egse.storage</code> module provides a convenience method that can be called from the method in the subclass:</p> <pre><code>&gt;&gt;&gt; from egse.storage import unregister_from_storage_manager  # noqa\n</code></pre> Note <p>the <code>egse.storage</code> module might not be available, it is provided by the <code>cgse-core</code> package.</p>"},{"location":"api/control/#egse.control.is_control_server_active","title":"is_control_server_active","text":"<pre><code>is_control_server_active(endpoint=None, timeout=0.5)\n</code></pre> <p>Checks if the Control Server is running.</p> <p>This function sends a Ping message to the Control Server and expects a Pong answer back within the timeout period.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Endpoint to connect to, i.e. ://: <code>None</code> <code>timeout</code> <code>float</code> <p>Timeout when waiting for a reply [s, default=0.5]</p> <code>0.5</code>"},{"location":"api/counter/","title":"egse.counter","text":"<p>This module manages files that have a counter in their filename.</p> <p>Functions:</p> Name Description <code>counter_exists</code> <p>Returns True if the given file exists, False otherwise.</p> <code>counter_filename</code> <p>Creates an absolute filename to be used as a counter file. A counter file usually has a 'count' extension</p> <code>get_next_counter</code> <p>Read the counter from a dedicated file, add one and save the counter back to the file.</p> <code>new_counter</code> <p>Create a counter based on the files that already exist for the given pattern.</p>"},{"location":"api/counter/#egse.counter.counter_exists","title":"counter_exists","text":"<pre><code>counter_exists(filename)\n</code></pre> <p>Returns True if the given file exists, False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>path of the counter file</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the given filename exists, False otherwise.</p> Note <p>No checking is done if the file is indeed a counter file, i.e. if it contains the correct content.   So, this function basically only checks if the given Path exists and if it is a regular file.</p>"},{"location":"api/counter/#egse.counter.counter_filename","title":"counter_filename","text":"<pre><code>counter_filename(location, filename)\n</code></pre> <p>Creates an absolute filename to be used as a counter file. A counter file usually has a 'count' extension but that is not enforced by this module. The location can be a relative path, even '.' or '..' are accepted.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Path</code> <p>the location of the counter file.</p> required <code>filename</code> <code>Path | str</code> <p>the name of the counter file, use the '.count' extension.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>An absolute filename.</p> Note <p>If the file doesn't exist, it is NOT created.</p>"},{"location":"api/counter/#egse.counter.determine_counter_from_dir_list","title":"determine_counter_from_dir_list","text":"<pre><code>determine_counter_from_dir_list(\n    location, pattern, index=-1\n)\n</code></pre> <p>Determine counter for a new file at the given location and with the given pattern. The next counter is determined from the sorted list of files that match the given pattern.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <p>Location where the file should be stored.</p> required <code>pattern</code> <p>Pattern for the filename.</p> required <code>index</code> <code>int</code> <p>the location of the counter in the filename after it is split on '_' [default=-1]</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The value of the next counter, 1 if no previous files were found or if an error occurred.</p>"},{"location":"api/counter/#egse.counter.get_next_counter","title":"get_next_counter","text":"<pre><code>get_next_counter(filename)\n</code></pre> <p>Read the counter from a dedicated file, add one and save the counter back to the file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <p>full pathname of the file that contains the required counter</p> required <p>Returns:</p> Type Description <code>int</code> <p>The value of the next counter, 1 if no previous files were found or if an error occurred.</p> Note <p>This will create the counter file if it doesn't exist.</p>"},{"location":"api/counter/#egse.counter.new_counter","title":"new_counter","text":"<pre><code>new_counter(filename, pattern)\n</code></pre> <p>Create a counter based on the files that already exist for the given pattern.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>the name of the counter file</p> required <code>pattern</code> <code>str</code> <p>a pattern to match the filenames</p> required <p>Returns:</p> Type Description <code>int</code> <p>The next counter value as an integer.</p>"},{"location":"api/decorators/","title":"egse.decorators","text":"<p>A collection of useful decorator functions.</p> <p>Classes:</p> Name Description <code>Nothing</code> <p>Just to get a nice repr for Nothing. It is kind of a Null object...</p> <code>Profiler</code> <p>A simple profiler class that provides some useful functions to profile a function.</p> <code>classproperty</code> <p>Defines a read-only class property.</p> <p>Functions:</p> Name Description <code>average_time</code> <p>This is a decorator that is intended mainly as a development aid. When you decorate your function with</p> <code>borg</code> <p>Use the Borg pattern to make a class with a shared state between its instances and subclasses.</p> <code>debug</code> <p>Logs the function signature and return value.</p> <code>deprecate</code> <p>Deprecate a function or method. This will print a warning with the function name and where</p> <code>dynamic_interface</code> <p>Adds a static variable <code>__dynamic_interface</code> to a method.</p> <code>profile</code> <p>Prints the function signature and return value to stdout.</p> <code>profile_func</code> <p>A time profiler decorator.</p> <code>query_command</code> <p>Adds a static variable <code>__query_command</code> to a method.</p> <code>read_command</code> <p>Adds a static variable <code>__read_command</code> to a method.</p> <code>retry</code> <p>Decorator that retries a function multiple times with a delay between attempts.</p> <code>retry_with_exponential_backoff</code> <p>Decorator for retrying a function with exponential backoff.</p> <code>singleton</code> <p>Use class as a singleton.</p> <code>spy_on_attr_change</code> <p>Tweak an object to show attributes changing. The changes are reported as WARNING log messages</p> <code>static_vars</code> <p>Define static variables in a function.</p> <code>time_it</code> <p>Print the runtime of the decorated function.</p> <code>timer</code> <p>Print the runtime of the decorated function.</p> <code>to_be_implemented</code> <p>Print a warning message that this function/method has to be implemented.</p> <code>transaction_command</code> <p>Adds a static variable <code>__transaction_command</code> to a method.</p> <code>write_command</code> <p>Adds a static variable <code>__write_command</code> to a method.</p>"},{"location":"api/decorators/#egse.decorators.Nothing","title":"Nothing","text":"<p>Just to get a nice repr for Nothing. It is kind of a Null object...</p>"},{"location":"api/decorators/#egse.decorators.Profiler","title":"Profiler","text":"<p>A simple profiler class that provides some useful functions to profile a function.</p> <ul> <li>count: count the number of times this function is executed</li> <li>duration: measure the total and average duration of the function [seconds]</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from egse.decorators import Profiler\n&gt;&gt;&gt; @Profiler.count()\n... def square(x):\n...     return x**2\n</code></pre> <pre><code>&gt;&gt;&gt; x = [square(x) for x in range(1_000_000)]\n</code></pre> <pre><code>&gt;&gt;&gt; print(f\"Function 'square' called {square.get_count()} times.\")\n&gt;&gt;&gt; print(square)\n</code></pre> <pre><code>&gt;&gt;&gt; @Profiler.duration()\n... def square(x):\n...     time.sleep(0.1)\n...     return x**2\n</code></pre> <pre><code>&gt;&gt;&gt; x = [square(x) for x in range(100)]\n</code></pre> <pre><code>&gt;&gt;&gt; print(f\"Function 'square' takes on average {square.get_average_duration():.6f} seconds.\")\n&gt;&gt;&gt; print(square)\n</code></pre>"},{"location":"api/decorators/#egse.decorators.classproperty","title":"classproperty","text":"<pre><code>classproperty(func)\n</code></pre> <p>Defines a read-only class property.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class Message:\n...     def __init__(self, msg):\n...         self._msg = msg\n...\n...     @classproperty\n...     def name(cls):\n...         return cls.__name__\n\n&gt;&gt;&gt; msg = Message(\"a simple doctest\")\n&gt;&gt;&gt; assert \"Message\" == msg.name\n</code></pre>"},{"location":"api/decorators/#egse.decorators.average_time","title":"average_time","text":"<pre><code>average_time(\n    *, name=\"average_time\", level=INFO, precision=6\n)\n</code></pre> <p>This is a decorator that is intended mainly as a development aid. When you decorate your function with <code>@average_time</code>, the execution time of your function will be kept and accumulated. At anytime in your code, you can request the total execution time and the number of calls:</p> <pre><code>@average_time()\ndef my_function():\n    ...\ntotal_execution_time, call_count = my_function.report()\n</code></pre> <p>Requesting the report will automatically log the average runtime and the number of calls. If you need to reset the execution time and the number of calls during your testing, use:</p> <pre><code>my_function.reset()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A name for the timer that will be used during reporting, default='average_time'</p> <code>'average_time'</code> <code>level</code> <code>int</code> <p>the required log level, default=logging.INFO</p> <code>INFO</code> <code>precision</code> <code>int</code> <p>the precision used to report the average time, default=6</p> <code>6</code> <p>Returns:</p> Type Description <p>The decorated function.</p>"},{"location":"api/decorators/#egse.decorators.borg","title":"borg","text":"<pre><code>borg(cls)\n</code></pre> <p>Use the Borg pattern to make a class with a shared state between its instances and subclasses.</p> from <p>we don't need no singleton</p>"},{"location":"api/decorators/#egse.decorators.debug","title":"debug","text":"<pre><code>debug(func)\n</code></pre> <p>Logs the function signature and return value.</p>"},{"location":"api/decorators/#egse.decorators.deprecate","title":"deprecate","text":"<pre><code>deprecate(reason=None, alternative=None)\n</code></pre> <p>Deprecate a function or method. This will print a warning with the function name and where it is called from. If the optional parameters <code>reason</code> and <code>alternative</code> are given, that information will be printed with the warning.</p> <p>Examples:</p> <pre><code>@deprecate(reason=\"it doesn't follow PEP8\", alternative=\"set_color()\")\ndef setColor(self, color):\n    self.set_color(color)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Optional[str]</code> <p>provide a short explanation why this function is deprecated. Generates 'because {reason}'</p> <code>None</code> <code>alternative</code> <code>Optional[str]</code> <p>provides an alternative function/parameters to be used. Generates 'Use {alternative}</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function.</p>"},{"location":"api/decorators/#egse.decorators.dynamic_interface","title":"dynamic_interface","text":"<pre><code>dynamic_interface(func)\n</code></pre> <p>Adds a static variable <code>__dynamic_interface</code> to a method.</p> <p>The intended use of this function is as a decorator for functions in an interface class.</p> <p>The static variable is currently used by the Proxy class to check if a method is meant to be overridden dynamically. The idea behind this is to loosen the contract of an abstract base class (ABC) into an interface. For an ABC, the abstract methods must be implemented at construction/initialization. This is not possible for the Proxy subclasses as they load their commands (i.e. methods) from the control server, and the method will be added to the Proxy interface after loading. Nevertheless, we like the interface already defined for auto-completion during development or interactive use.</p> <p>When a Proxy subclass that implements an interface with methods decorated by the <code>@dynamic_interface</code> does overwrite one or more of the decorated methods statically, these methods will not be dynamically overwritten when loading the interface from the control server. A warning will be logged instead.</p>"},{"location":"api/decorators/#egse.decorators.profile","title":"profile","text":"<pre><code>profile(func)\n</code></pre> <p>Prints the function signature and return value to stdout.</p> <p>This function checks the <code>Settings.profiling()</code> value and only prints out profiling information if this returns True.</p> <p>Profiling can be activated with <code>Settings.set_profiling(True)</code>.</p>"},{"location":"api/decorators/#egse.decorators.profile_func","title":"profile_func","text":"<pre><code>profile_func(\n    output_file=None,\n    sort_by=\"cumulative\",\n    lines_to_print=None,\n    strip_dirs=False,\n)\n</code></pre> <p>A time profiler decorator.</p> <p>Parameters:</p> Name Type Description Default <code>output_file</code> <p>str or None. Default is None Path of the output file. If only name of the file is given, it's saved in the current directory. If it's None, the name of the decorated function is used.</p> <code>None</code> <code>sort_by</code> <p>str or SortKey enum or tuple/list of str/SortKey enum Sorting criteria for the Stats object. For a list of valid string and SortKey refer to: https://docs.python.org/3/library/profile.html#pstats.Stats.sort_stats</p> <code>'cumulative'</code> <code>lines_to_print</code> <p>int or None Number of lines to print. Default (None) is for all the lines. This is useful in reducing the size of the printout, especially that sorting by 'cumulative', the time consuming operations are printed toward the top of the file.</p> <code>None</code> <code>strip_dirs</code> <p>bool Whether to remove the leading path info from file names. This is also useful in reducing the size of the printout</p> <code>False</code> <p>Returns:</p> Type Description <p>Profile of the decorated function</p> Note <p>This code was taken from this gist: a profile decorator.</p> <p>Inspired by and modified the profile decorator of Giampaolo Rodola: profile decorato.</p>"},{"location":"api/decorators/#egse.decorators.query_command","title":"query_command","text":"<pre><code>query_command(func)\n</code></pre> <p>Adds a static variable <code>__query_command</code> to a method.</p>"},{"location":"api/decorators/#egse.decorators.read_command","title":"read_command","text":"<pre><code>read_command(func)\n</code></pre> <p>Adds a static variable <code>__read_command</code> to a method.</p>"},{"location":"api/decorators/#egse.decorators.retry","title":"retry","text":"<pre><code>retry(times=3, wait=10.0, exceptions=None)\n</code></pre> <p>Decorator that retries a function multiple times with a delay between attempts.</p> <p>This decorator can be applied to a function to handle specified exceptions by retrying the function execution. It will make up to 'times' attempts with a waiting period of 'wait' seconds between each attempt. Any exception from the list provided in the <code>exceptions</code> argument will be ignored for the given <code>times</code>.</p> <p>If after times attempts still an exception is raised, it will be passed through the calling function, otherwise the functions return value will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>times</code> <code>int</code> <p>The number of retry attempts. Defaults to 3.</p> <code>3</code> <code>wait</code> <code>float</code> <p>The waiting period between retries in seconds. Defaults to 10.0.</p> <code>10.0</code> <code>exceptions</code> <code>List[Exception] or None</code> <p>List of exception types to catch and retry. Defaults to None, which catches all exceptions.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Callable</code> <p>The decorated function.</p> Example <p>Apply the retry decorator to a function with specific retry settings:</p> <pre><code>@retry(times=5, wait=15.0, exceptions=[ConnectionError, TimeoutError])\ndef my_function():\n    # Function logic here\n</code></pre> Note <p>The decorator catches specified exceptions and retries the function, logging information about each retry attempt.</p>"},{"location":"api/decorators/#egse.decorators.retry_with_exponential_backoff","title":"retry_with_exponential_backoff","text":"<pre><code>retry_with_exponential_backoff(\n    max_attempts=5,\n    initial_wait=1.0,\n    backoff_factor=2,\n    exceptions=None,\n)\n</code></pre> <p>Decorator for retrying a function with exponential backoff.</p> <p>This decorator can be applied to a function to handle specified exceptions by retrying the function execution. It will make up to 'max_attempts' attempts with a waiting period that grows exponentially between each attempt (dependent on the backoff_factor). Any exception from the list provided in the <code>exceptions</code> argument will be ignored for the given <code>max_attempts</code>.</p> <p>If after all attempts still an exception is raised, it will be passed through the calling function, otherwise the functions return value will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>max_attempts</code> <p>The maximum number of attempts to make.</p> <code>5</code> <code>initial_wait</code> <p>The initial waiting time in seconds before retrying after the first failure.</p> <code>1.0</code> <code>backoff_factor</code> <p>The factor by which the wait time increases after each failure.</p> <code>2</code> <p>Returns:</p> Type Description <p>The response from the executed function.</p>"},{"location":"api/decorators/#egse.decorators.singleton","title":"singleton","text":"<pre><code>singleton(cls)\n</code></pre> <p>Use class as a singleton.</p> from <p>Decorator library: Signleton</p>"},{"location":"api/decorators/#egse.decorators.spy_on_attr_change","title":"spy_on_attr_change","text":"<pre><code>spy_on_attr_change(obj, obj_name=None)\n</code></pre> <p>Tweak an object to show attributes changing. The changes are reported as WARNING log messages in the <code>egse.spy</code> logger.</p> <p>Note this is not a decorator, but a function that changes the class of an object.</p> <p>Note that this function is a debugging aid and should not be used in production code!</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>any object that you want to monitor</p> required <code>obj_name</code> <code>str</code> <p>the variable name of the object that was given in the code, if None than the class name will be printed.</p> <code>None</code> Example <pre><code>class X:\n   pass\n\nx = X()\nspy_on_attr_change(x, obj_name=\"x\")\nx.a = 5\n</code></pre> From <p>Adding a dunder to an object</p>"},{"location":"api/decorators/#egse.decorators.static_vars","title":"static_vars","text":"<pre><code>static_vars(**kwargs)\n</code></pre> <p>Define static variables in a function.</p> <p>The static variable can be accessed with . inside the function body. Example <pre><code>@static_vars(count=0)\ndef special_count():\n    return special_count.count += 2\n</code></pre>"},{"location":"api/decorators/#egse.decorators.time_it","title":"time_it","text":"<pre><code>time_it(count=1000, precision=4)\n</code></pre> <p>Print the runtime of the decorated function.</p> <p>This is a simple replacement for the builtin <code>timeit</code> function. The purpose is to simplify calling a function with some parameters.</p> <p>The intended way to call this is as a function:</p> <pre><code>value = function(args)\n\nvalue = time_it(10_000)(function)(args)\n</code></pre> <p>The <code>time_it</code> function can be called as a decorator in which case it will always call the function <code>count</code> times which is probably not what you want.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>the number of executions [default=1000].</p> <code>1000</code> <code>precision</code> <code>int</code> <p>the number of significant digits [default=4]</p> <code>4</code> <p>Returns:</p> Name Type Description <code>value</code> <p>the return value of the last function execution.</p> See also <p>the <code>Timer</code> context manager located in <code>egse.system</code>.</p> Usage <pre><code>@time_it(count=10000)\ndef function(args):\n    pass\n\ntime_it(10000)(function)(args)\n</code></pre>"},{"location":"api/decorators/#egse.decorators.timer","title":"timer","text":"<pre><code>timer(*, name='timer', level=INFO, precision=4)\n</code></pre> <p>Print the runtime of the decorated function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>a name for the Timer, will be printed in the logging message</p> <code>'timer'</code> <code>level</code> <code>int</code> <p>the logging level for the time message [default=INFO]</p> <code>INFO</code> <code>precision</code> <code>int</code> <p>the number of decimals for the time [default=3 (ms)]</p> <code>4</code>"},{"location":"api/decorators/#egse.decorators.to_be_implemented","title":"to_be_implemented","text":"<pre><code>to_be_implemented(func)\n</code></pre> <p>Print a warning message that this function/method has to be implemented.</p>"},{"location":"api/decorators/#egse.decorators.transaction_command","title":"transaction_command","text":"<pre><code>transaction_command(func)\n</code></pre> <p>Adds a static variable <code>__transaction_command</code> to a method.</p>"},{"location":"api/decorators/#egse.decorators.write_command","title":"write_command","text":"<pre><code>write_command(func)\n</code></pre> <p>Adds a static variable <code>__write_command</code> to a method.</p>"},{"location":"api/exceptions/","title":"egse.exceptions","text":"<pre><code>Exception\n \u251c\u2500\u2500 CGSEException\n \u2502    \u251c\u2500\u2500 Warning\n \u2502    \u2514\u2500\u2500 Error\n \u2502        \u251c\u2500\u2500 InvalidOperationError\n \u2502        \u251c\u2500\u2500 DeviceNotFoundError\n \u2502        \u251c\u2500\u2500 InternalStateError\n \u2502        \u2514\u2500\u2500 DeviceError\n \u2502             \u251c\u2500\u2500 DeviceControllerError\n \u2502             \u251c\u2500\u2500 DeviceConnectionError\n \u2502             \u251c\u2500\u2500 DeviceTimeoutError\n \u2502             \u2514\u2500\u2500 DeviceInterfaceError\n \u251c\u2500\u2500 Failure\n \u251c\u2500\u2500 HexapodError\n \u251c\u2500\u2500 PMACError\n \u251c\u2500\u2500 OGSEError\n \u251c\u2500\u2500 ESLError\n \u251c\u2500\u2500 FilterWheelError\n \u251c\u2500\u2500 FilterWheel8smc4Error\n \u251c\u2500\u2500 ShutterKSC1010Error\n \u251c\u2500\u2500 WindowSizeError\n \u251c\u2500\u2500 SettingsError\n \u2514\u2500\u2500 StagesError\n</code></pre> <p>Classes:</p> Name Description <code>Abort</code> <p>Internal Exception to signal a process to abort.</p> <code>CGSEException</code> <p>The base exception for all errors and warnings in the Common-EGSE.</p> <code>DeviceNotFoundError</code> <p>Raised when a device could not be located, or loaded.</p> <code>Error</code> <p>The base class for all Common-EGSE Errors.</p> <code>FileIsEmptyError</code> <p>Raised when a file is empty and that is unexpected.</p> <code>InternalError</code> <p>Raised when an internal inconsistency occurred in a function, method or class.</p> <code>InternalStateError</code> <p>Raised when an object encounters an internal state inconsistency.</p> <code>InvalidInputError</code> <p>Exception raised when the input is invalid after editing.</p> <code>InvalidOperationError</code> <p>Raised when a certain operation is not valid in the given state,</p> <code>Warning</code> <p>The base class for all Common-EGSE Warnings.</p>"},{"location":"api/exceptions/#egse.exceptions.Abort","title":"Abort","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Internal Exception to signal a process to abort.</p>"},{"location":"api/exceptions/#egse.exceptions.CGSEException","title":"CGSEException","text":"<p>               Bases: <code>Exception</code></p> <p>The base exception for all errors and warnings in the Common-EGSE.</p>"},{"location":"api/exceptions/#egse.exceptions.DeviceNotFoundError","title":"DeviceNotFoundError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when a device could not be located, or loaded.</p>"},{"location":"api/exceptions/#egse.exceptions.Error","title":"Error","text":"<p>               Bases: <code>CGSEException</code></p> <p>The base class for all Common-EGSE Errors.</p>"},{"location":"api/exceptions/#egse.exceptions.FileIsEmptyError","title":"FileIsEmptyError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when a file is empty and that is unexpected.</p>"},{"location":"api/exceptions/#egse.exceptions.InternalError","title":"InternalError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when an internal inconsistency occurred in a function, method or class.</p>"},{"location":"api/exceptions/#egse.exceptions.InternalStateError","title":"InternalStateError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when an object encounters an internal state inconsistency.</p>"},{"location":"api/exceptions/#egse.exceptions.InvalidInputError","title":"InvalidInputError","text":"<p>               Bases: <code>Error</code></p> <p>Exception raised when the input is invalid after editing.</p>"},{"location":"api/exceptions/#egse.exceptions.InvalidOperationError","title":"InvalidOperationError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when a certain operation is not valid in the given state, circumstances or environment.</p>"},{"location":"api/exceptions/#egse.exceptions.Warning","title":"Warning","text":"<p>               Bases: <code>CGSEException</code></p> <p>The base class for all Common-EGSE Warnings.</p>"},{"location":"api/settings/","title":"egse.settings","text":"<p>The Settings class handles user and configuration settings that are provided in a <code>YAML</code> file.</p> <p>The idea is that settings are grouped by components or any arbitrary grouping that makes sense for the application or for the user. Settings are also modular and provided by each package by means of entry-points. The Settings class can read from different YAML files.</p> <p>By default, settings are loaded from a file called <code>settings.yaml</code>, but this can be changed in the entry-point definition.</p> <p>The yaml configuration files are provided as entry points by the packages that specified an entry-point group 'cgse.settings' in the <code>pyproject.toml</code>. The Settings dictionary (attrdict) is constructed from the configuration YAML files from each of the packages. Settings can be overwritten by the next package configuration file. So, make sure the group names in each package configuration file are unique.</p> <p>The YAML file is read and the configuration parameters for the given group are available as instance variables of the returned class.</p> <p>The intended use is as follows:</p> <pre><code>from egse.settings import Settings\n\ndsi_settings = Settings.load(\"DSI\")\n\nif 0x000C &lt;= dsi_settings.RMAP_BASE_ADDRESS &lt;= 0x00FF:\n    ...  # do something here\nelse:\n    raise RMAPError(\"Attempt to access outside the RMAP memory map.\")\n</code></pre> <p>The above code reads the settings from the default YAML file for a group called <code>DSI</code>. The settings will then be available as variables of the returned class, in this case <code>dsi_settings</code>. The returned class is and behaves also like a dictionary, so you can check if a configuration parameter is defined like this:</p> <pre><code>if \"DSI_FEE_IP_ADDRESS\" not in dsi_settings:\n    # define the IP address of the DSI\n</code></pre> <p>The YAML section for the above code looks like this:</p> <pre><code>DSI:\n\n    # DSI Specific Settings\n\n    DSI_FEE_IP_ADDRESS  10.33.178.144   # IP address of the DSI EtherSpaceLink interface\n    LINK_SPEED:                   100   # SpW link speed used for both up- and downlink\n\n    # RMAP Specific Settings\n\n    RMAP_BASE_ADDRESS:     0x00000000   # The start of the RMAP memory map managed by the FEE\n    RMAP_MEMORY_SIZE:            4096   # The size of the RMAP memory map managed by the FEE\n</code></pre> <p>When you want to read settings from another YAML file, specify the <code>filename=</code> keyword. If that file is located at a specific location, also use the <code>location=</code> keyword.</p> <pre><code>my_settings = Settings.load(filename=\"user.yaml\", location=\"/Users/JohnDoe\")\n</code></pre> <p>The above code will read the YAML file from the given location and not from the entry-points.</p> <p>Classes:</p> Name Description <code>Settings</code> <p>The Settings class provides a load() method that loads configuration settings for a group</p> <code>SettingsError</code> <p>A settings-specific error.</p> <p>Functions:</p> Name Description <code>load_global_settings</code> <p>Loads the settings that are defined by the given entry_point. The entry-points are defined in the</p> <code>load_local_settings</code> <p>Loads the local settings file that is defined from the environment variable PROJECT_LOCAL_SETTINGS (where</p> <code>load_settings_file</code> <p>Loads the YAML configuration file that is located at <code>path / filename</code>.</p> <code>read_configuration_file</code> <p>Read the YAML input configuration file. The configuration file is only read</p>"},{"location":"api/settings/#egse.settings.Settings","title":"Settings","text":"<p>The Settings class provides a load() method that loads configuration settings for a group into a dynamically created class as instance variables.</p> <p>Methods:</p> Name Description <code>load</code> <p>Load the settings for the given group. When no group is provided, the</p> <code>to_string</code> <p>Returns a simple string representation of the cached configuration of this Settings class.</p>"},{"location":"api/settings/#egse.settings.Settings.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(\n    group_name=None,\n    filename=\"settings.yaml\",\n    location=None,\n    *,\n    add_local_settings=True,\n    force=False,\n)\n</code></pre> <p>Load the settings for the given group. When no group is provided, the complete configuration is returned.</p> <p>The Settings are loaded from entry-points that are defined in each of the packages that provide a Settings file.</p> <p>If a location is explicitly provided, the Settings will be loaded from that location, using the given filename or the default (which is settings.yaml).</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>the name of one of the main groups from the YAML file</p> <code>None</code> <code>filename</code> <code>str</code> <p>the name of the YAML file to read [default=settings.yaml]</p> <code>'settings.yaml'</code> <code>location</code> <code>(str, Path)</code> <p>the path to the location of the YAML file</p> <code>None</code> <code>force</code> <code>bool</code> <p>force reloading the file</p> <code>False</code> <code>add_local_settings</code> <code>bool</code> <p>update the Settings with site specific local settings</p> <code>True</code> <p>Returns:</p> Type Description <code>attrdict</code> <p>a dynamically created class with the configuration parameters as instance variables.</p> <p>Raises:</p> Type Description <code>SettingsError</code> <p>when the group is not defined in the YAML file.</p>"},{"location":"api/settings/#egse.settings.Settings.to_string","title":"to_string  <code>classmethod</code>","text":"<pre><code>to_string()\n</code></pre> <p>Returns a simple string representation of the cached configuration of this Settings class.</p>"},{"location":"api/settings/#egse.settings.SettingsError","title":"SettingsError","text":"<p>               Bases: <code>Exception</code></p> <p>A settings-specific error.</p>"},{"location":"api/settings/#egse.settings.load_global_settings","title":"load_global_settings","text":"<pre><code>load_global_settings(\n    entry_point=\"cgse.settings\", force=False\n)\n</code></pre> <p>Loads the settings that are defined by the given entry_point. The entry-points are defined in the <code>pyproject.toml</code> files of the packages that export their global settings.</p> <p>Parameters:</p> Name Type Description Default <code>entry_point</code> <code>str</code> <p>the name of the entry-point group [default: 'cgse.settings']</p> <code>'cgse.settings'</code> <code>force</code> <code>bool</code> <p>force reloading the settings, i.e. ignore the cache</p> <code>False</code> <p>Returns:</p> Type Description <code>attrdict</code> <p>A dictionary (attrdict) containing a collection of all the settings exported by the packages         through the given entry-point.</p>"},{"location":"api/settings/#egse.settings.load_local_settings","title":"load_local_settings","text":"<pre><code>load_local_settings(force=False)\n</code></pre> <p>Loads the local settings file that is defined from the environment variable PROJECT_LOCAL_SETTINGS (where PROJECT is the name of your project, defined in the environment variable of the same name).</p> <p>This function might return an empty dictionary when</p> <ul> <li>the local settings YAML file is empty</li> <li>the local settings environment variable is not defined.</li> </ul> <p>in both cases a warning message is logged.</p> <p>Raises:</p> Type Description <code>SettingsError</code> <p>when the local settings YAML file is not found. Check the PROJECT_LOCAL_SETTINGS         environment variable.</p> <p>Returns:</p> Type Description <code>attrdict</code> <p>A dictionary (attrdict) with all local settings.</p>"},{"location":"api/settings/#egse.settings.load_settings_file","title":"load_settings_file","text":"<pre><code>load_settings_file(path, filename, force=False)\n</code></pre> <p>Loads the YAML configuration file that is located at <code>path / filename</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PATH</code> <p>the folder where the YAML file is located</p> required <code>filename</code> <code>str</code> <p>the name of the YAML configuration file</p> required <code>force</code> <code>bool</code> <p>force reloading, i.e. don't use the cached information</p> <code>False</code> <p>Raises:</p> Type Description <code>SettingsError</code> <p>when the configuration file doesn't exist or cannot be found or         when there was an error reading the configuration file.</p> <p>Returns:</p> Type Description <code>attrdict</code> <p>A dictionary (attrdict) with all the settings from the given file.</p> Note <p>in case of an empty configuration file, and empty dictionary         is returned and a warning message is issued.</p>"},{"location":"api/settings/#egse.settings.read_configuration_file","title":"read_configuration_file","text":"<pre><code>read_configuration_file(filename, *, force=False)\n</code></pre> <p>Read the YAML input configuration file. The configuration file is only read once and memoized as load optimization.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>the fully qualified filename of the YAML file</p> required <code>force</code> <code>bool</code> <p>force reloading the file, even when it was memoized</p> <code>False</code> <p>Raises:</p> Type Description <code>SettingsError</code> <p>when there was an error reading the YAML file.</p> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary containing all the configuration settings from the YAML file.</p>"},{"location":"api/setup/","title":"egse.setup","text":""},{"location":"api/setup/#egse.setup--setup","title":"Setup","text":"<p>This module defines the Setup, which contains the complete configuration information for a test.</p> <p>The Setup class contains all configuration items that are specific for a test or observation and is normally (during nominal operation/testing) loaded automatically from the configuration manager. The Setup includes type and identification of hardware that is used, calibration files, software versions, reference frames and coordinate systems that link positions of alignment equipment, conversion functions for temperature sensors, etc.</p> <p>The configuration information that is in the Setup can be navigated in two different ways. First, the Setup is a dictionary, so all information can be accessed by keys as in the following example.</p> <pre><code>&gt;&gt;&gt; setup = Setup({\"gse\": {\"hexapod\": {\"ID\": 42, \"calibration\": [0,1,2,3,4,5]}}})\n&gt;&gt;&gt; setup[\"gse\"][\"hexapod\"][\"ID\"]\n42\n</code></pre> <p>Second, each of the keys is also available as an attribute of the Setup and that make it possible to navigate the Setup with dot-notation:</p> <pre><code>&gt;&gt;&gt; id = setup.gse.hexapod.ID\n</code></pre> <p>In the above example you can see how to navigate from the setup to a device like the PUNA Hexapod. The Hexapod device is connected to the control server and accepts commands as usual. If you want to know which keys you can use to navigate the Setup, use the <code>keys()</code> method.</p> <pre><code>&gt;&gt;&gt; setup.gse.hexapod.keys()\ndict_keys(['ID', 'calibration'])\n&gt;&gt;&gt; setup.gse.hexapod.calibration\n[0, 1, 2, 3, 4, 5]\n</code></pre> <p>To get a full printout of the Setup, you can use the <code>pretty_str()</code> method. Be careful, because this can print out a lot of information when a full Setup is loaded.</p> <pre><code>&gt;&gt;&gt; print(setup)\nSetup\n\u2514\u2500\u2500 gse\n    \u2514\u2500\u2500 hexapod\n        \u251c\u2500\u2500 ID: 42\n        \u2514\u2500\u2500 calibration: [0, 1, 2, 3, 4, 5]\n</code></pre>"},{"location":"api/setup/#egse.setup--special-values","title":"Special Values","text":"<p>Some of the information in the Setup is interpreted in a special way, i.e. some values are processed before returning. Examples are the device classes and calibration/data files. The following values are treated special if they start with:</p> <ul> <li><code>class//</code>: instantiate the class and return the object</li> <li><code>factory//</code>: instantiates a factory and executes its <code>create()</code> method</li> <li><code>csv//</code>: load the CSV file and return a numpy array</li> <li><code>yaml//</code>: load the YAML file and return a dictionary</li> <li><code>pandas//</code>: load a CSV file into a pandas Dataframe</li> <li><code>int-enum//</code>: dynamically create the enumeration and return the Enum object</li> </ul>"},{"location":"api/setup/#egse.setup--device-classes","title":"Device Classes","text":"<p>Most of the hardware components in the Setup will have a <code>device</code> key that defines the class for the device controller. The <code>device</code> keys have a value that starts with <code>class//</code> and it will return the device object. As an example, the following defines the Hexapod device:</p> <pre><code>&gt;&gt;&gt; setup = Setup(\n...   {\n...     \"gse\": {\n...       \"hexapod\": {\"ID\": 42, \"device\": \"class//egse.hexapod.symetrie.puna.PunaSimulator\"}\n...     }\n...   }\n... )\n&gt;&gt;&gt; setup.gse.hexapod.device.is_homing_done()\nFalse\n&gt;&gt;&gt; setup.gse.hexapod.device.info()\n'Info about the PunaSimulator...'\n</code></pre> <p>In the above example you see that we can call the <code>is_homing_done()</code> and <code>info()</code> methodes directly on the device by navigating the Setup. It would however be better (more performant) to put the device object in a variable and work with that variable:</p> <pre><code>&gt;&gt;&gt; hexapod = setup.gse.hexapod.device\n&gt;&gt;&gt; hexapod.homing()\n&gt;&gt;&gt; hexapod.is_homing_done()\nTrue\n&gt;&gt;&gt; hexapod.get_user_positions()\n</code></pre> <p>If you need, for some reason, to have access to the actual raw value of the hexapod device key, use the <code>get_raw_value()</code> method:</p> <pre><code>&gt;&gt;&gt; setup.gse.hexapod.get_raw_value(\"device\")\n&lt;egse.hexapod.symetrie.puna.PunaSimulator object at ...\n</code></pre>"},{"location":"api/setup/#egse.setup--data-files","title":"Data Files","text":"<p>Some information is too large to add to the Setup as such and should be loaded from a data file. Examples are calibration files, flat-fields, temperature conversion curves, etc.</p> <p>The Setup will automatically load the file when you access a key that contains a value that starts with <code>csv//</code> or <code>yaml//</code>.</p> <pre><code>&gt;&gt;&gt; setup = Setup({\n...     \"instrument\": {\"coeff\": \"csv//cal_coeff_1234.csv\"}\n... })\n&gt;&gt;&gt; setup.instrument.coeff[0, 4]\n5.0\n</code></pre> <p>Note: the resource location is always relative to the path defined by the PROJECT_CONF_DATA_LOCATION environment variable.</p> <p>The Setup inherits from a NavigableDict (aka navdict) which is also defined in this module.</p> <p>Classes:</p> Name Description <code>Setup</code> <p>The Setup class represents a version of the configuration of the test facility, the</p> <code>SetupError</code> <p>A setup-specific error.</p> <p>Functions:</p> Name Description <code>get_setup</code> <p>Retrieve the currently active Setup from the configuration manager.</p> <code>list_setups</code> <p>This is a function to be used for interactive use, it will print to the terminal (stdout) a</p> <code>load_last_setup_id</code> <p>Returns the ID of the last Setup that was used by the configuration manager.</p> <code>load_setup</code> <p>This function loads the Setup corresponding with the given <code>setup_id</code>.</p> <code>save_last_setup_id</code> <p>Makes the given Setup ID persistent, so it can be restored upon the next startup.</p> <code>submit_setup</code> <p>Submit the given Setup to the Configuration Manager.</p> <p>Attributes:</p> Name Type Description <code>navdict</code> <p>Shortcut for NavigableDict and more Pythonic.</p>"},{"location":"api/setup/#egse.setup.navdict","title":"navdict  <code>module-attribute</code>","text":"<pre><code>navdict = NavigableDict\n</code></pre> <p>Shortcut for NavigableDict and more Pythonic.</p>"},{"location":"api/setup/#egse.setup.NavigableDict","title":"NavigableDict","text":"<pre><code>NavigableDict(head=None, label=None)\n</code></pre> <p>               Bases: <code>dict</code></p> <p>A NavigableDict is a dictionary where all keys in the original dictionary are also accessible as attributes to the class instance. So, if the original dictionary (setup) has a key \"site_id\" which is accessible as <code>setup['site_id']</code>, it will also be accessible as <code>setup.site_id</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; setup = NavigableDict({'site_id': 'KU Leuven', 'version': \"0.1.0\"})\n&gt;&gt;&gt; assert setup['site_id'] == setup.site_id\n&gt;&gt;&gt; assert setup['version'] == setup.version\n</code></pre> Note <p>We always want all keys to be accessible as attributes, or none. That means all keys of the original dictionary shall be of type <code>str</code>.</p> <pre><code>label (str): a label or name that is used when printing the navdict\n</code></pre> <p>Methods:</p> Name Description <code>add</code> <p>Set a value for the given key.</p> <code>get_private_attribute</code> <p>Returns the value of the given private attribute.</p> <code>get_raw_value</code> <p>Returns the raw value of the given key.</p> <code>has_private_attribute</code> <p>Check if the given key is defined as a private attribute.</p> <code>pretty_str</code> <p>Returns a pretty string representation of the dictionary.</p> <code>set_private_attribute</code> <p>Sets a private attribute for this object.</p>"},{"location":"api/setup/#egse.setup.NavigableDict.add","title":"add","text":"<pre><code>add(key, value)\n</code></pre> <p>Set a value for the given key.</p> <p>If the value is a dictionary, it will be converted into a NavigableDict and the keys will become available as attributes provided that all the keys are strings.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the name of the key / attribute to access the value</p> required <code>value</code> <code>Any</code> <p>the value to assign to the key</p> required"},{"location":"api/setup/#egse.setup.NavigableDict.get_private_attribute","title":"get_private_attribute","text":"<pre><code>get_private_attribute(key)\n</code></pre> <p>Returns the value of the given private attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the name of the private attribute (must start with an underscore character).</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the value of the private attribute given in <code>key</code>.</p> Note <p>Because of the implementation, this private attribute can also be accessed as a 'normal' attribute of the object. This use is however discouraged as it will make your code less understandable. Use the methods to access these 'private' attributes.</p>"},{"location":"api/setup/#egse.setup.NavigableDict.get_raw_value","title":"get_raw_value","text":"<pre><code>get_raw_value(key)\n</code></pre> <p>Returns the raw value of the given key.</p> <p>Some keys have special values that are interpreted by the AtributeDict class. An example is a value that starts with 'class//'. When you access these values, they are first converted from their raw value into their expected value, e.g. the instantiated object in the above example. This method allows you to access the raw value before conversion.</p>"},{"location":"api/setup/#egse.setup.NavigableDict.has_private_attribute","title":"has_private_attribute","text":"<pre><code>has_private_attribute(key)\n</code></pre> <p>Check if the given key is defined as a private attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the name of a private attribute (must start with an underscore)</p> required"},{"location":"api/setup/#egse.setup.NavigableDict.pretty_str","title":"pretty_str","text":"<pre><code>pretty_str(indent=0)\n</code></pre> <p>Returns a pretty string representation of the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>number of indentations (of four spaces)</p> <code>0</code> Note <p>The indent argument is intended for the recursive call of this function.</p>"},{"location":"api/setup/#egse.setup.NavigableDict.set_private_attribute","title":"set_private_attribute","text":"<pre><code>set_private_attribute(key, value)\n</code></pre> <p>Sets a private attribute for this object.</p> <p>The name in key will be accessible as an attribute for this object, but the key will not be added to the dictionary and not be returned by methods like keys().</p> <p>The idea behind this private attribute is to have the possibility to add status information or identifiers to this classes object that can be used by save() or load() methods.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the name of the private attribute (must start with an underscore character).</p> required <code>value</code> <p>the value for this private attribute</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; setup = NavigableDict({'a': 1, 'b': 2, 'c': 3})\n&gt;&gt;&gt; setup.set_private_attribute(\"_loaded_from_dict\", True)\n&gt;&gt;&gt; assert \"c\" in setup\n&gt;&gt;&gt; assert \"_loaded_from_dict\" not in setup\n&gt;&gt;&gt; assert setup.get_private_attribute(\"_loaded_from_dict\") == True\n</code></pre>"},{"location":"api/setup/#egse.setup.Setup","title":"Setup","text":"<pre><code>Setup(nav_dict=None, label=None)\n</code></pre> <p>               Bases: <code>NavigableDict</code></p> <p>The Setup class represents a version of the configuration of the test facility, the test setup and the Camera Under Test (CUT).</p> <p>Methods:</p> Name Description <code>find_devices</code> <p>Returns a dictionary with the devices that are included in the setup.  The keys</p> <code>from_dict</code> <p>Create a Setup from a given dictionary.</p> <code>from_yaml_file</code> <p>Loads a Setup from the given YAML file.</p> <code>from_yaml_string</code> <p>Loads a Setup from the given YAML string.</p> <code>get_filename</code> <p>Returns the filename for this Setup or None when no filename could be determined.</p> <code>get_id</code> <p>Returns the Setup ID (as a string) or None when no setup id could be identified.</p> <code>to_yaml_file</code> <p>Saves a NavigableDict to a YAML file.</p> <code>walk</code> <p>Walk through the given dictionary, in a recursive way, appending the leaf with</p>"},{"location":"api/setup/#egse.setup.Setup.find_devices","title":"find_devices  <code>staticmethod</code>","text":"<pre><code>find_devices(node, devices=None)\n</code></pre> <p>Returns a dictionary with the devices that are included in the setup.  The keys in the dictionary are taken from the \"device_name\" entries in the setup file. The corresponding values in the dictionary are taken from the \"device\" entries in the setup file.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>NavigableDict</code> <p>Dictionary in which to look for the devices (and their names).</p> required <code>devices</code> <code>dict</code> <p>Dictionary in which to include the devices in the setup.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the devices that are included in the setup.</p>"},{"location":"api/setup/#egse.setup.Setup.from_dict","title":"from_dict  <code>staticmethod</code>","text":"<pre><code>from_dict(my_dict)\n</code></pre> <p>Create a Setup from a given dictionary.</p> <p>Remember that all keys in the given dictionary shall be of type 'str' in order to be accessible as attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; setup = Setup.from_dict({\"ID\": \"my-setup-001\", \"version\": \"0.1.0\"})\n&gt;&gt;&gt; assert setup[\"ID\"] == setup.ID == \"my-setup-001\"\n</code></pre>"},{"location":"api/setup/#egse.setup.Setup.from_yaml_file","title":"from_yaml_file  <code>cached</code> <code>staticmethod</code>","text":"<pre><code>from_yaml_file(filename=None, add_local_settings=True)\n</code></pre> <p>Loads a Setup from the given YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the path of the YAML file to be loaded</p> <code>None</code> <code>add_local_settings</code> <code>bool</code> <p>if local settings shall be loaded and override the settings from the YAML file.</p> <code>True</code> <p>Returns:</p> Type Description <p>a Setup that was loaded from the given location.</p>"},{"location":"api/setup/#egse.setup.Setup.from_yaml_string","title":"from_yaml_string  <code>staticmethod</code>","text":"<pre><code>from_yaml_string(yaml_content=None)\n</code></pre> <p>Loads a Setup from the given YAML string.</p> <p>This method is mainly used for easy creation of Setups from strings during unit tests.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_content</code> <code>str</code> <p>a string containing YAML</p> <code>None</code> <p>Returns:</p> Type Description <p>a Setup that was loaded from the content of the given string.</p>"},{"location":"api/setup/#egse.setup.Setup.get_filename","title":"get_filename","text":"<pre><code>get_filename()\n</code></pre> <p>Returns the filename for this Setup or None when no filename could be determined.</p>"},{"location":"api/setup/#egse.setup.Setup.get_id","title":"get_id","text":"<pre><code>get_id()\n</code></pre> <p>Returns the Setup ID (as a string) or None when no setup id could be identified.</p>"},{"location":"api/setup/#egse.setup.Setup.to_yaml_file","title":"to_yaml_file","text":"<pre><code>to_yaml_file(filename=None)\n</code></pre> <p>Saves a NavigableDict to a YAML file.</p> <p>When no filename is provided, this method will look for a 'private' attribute <code>_filename</code> and use that to save the data.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | Path</code> <p>the path of the YAML file where to save the data</p> <code>None</code> Note <p>This method will overwrite the original or given YAML file and therefore you might lose proper formatting and/or comments.</p>"},{"location":"api/setup/#egse.setup.Setup.walk","title":"walk  <code>staticmethod</code>","text":"<pre><code>walk(node, key_of_interest, leaf_list)\n</code></pre> <p>Walk through the given dictionary, in a recursive way, appending the leaf with the given keyword to the given list.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>dict</code> <p>Dictionary in which to look for leaves with the given keyword.</p> required <code>key_of_interest</code> <p>Key to look for in the leaves of the given dictionary.</p> required <code>leaf_list</code> <p>List to which to add the leaves with the given keyword.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Given list with the leaves (with the given keyword) in the given dictionary             appended to it.</p>"},{"location":"api/setup/#egse.setup.SetupError","title":"SetupError","text":"<p>               Bases: <code>Exception</code></p> <p>A setup-specific error.</p>"},{"location":"api/setup/#egse.setup.disentangle_filename","title":"disentangle_filename","text":"<pre><code>disentangle_filename(filename)\n</code></pre> <p>Returns the site_id and setup_id (as a tuple) that is extracted from the Setups filename.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the filename or fully qualified file path as a string.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple (site_id, setup_id).</p>"},{"location":"api/setup/#egse.setup.get_last_setup_id_file_path","title":"get_last_setup_id_file_path","text":"<pre><code>get_last_setup_id_file_path(site_id=None)\n</code></pre> <p>Return the fully expanded file path of the file containing the last loaded Setup in the configuration manager. The default location for this file is the data storage location.</p> <p>Parameters:</p> Name Type Description Default <code>site_id</code> <code>str</code> <p>The SITE identifier (overrides the SITE_ID environment variable)</p> <code>None</code>"},{"location":"api/setup/#egse.setup.get_path_of_setup_file","title":"get_path_of_setup_file","text":"<pre><code>get_path_of_setup_file(setup_id, site_id)\n</code></pre> <p>Returns the Path to the last Setup file for the given site_id. The last Setup file is the file with the largest setup_id number.</p> <p>This function needs the environment variable _CONF_REPO_LOCATION to be defined as the location of the repository with configuration data on your disk. If the repo is not defined, the configuration data location will be used instead. <p>Parameters:</p> Name Type Description Default <code>setup_id</code> <code>int</code> <p>the identifier for the requested Setup</p> required <code>site_id</code> <code>str</code> <p>the test house name, one of CSL, SRON, IAS, INTA</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The full path to the requested Setup file.</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>when the environment variable is not set.</p> <code>NotADirectoryError</code> <p>when either the repository folder or the Setups folder doesn't exist.</p> <code>FileNotFoundError</code> <p>when no Setup file can be found for the given arguments.</p>"},{"location":"api/setup/#egse.setup.get_setup","title":"get_setup","text":"<pre><code>get_setup(setup_id=None)\n</code></pre> <p>Retrieve the currently active Setup from the configuration manager.</p> <p>When a setup_id is provided, that setup will be returned, but not loaded in the configuration manager. This function does NOT change the configuration manager.</p> <p>This function is for interactive use and consults the configuration manager server. Don't use this within the test script, but use the <code>GlobalState.setup</code> property instead.</p>"},{"location":"api/setup/#egse.setup.list_setups","title":"list_setups","text":"<pre><code>list_setups(**attr)\n</code></pre> <p>This is a function to be used for interactive use, it will print to the terminal (stdout) a list of Setups known at the Configuration Manager. This list is sorted with the most recent ( highest) value last.</p> <p>The list can be restricted with key:value pairs (keyword arguments). This search mechanism allows us to find all Setups that adhere to the key:value pairs, e.g. to find all Setups for CSL at position 2, use:</p> <pre><code>&gt;&gt;&gt; list_setups(site_id=\"CSL\", position=2)\n</code></pre> <p>To have a nested keyword search (i.e. search by <code>gse.hexapod.ID</code>) then pass in <code>gse__hexapod__ID</code> as the keyword argument. Replace the '.' notation with double underscores '__'.</p> <pre><code>&gt;&gt;&gt; list_setups(gse__hexapod__ID=4)\n</code></pre>"},{"location":"api/setup/#egse.setup.load_last_setup_id","title":"load_last_setup_id","text":"<pre><code>load_last_setup_id(site_id=None)\n</code></pre> <p>Returns the ID of the last Setup that was used by the configuration manager. The file shall only contain the Setup ID which must be an integer on the first line of the file. If no such ID can be found, the Setup ID = 0 will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>site_id</code> <code>str</code> <p>The SITE identifier</p> <code>None</code>"},{"location":"api/setup/#egse.setup.load_setup","title":"load_setup","text":"<pre><code>load_setup(setup_id=None, site_id=None, from_disk=False)\n</code></pre> <p>This function loads the Setup corresponding with the given <code>setup_id</code>.</p> <p>Loading a Setup means:</p> <ul> <li>that this Setup will also be loaded and activated in the configuration manager,</li> <li>that this Setup will be available from the <code>GlobalState.setup</code></li> </ul> <p>When no setup_id is provided, the current Setup is loaded from the configuration manager.</p> <p>Parameters:</p> Name Type Description Default <code>setup_id</code> <code>int</code> <p>the identifier for the Setup</p> <code>None</code> <code>site_id</code> <code>str</code> <p>the name of the test house</p> <code>None</code> <code>from_disk</code> <code>bool</code> <p>True if the Setup needs to be loaded from disk</p> <code>False</code> <p>Returns:</p> Type Description <code>Setup</code> <p>The requested Setup or None when the Setup could not be loaded from the         configuration manager.</p>"},{"location":"api/setup/#egse.setup.save_last_setup_id","title":"save_last_setup_id","text":"<pre><code>save_last_setup_id(setup_id, site_id=None)\n</code></pre> <p>Makes the given Setup ID persistent, so it can be restored upon the next startup.</p> <p>Parameters:</p> Name Type Description Default <code>setup_id</code> <code>int | str</code> <p>The Setup identifier to be saved</p> required <code>site_id</code> <code>str</code> <p>The SITE identifier</p> <code>None</code>"},{"location":"api/setup/#egse.setup.submit_setup","title":"submit_setup","text":"<pre><code>submit_setup(setup, description)\n</code></pre> <p>Submit the given Setup to the Configuration Manager.</p> <p>When you submit a Setup, the Configuration Manager will save this Setup with the next (new) setup id and make this Setup the current Setup in the Configuration manager unless you have explicitly set <code>replace=False</code> in which case the current Setup will not be replaced with the new Setup.</p> <p>Parameters:</p> Name Type Description Default <code>setup</code> <code>Setup</code> <p>a (new) Setup to submit to the configuration manager</p> required <code>description</code> <code>str</code> <p>one-liner to help identifying the Setup afterwards</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The Setup ID of the newly created Setup or None.</p>"},{"location":"dev_guide/","title":"Developer Guide","text":"<p>Welcome to the CGSE developer guide! An in-depth reference on how to contribute to the CGSE.</p> <p>First thing to know is that this repository is actually a monorepo, meaning it contains a bunch of related but self-standing packages with a minimum of interdependencies. A monorepo can grow quite big and can contain a lot of packages that even different groups are working on. What they have in common is that they use the same guidelines and have the same or a very similar development  workflow.</p> <p>Don't confuse a monorepo with a monolith or a monolithic architecture. While a monorepo holds multiple related but more-or-less independent projects, a monolith is a traditional software application or architecture which is an often huge, self-contained and independent unit of code that is highly coupled and difficult to maintain.</p> <p>Don't confuse a monorepo with microservices either. A microservice architecture contains units that run independently and are developed, scaled and deployed without affecting the other units or services. You can set up a monorepo containing all of your microservices with ease, one does not need the other, but they can perfectly go together.</p>"},{"location":"dev_guide/coding_style/","title":"Style Guide","text":"<p>This part of the developer guide contains instructions for coding styles that are adopted for this project.</p> <p>The style guide that we use for this project is PEP8. This is the standard for Python code and all IDEs, parsers and code formatters understand and work with this standard. PEP8 leaves room for project specific styles. A good style guide that we can follow is the Google Style Guide.</p> <p>The following sections will give the most used conventions with a few examples of good and bad.</p>"},{"location":"dev_guide/coding_style/#tldr","title":"TL;DR","text":"Type Style Example Classes CapWords ProcessManager, ImageViewer, CommandList, Observation, MetaData Methods &amp; Functions lowercase with underscores get_value, set_mask, create_image Variables lowercase with underscores key, last_value, model, index, user_info Constants UPPERCASE with underscores MAX_LINES, BLACK, COMMANDING_PORT Modules &amp; packages lowercase no underscores dataset, commanding, multiprocessing"},{"location":"dev_guide/coding_style/#general","title":"General","text":"<ul> <li> <p>Name the class or variable or function with what it is, what it does or what it contains. A variable named <code>user_list</code> might look good at first, but what if at some point you want to change the list to a set so it can not contain duplicates. Are you going to rename everything into <code>user_set</code> or would <code>user_info</code> be a better name?</p> </li> <li> <p>Never use dashes in any name that will be interpreted by Python, they will raise a <code>SyntaxError:    invalid syntax</code>.</p> </li> <li> <p>We introduce a number of relaxations to not break backward compatibility for the sake of a naming convention. As described in A Foolish Consistency is the Hobgoblin of Little Minds: Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important. [...] do not break backwards compatibility just to comply with this PEP!</p> </li> </ul> <p>Note</p> <p>You will sometimes see that we use one or two words between <code>&lt; &gt;</code> angle brakcets. That means  you will have to replace that text AND the brackets with your own text. As an example, if you see <code>--prompt &lt;venv name&gt;</code>, replace this with something like <code>--prompt cgse-venv</code>.  </p>"},{"location":"dev_guide/coding_style/#classes","title":"Classes","text":"<p>Always use CamelCase (Python uses CapWords) for class names. When using acronyms, keep them all UPPER case.</p> <ul> <li>Class names should be nouns, like Observation</li> <li>Make sure to name classes distinctively</li> <li>Stick to one word for a concept when naming classes, i.e. words like <code>Manager</code> or <code>Controller</code> or <code>Organizer</code> all mean similar things. Choose one word for the concept and stick to it.</li> <li>If a word is already part of a package or module, don't use the same word in the class name again.</li> </ul> <p>Good names are: <code>Observation</code>, <code>CalibrationFile</code>, <code>MetaData</code>, <code>Message</code>, <code>ReferenceFrame</code>, <code>URLParser</code>.</p>"},{"location":"dev_guide/coding_style/#methods-and-functions","title":"Methods and Functions","text":"<p>A function or a method does something (and should only do one thing, SRP=Single Responsibility Principle), it is an action, so the name should reflect that action.</p> <p>Always use lowercase words separated with underscores.</p> <p>Good names are: <code>get_time_in_ms()</code>, <code>get_commanding_port()</code>, <code>is_connected()</code>, <code>parse_time()</code>, <code>setup_mask()</code>.</p> <p>When working with legacy code or code from another project, names may be in camelCase (with the first letter a lower case letter). So we can in this case use also <code>getCommandPort()</code> or <code>isConnected()</code> as method and function names.</p>"},{"location":"dev_guide/coding_style/#variables","title":"Variables","text":"<p>Use the same naming convention as functions and methods, i.e. lowercase with underscores.</p> <p>Good names are: <code>key</code>, <code>value</code>, <code>user_info</code>, <code>model</code>, <code>last_value</code></p> <p>Bad names: <code>NSegments</code>, <code>outNoise</code></p> <p>Take care not to use builtins: <code>list</code>, <code>type</code>, <code>filter</code>, <code>lambda</code>, <code>map</code>, <code>dict</code>, ...</p> <p>Private variables (for classes) start with an underscore: <code>_name</code> or <code>_total_n_args</code>.</p> <p>In the same spirit as method and function names, the variables can also be in camelCase for specific cases.</p>"},{"location":"dev_guide/coding_style/#constants","title":"CONSTANTS","text":"<p>Use ALL_UPPER_CASE with underscores for constants. Use constants always within a name space, not globally.</p> <p>Good names: <code>MAX_LINES</code>, <code>BLACK</code>, <code>YELLOW</code>, <code>ESL_LINK_MODE_DISABLED</code></p>"},{"location":"dev_guide/coding_style/#modules-and-packages","title":"Modules and Packages","text":"<p>Use simple words for modules, preferably just one word like <code>datasets</code> or <code>commanding</code> or <code>storage</code> or <code>extensions</code>. If two words are unavoidable, just concatenate them, like <code>multiprocessing</code> or <code>sampledata</code> or <code>testdata</code>. If needed for readability, use an underscore to separate the words, e.g. <code>image_analysis</code>.</p>"},{"location":"dev_guide/coding_style/#import-statements","title":"Import Statements","text":"<ul> <li>Group and sort import statements</li> <li>Never use the form <code>from &lt;module&gt; import *</code></li> <li>Always use absolute imports in scripts</li> </ul> <p>Be careful that you do not name any modules the same as a module in the Python standard library. This can result in strange effects and may result in an <code>AttributeError</code>. Suppose you have named a module <code>math</code> in the <code>egse</code> directory and it is imported and used further in the code as follows:</p> <pre><code>from egse import math\n\n# in some expression further down the code you might use\n\nmath.exp(a)\n</code></pre> <p>This will result in the following runtime error:</p> <pre><code>File \"some_module.py\", line 8, in &lt;module&gt;\n  print(math.exp(a))\nAttributeError: module 'egse.math' has no attribute 'exp'\n</code></pre> <p>Of course this is an obvious example, but it might be more obscure like e.g. in this GitHub issue: 'module'  object has no attribute 'Cmd'.</p>"},{"location":"dev_guide/docs/","title":"Building the documentation","text":"<ul> <li>Make sure you are in a virtual environment with Python 3.9+ or use the <code>uv</code> commands as   demonstrated below.</li> <li>Run the <code>mkdocs serve</code> from the project root older</li> <li>Create new pages by adding folder and Markdown files inside <code>docs/*</code></li> </ul>"},{"location":"dev_guide/docs/#set-up-your-environment","title":"Set up your environment","text":"<p>The <code>pyproject.toml</code> file of the <code>cgse</code> root contains additional dependencies for running the <code>mkdocs</code> commands. When working on the documentation, make sure you have installed the 'docs' dependency group. Currently, only <code>mkdocs</code> and <code>mkdocs-material</code> are needed. You can use the  following command to add the documentation dependencies to your development environment.</p> <pre><code>$ cd ~/github/cgse\n$ uv sync --all-packages --all-groups\n</code></pre> <p>Now you can start the live-reload server of <code>mkdocs</code>. This will recreate the documentation  whenever you make a change in the files below the <code>docs</code> folder. After starting this command,  navigate to the <code>http://127.0.0.1:8000/cgse/</code> site in your favorite browser.</p> <pre><code>$ uv run mkdocs serve\n</code></pre> <p>Now you can update files, create new folders in <code>docs/*</code>, create new Markdown files and all changes will be reloaded live in the browser.</p> <p>When you are ready with updating, you will need to build the site and publish it on GitHub pages:</p> <pre><code>$ uv run mkdocs build\n$ uv run mkdocs gh-deploy -r upstream -m \"documentation update on ..\"\n</code></pre>"},{"location":"dev_guide/docs/#commands","title":"Commands","text":"<ul> <li><code>mkdocs serve</code> \u2014 start the live-reloading docs server</li> <li><code>mkdocs build</code> \u2014 build the documentation site</li> <li><code>mkdocs deploy</code> \u2014 publish your documentation on GitHub pages</li> <li><code>mkdocs -h</code> \u2014 print a help message for more options</li> </ul>"},{"location":"dev_guide/docs/#project-layout","title":"Project layout","text":"<p>The documentation pages follow more or less the structure of the code in terms of libs and  projects. Below I have laid out this structure leaving out less important files and folders. </p> <pre><code>mkdocs.yml         # the mkdocs configuration file\ndocs\n\u251c\u2500\u2500 index.md       # the documentation homepage\n\u251c\u2500\u2500 initialize.md\n\u251c\u2500\u2500 getting_started.md\n\u251c\u2500\u2500 package_list.md\n\u251c\u2500\u2500 dev_guide/\n\u251c\u2500\u2500 user_guide/\n\u251c\u2500\u2500 libs\n\u2502   \u251c\u2500\u2500 cgse-common/\n\u2502   \u251c\u2500\u2500 cgse-coordinates/\n\u2502   \u251c\u2500\u2500 cgse-core/\n\u2502   \u251c\u2500\u2500 cgse-gui/\n\u2502   \u2514\u2500\u2500 index.md\n\u251c\u2500\u2500 projects/\n\u2502   \u251c\u2500\u2500 cgse-tools.md\n\u2502   \u251c\u2500\u2500 symetrie-hexapod.md\n\u2502   \u2514\u2500\u2500 index.md\n\u251c\u2500\u2500 images/\n\u2514\u2500\u2500 roadmap.md\n</code></pre>"},{"location":"dev_guide/installation/","title":"Installation Guide for Developers","text":""},{"location":"dev_guide/installation/#github","title":"GitHub","text":"<p>Before starting, make sure you have a fork of the <code>cgse</code> repository. Through this fork (which  resides on the GitHub  server) you will create pull requests. Install a clone of your fork on  your local machine or laptop.</p> <p> </p> <p>So, when you have created a fork in your GitHub account, clone the repository on your local  machine.  For the purpose of this guide we will clone the repo in the <code>~/github/cgse</code> folder.  The following commands will create the required folders and clone the repo.</p> <pre><code>$ mkdir -p ~/github\n$ cd ~/github\n$ git clone git@github.com:IvS-KULeuven/cgse.git\n$ cd ~/github/cgse\n</code></pre> <p>Now you will have to create a virtual environment and populated it with all the dependencies. </p> <p>Note</p> <p>The following three commands will get you going quickly: <pre><code>$ uv venv --python 3.9.20\n$ uv sync --all-packages\n$ uv run cgse\n\nUsage: cgse [OPTIONS] COMMAND [ARGS]...\n\nThe main cgse command to inspect, configure, monitor the core services and device control \nservers.\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --install-completion          Install completion for the current shell.                                        \u2502\n\u2502 --show-completion             Show completion for the current shell, to copy it or customize the installation. \u2502\n\u2502 --help                        Show this message and exit.                                                      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 version   Prints the version of the cgse-core and other registered packages.                                   \u2502\n\u2502 top       A top-like interface for core services and device control servers.                                   \u2502\n\u2502 clock     Showcase for running an in-line Textual App.                                                         \u2502\n\u2502 init      Initialize your project.                                                                             \u2502\n\u2502 show      Show information about settings, environment, setup, ...                                             \u2502\n\u2502 check     Check installation, settings, required files, etc.                                                   \u2502\n\u2502 dev-x     device-x is an imaginary device that serves as an example                                            \u2502\n\u2502 core      handle core services: start, stop, status                                                            \u2502\n\u2502 puna      PUNA Positioning Hexapod, Sym\u00e9trie                                                                   \u2502\n\u2502 daq6510   DAQ6510 Data Acquisition Unit, Keithley, temperature monitoring                                      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre></p>"},{"location":"dev_guide/monorepo/","title":"The structure of this monorepo","text":"<p>Currently, the structure starts with two main folders in the root, i.e. <code>libs</code> and <code>projects</code>. Where libs contains library type packages like common modules, small generic gui and tui functions, reference frames, ... and projects contain packages that build upon these libraries and can be device drivers or stand-alone applications.</p> <p>There is one package that I think doesn't fit into this picture, that is <code>cgse-core</code>. This is not a library, but a \u2013 collection of \u2013 service(s). So, we might want to add a third top-level folder <code>services</code> but I also fear that this again more complicates the monorepo.</p> <p>Anyway, the overall structure of the monorepo is depicted below:</p> <pre><code>cgse/\n\u2502\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 libs/\n\u2502   \u251c\u2500\u2500 cgse-common/\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u2514\u2500\u2500 pyproject.toml\n\u2502   \u251c\u2500\u2500 cgse-core/\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u2514\u2500\u2500 pyproject.toml\n\u2502   \u251c\u2500\u2500 cgse-coordinates/\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u2514\u2500\u2500 pyproject.toml\n\u2502   \u2514\u2500\u2500 cgse-gui/\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u2514\u2500\u2500 pyproject.toml\n\u2502\n\u2514\u2500\u2500 projects/\n    \u251c\u2500\u2500 generic/\n    \u2502   \u251c\u2500\u2500 cgse-tools/\n    \u2502   \u251c\u2500\u2500 keithley-tempcontrol/\n    \u2502   \u2514\u2500\u2500 symetrie-hexapod/\n    \u2514\u2500\u2500 plato/\n        \u251c\u2500\u2500 plato-spw/\n        \u251c\u2500\u2500 plato-fits/\n        \u2514\u2500\u2500 plato-hdf5/\n</code></pre> <p>We will discuss the structure of individual packages in a later section, for now let's look at the root of the monorepo. The root also contains a <code>pyproject.toml</code> file although this is not a package that will be build and published. The purpose of this root <code>pyproject.toml</code> file is to define properties that are used to build the full repo or any individual package in it. In the root folder we will also put some maintenance/management scripts to help you maintain and bump versions of the projects, build and publish all projects, create and maintain a changelog etc.</p>"},{"location":"dev_guide/monorepo/#package-structure","title":"Package Structure","text":"<p>We try to keep the package structure as standard as possible and consistent over the whole monorepo. The structure currently is as follows (example from cgse-common):</p> <pre><code>\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 egse/  # namespace, i.e. there shall not be a __init__.py in this folder\n\u2502       \u251c\u2500\u2500 modules (*.py)\n\u2502       \u2514\u2500\u2500 &lt;sub-packages&gt;/  # these do contain a __init__.py\n\u2514\u2500\u2500 tests/\n    \u251c\u2500\u2500 data\n    \u2514\u2500\u2500 pytest modules (test_*.py)\n</code></pre> <p>Note that each library or project is a standalone Python package with its own <code>pyproject.toml</code> file, source code and unit tests.</p>"},{"location":"dev_guide/monorepo/#package-versions","title":"Package versions","text":"<p>All packages in the monorepo will have the same version. This can be maintained with the <code>bump.py</code> script. This script will read the version from the <code>pyproject.toml</code> file at the root of the monorepo and propagate the version to all libs and projects in the monorepo. Note that you \u2013for now\u2013 will have to update the version number in the <code>pyproject.toml</code> file located at the monorepo root folder manually.</p>"},{"location":"dev_guide/monorepo/#the-egse-namespace","title":"The egse namespace","text":"<p>You might have notices that all packages in this monorepo have a <code>src/egse</code> folder in which they maintain their source code, preferably in a sub-package. Note that the <code>egse</code> folder is not a normal Python package but a namespace. There are two important facts you need to remember about namespaces:</p> <ol> <li>A namespace package does not contain an <code>__init__.py</code> module, never, in any of the packages    in this or any other repo. If you place an <code>__init__.py</code> module in one of your <code>egse</code> package    folders, you will break the namespace and therefore also the external contributions in plugins    etc.</li> <li>A namespace package is spread out over several directories that can reside in different packages    as distributed by PyPI.</li> </ol>"},{"location":"dev_guide/monorepo/#egse-versus-cgse","title":"<code>egse</code> versus <code>cgse</code>","text":"<p>Why is there sometimes <code>egse</code> and sometimes <code>cgse</code> used in documentation, folder names etc.? The acronym EGSE stands for Electric Ground Support Equipment and the CGSE stands for Common-EGSE. So, the latter, CGSE, is what we use for the project name, to emphasise its common purpose as a framework for testing instrumentation and for external packages and device drivers to emphasise that they are intended to be common and work well with the CGSE framework. The <code>egse</code> is what the software is about, the electric ground support equipment, and therefore we use this for the namespace, i.e. the root of the library and projects. Using <code>egse</code> as the namespace also avoid  any conflicts with the <code>cgse</code> monorepo name.</p>"},{"location":"dev_guide/plugins/","title":"Plugins","text":"<p>The CGSE is designed to be extensible and uses a few plugin mechanisms to extend its functionally with external contributions. Also within the <code>cgse</code> monorepo we use the plugin mechanism at several places. The following entry-points are currently defined:</p> <ul> <li><code>cgse.version</code>: Each package that provides functionality within the CGSE or adds a device driver   registers itself to provide version information.</li> <li><code>cgse.command</code>: Packages can add commands or sub-commands to the <code>cgse</code> app to manage   their functionality from within the <code>cgse</code> app, e.g. to start or stop the service or to report on   its status.</li> <li><code>cgse.service</code>: Package provides a device driver or another service.</li> <li><code>cgse.settings</code>: Package can add their own settings.</li> <li><code>cgse.explore</code>: Package provides a set of functions to explore, e.g. if any of the processes    it provides are running.</li> <li><code>cgse.resource</code>: Packages can register resources.</li> </ul> <p>Each of the entry-points knows how to load a module or object and each entry-point group is connected to a specific action or plugin hook like, e.g. add a command or command group to the <code>cgse</code> app, add package specific settings to the global settings.</p>"},{"location":"dev_guide/plugins/#version-discovery","title":"Version discovery","text":"<p>When you write a package that you want to integrate with the CGSE, provide a <code>cgse.version</code> entry-point. The name of the entry-point shall match the package name and is used to read the version from the importlib metadata. The entry-point value is currently not used. The entry-point value can optionally provide additional information about the package, but that is currently not specified.</p> <p>Add the following to your <code>pyproject.toml</code> file in your project's root folder, replacing package-name with the name of your project. The entry-point value is currently not used, but you want to use a valid format, the value below is always valid.</p> <pre><code>[project.entry-points.\"cgse.version\"]\npackage-name = 'egse.version:get_version_installed'\n</code></pre>"},{"location":"dev_guide/plugins/#extending-the-cgse-app","title":"Extending the <code>cgse</code> app","text":""},{"location":"dev_guide/plugins/#add-a-command","title":"Add a Command","text":"<p>If your package provides specific functionality that can be added as a command or a command group to the <code>cgse</code> app, use the <code>cgse.command</code> entry-point group. Since the <code>cgse</code> app uses the Typer package to build its commandline interface, adding a command is as simple as writing a function. The function will be added to the <code>cgse</code> app using the <code>app.command()</code> function of <code>Typer</code>, making the function a top-level command of the <code>cgse</code> app. The function can be defined as a plain function or with Typer's <code>@app.command</code> decorator.</p> <p>In the <code>pyproject.toml</code> file of your project, add the following lines to add the CGSE command:</p> <pre><code>[project.entry-points.\"cgse.command\"]\nname = 'module:object'\n</code></pre> <p>Where:</p> <ul> <li><code>name</code> is the name of the command</li> <li><code>module</code> is a fully qualified module name for your package, a module that can be imported</li> <li><code>object</code> is the name of the function that you want to add as a command</li> </ul> <p>As an example, for the <code>cgse-tools</code> package, the <code>init</code> command of the <code>cgse</code> app is listed in the <code>pyproject.toml</code> file as follows:</p> <pre><code>[project.entry-points.\"cgse.command\"]\ninit = 'cgse_tools.cgse_commands:init'\n</code></pre> <p>The <code>init</code> function is defined in the <code>cgse_commands.py</code> module which is located in the <code>cgse_tools</code> module in the <code>src</code> folder of the package:</p> <pre><code>src\n\u251c\u2500\u2500 cgse_tools\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 cgse_commands.py\n...\n</code></pre>"},{"location":"dev_guide/plugins/#add-a-command-group","title":"Add a Command group","text":"<p>Some commands are more complicated and define a number of sub-commands. An example is the <code>show</code> command where you currently have the sub-commands <code>env</code> and <code>settings</code></p> <pre><code>$ cgse show --help\n\n Usage: cgse show [OPTIONS] COMMAND [ARGS]...\n\n Show information about settings, environment, setup, ...\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                           \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 settings   Show the settings that are defined by the installed packages.              \u2502\n\u2502 env        Show the environment variables that are defined for the project.           \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>The <code>show</code> command is defined as a <code>typer.Typer()</code> object where <code>env</code> and <code>settings</code> are added using the decorator <code>@&lt;app&gt;.command()</code>.</p> <pre><code>import typer\n\nshow = typer.Typer(help=\"Show information about settings, environment, setup, ...\")\n\n\n@show.command(name=\"settings\")\ndef show_settings():\n    ...\n\n\n@show.command(name=\"env\")\ndef show_env():\n    ...\n</code></pre> <p>To add this command group to the <code>cgse</code> app, the following entry was used in the <code>pyproject. toml</code> file of the <code>cgse-tools</code> project. Notice the <code>[group]</code> at the end of the entry which indicates this is a command group instead of a single command.</p> <pre><code>[project.entry-points.\"cgse.command\"]\nshow = 'cgse_tools.cgse_commands:show[group]'\n</code></pre>"},{"location":"dev_guide/plugins/#add-a-service","title":"Add a Service","text":"<p>If your package provides a device driver or a specific service, use the <code>cgse.service</code> entry-point group. Service entry-points follow the same scheme as command groups, i.e. they are added to the <code>cgse</code> app as a <code>Typer()</code> object. Use the following entry in your <code>pyproject.toml</code> file:</p> <pre><code>[project.entry-points.\"cgse.service\"]\nname = 'module:object'\n</code></pre> <p>where:</p> <ul> <li><code>name</code> is the name of the service or device driver</li> <li><code>module</code> is a fully qualified module name for your package, a module that can be imported</li> <li><code>object</code> is the name of the <code>Typer()</code> object that you want to add as a service</li> </ul>"},{"location":"dev_guide/plugins/#explore","title":"Explore","text":"<p>The entry-point <code>cgse.explore</code> can be used to extend functionality without adding a new command  or sub-command to the <code>cgse</code> app. The idea is that commands that work on different packages can  use this entry-point to perform certain tasks on the package. This is currently used for the  <code>show procs</code> command (see below).</p> <p>The entry-point has the following format:</p> <pre><code>[project.entry-points.\"cgse.explore\"]\nexplore = \"&lt;package&gt;.cgse_explore\"\n</code></pre> <p>So, what happens is that a command that wants to apply a functionality on an external package  loads the <code>cgse_explore.py</code> module for that package and checks if a function with a specific  name exists in that module. It then executes that function. For the <code>show procs</code> command, the  function <code>show_processes</code> is expected and it shall return a list of strings which currently are  printed to the terminal. This entry-point is currently implemented for <code>cgse-core</code> and  <code>cgse-dummy</code> (an external demo package) and when you run the <code>cgse show procs</code> command it looks  something like below (the format is from the unix <code>ps -ef</code> command). </p> <pre><code>\u279c  cgse show procs\n459800007 76849     1   0 11:07PM ttys003    0:03.53 /Users/rik/tmp/test_dummy/venv/bin/python3.9 -m egse.logger.log_cs start\n459800007 76850     1   0 11:07PM ttys003    2:18.60 /Users/rik/tmp/test_dummy/venv/bin/python3.9 -m egse.storage.storage_cs start\n459800007 76851     1   0 11:07PM ttys003    2:20.10 /Users/rik/tmp/test_dummy/venv/bin/python3.9 -m egse.confman.confman_cs start\n459800007 13825     1   0  4:31PM ttys003    0:02.97 /Users/rik/tmp/test_dummy/venv/bin/python3.9 -m cgse_dummy.dummy_sim start\n</code></pre>"},{"location":"dev_guide/plugins/#register-resources","title":"Register resources","text":"<p>TODO: what if two packages provide a resource <code>icons</code> ?</p> <ul> <li>known resources: icons, styles</li> </ul>"},{"location":"dev_guide/unit_testing/","title":"Testing the Software","text":"<p>We use the <code>pytest</code> package to unit test our modules and packages. The <code>pyproject.toml</code> files are configured for  each package to perform the testing. This section will guide you through the steps to run the tests and also explain  how we configured the tests and some guidelines we used.</p>"},{"location":"dev_guide/unit_testing/#running-the-unit-test-for-each-package-separately","title":"Running the unit test for each package separately","text":"<p>If you are working on a particular package and want to run its unit test, make sure you are in the root folder of  that package, e.g. for the <code>cgse-common</code> package, do the following:</p> <pre><code>$ cd ~/github/cgse/libs/cgse-common/\n$ uv sync\n$ uv run pytest -v\n================================================================ test session starts =================================================================\nplatform darwin -- Python 3.9.20, pytest-8.3.4, pluggy-1.5.0 -- /Users/rik/github/cgse/.venv/bin/python3\ncachedir: .pytest_cache\nrootdir: /Users/rik/github/cgse/libs/cgse-common\nconfigfile: pyproject.toml\nplugins: cov-6.0.0, mock-3.14.0\ncollected 161 items\n\ntest_bits.py::test_clear_bit PASSED                                                                                                            [  0%]\ntest_bits.py::test_set_bit PASSED                                                                                                              [  1%]\ntest_bits.py::test_toggle_bit PASSED                                                                                                           [  1%]\ntest_bits.py::test_beautify_binary PASSED                                                                                                      [  2%]\ntest_bits.py::test_set_bits PASSED                                                                                                             [  3%]\ntest_bits.py::test_alternative_set_bits PASSED                                                                                                 [  3%]\ntest_bits.py::test_clear_bits PASSED                                                                                                           [  4%]\ntest_bits.py::test_crc_calc PASSED                                                                                                             [  4%]\ntest_bits.py::test_humanize_bytes PASSED                                                                                                       [  5%]\ntest_bits.py::test_s16 PASSED                                                                                                                  [  6%]\ntest_bits.py::test_s32 PASSED                                                                                                                  [  6%]\ntest_command.py::test_dry_run PASSED                                                                                                           [  7%]\ntest_command.py::test_command_class PASSED                                                                                                     [  8%]\ntest_command.py::test_return_code_of_execute PASSED                                                                                            [  8%]\n...\n</code></pre>"},{"location":"dev_guide/unit_testing/#running-the-unit-tests-of-all-packages","title":"Running the unit tests of all packages","text":"<p>Before releasing the software, we should run all the unit tests of all the packages in the monorepo and have green  light \ud83d\udfe2. Running these unit tests is as simple as for the individual packages. You will need to be in the root folder  of the monorepo and sync your virtual environment for all the packages in the workspace.</p> <pre><code>$ cd ~/gitbug/cgse\n$ uv sync --all-packages\n$ uv run pytest -v\n</code></pre>"},{"location":"dev_guide/uv/","title":"Working with <code>uv</code>","text":"<p><code>uv</code> is an extremely fast Python package and project manager, written in Rust. We will use <code>uv</code> as the single tool that replaces <code>pip</code>, <code>virtualenv</code>, <code>pyenv</code>, and more. The main tasks for which we will use <code>uv</code> are:</p> <ul> <li>run and install Python versions</li> <li>installing and managing a virtual environment</li> <li>build all the packages in the workspace or monorepo</li> <li>publish all the packages to PyPI</li> <li>run scripts and apps</li> </ul>"},{"location":"dev_guide/uv/#installing-uv","title":"Installing <code>uv</code>","text":"<p>On macOS and Linux you can install <code>uv</code> using <code>curl</code>:</p> <pre><code>$ curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>If you need more specific information on installing and upgrading <code>uv</code>, please refer to the official documentation.</p>"},{"location":"dev_guide/uv/#installing-a-python-version","title":"Installing a Python version","text":"<p>The CGSE is guaranteed to work with Python 3.9.x. We will gradually include higher versions of Python, but currently  these have not been tested. So, we will for the moment stick with Python 3.9.20. Install this version as follows:</p> <pre><code>$ uv python install 3.9.20\n</code></pre> <p><code>pyenv</code></p> <p>When you are using <code>pyenv</code> to manage your Python versions, make sure you also have the same  Python version installed with <code>pyenv</code> and <code>uv</code>. Otherwise you will run into the following  error. This is a known issue with <code>uv</code>.</p> <pre><code>pyenv: version `3.9.20' is not installed (set by /Users/rik/github/cgse/libs/cgse-common/.python-version)\n</code></pre> <p>You can check which Python versions are installed already on your system:</p> CommandOutput <pre><code>$ uv python list --only-installed\n</code></pre> <pre><code>cpython-3.12.8-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.12.8-macos-aarch64-none/bin/python3.12\ncpython-3.10.16-macos-aarch64-none    /Users/rik/Library/Application Support/uv/python/cpython-3.10.16-macos-aarch64-none/bin/python3.10\ncpython-3.9.21-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.9.21-macos-aarch64-none/bin/python3.9\ncpython-3.9.20-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.9.20-macos-aarch64-none/bin/python3.9\ncpython-3.9.6-macos-aarch64-none      /Library/Developer/CommandLineTools/usr/bin/python3 -&gt; ../../Library/Frameworks/Python3.framework/Versions/3.9/bin/python3\ncpython-3.8.17-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.8.17-macos-aarch64-none/bin/python3.8\n</code></pre>"},{"location":"dev_guide/uv/#create-a-virtual-environment","title":"Create a virtual environment","text":"<p>Pin a Python version</p> <p>You can pin a python version with the command:</p> <pre><code>$ uv python pin 3.9.20\n</code></pre> <p><code>uv</code> will search for a pinned version in the parent folders up to the root folder or your home directory.</p> <p>You can create a virtual environment with <code>uv</code> for the specific Python version as follows. The  '<code>--python</code>' is optional  and <code>uv</code> will use the default (pinned) Python version when creating a  <code>venv</code> without this option. We are working in a monorepo or what <code>uv</code> calls a workspace. There  will be only one virtual environment at the root of the monorepo, despite the fact that we have  several individual packages in our workspace. Don't worry, <code>uv</code> will always use the virtual  environment at the root and keep it up-to-date with the project your are currently working in.</p> <p>When creating a virtual environment make sure you are in the root folder, e.g. <code>~/github/cgse</code>.</p> <p><pre><code>$ cd ~/github/cgse\n$ uv venv --python 3.9.20\n</code></pre> If you want to name your virtual environment, use the optional argument <code>--prompt &lt;venv name&gt;</code> in  the above command, otherwise the virtual environment will get the same name as the project, i.e.  <code>cgse</code>.</p> <p>Now, navigate to the package you will be working in and update the projects' environment,  assuming you are going to work in <code>cgse-core</code>, this will be:</p> <pre><code>$ cd ~/github/cgse/libs/cgse-core\n$ uv sync\n</code></pre> <p>Your package(s) from the workspace should be installed as an editable install. You can check  this with the command:</p> <pre><code>$ uv pip list -v\nUsing Python 3.9.20 environment at: /Users/rik/github/cgse/.venv\nPackage           Version     Editable project location\n----------------- ----------- ---------------------------------------\napscheduler       3.11.0\ncgse-common       0.4.0       /Users/rik/github/cgse/libs/cgse-common\ncgse-core         0.4.0       /Users/rik/github/cgse/libs/cgse-core\n...\n</code></pre> <p>To install any other project as an editable package:</p> <pre><code>$ uv pip install -e &lt;project location&gt;\n</code></pre> <p>Note</p> <p>If you don't want to use the <code>uv</code> commands, you can activate the virtual environment and use the original <code>pip</code>  and <code>python</code> commands as you are used to, but I would recommend you try to get used to <code>uv</code>  for a while to experience its benefits.</p> <pre><code>$ source ~/github/cgse/.venv/bin/activate\n</code></pre> <p>Info</p> <p>In a workspace, maintaining a virtual environment per package might be a hassle and most of the time that is not  needed. A good approach is to always use the virtual environment at the workspace root. This <code>venv</code> which will be  automatically created if you run a command or if you use <code>uv sync</code> in the package folder. With <code>uv sync</code> you can  make sure the virtual environment is up-to-date and contains only those dependencies that are required for the  package you are in. So, each time you switch to another package and want to run a comand or a test for that  package, use </p> <pre><code>$ uv sync\n</code></pre>"},{"location":"dev_guide/uv/#building-and-publishing-all-packages","title":"Building and publishing all packages","text":"<p>We have chosen for one and the same version number for all packages in the <code>cgse</code> monorepo. That means that whenever  we make a change to one of the packages and want to release that change, all packages shall be rebuild and published.</p> <p>Inline</p> <p>When working in a workspace, keep in mind that the commands <code>uv run</code> and <code>uv sync</code> by default work on the  workspace root. That means that when you run the <code>uv run pip install &lt;package&gt;</code> command, the <code>.venv</code> at the  workspace root will be updated or created if it didn't exist. Similar for the <code>uv sync</code> command, there is only  one <code>uv.lock</code> file at the root of the workspace.  </p> <p>Fortunately, with <code>uv</code>, that is done in a few commands.</p> <p>When you are in the monorepo root folder, you can build all packages at once. They will be placed in the <code>dist</code> folder  of the root package. Before building, make sure you update the version in the <code>pyproject.toml</code> of the root package  and then bump the versions. Before building, clean up the <code>dist</code> folder, then you can do a default <code>uv publish</code> afterwards.</p> <pre><code>$ cd &lt;monorepo root&gt;\n$ uv run bump.py\n$ rm -r dist\n$ uv build --all-packages\n</code></pre> <p>Publish all packages in the root dist folder to PyPI. The UV_PUBLISH_TOKEN can be defined in a (read protected) ~/. setenv.bash file:</p> <pre><code>$ uv publish --token $UV_PUBLISH_TOKEN\n</code></pre> <p>The above command will publish all package to PyPI. If you don't want the token to be in a shell variable, you can  omit the <code>--token</code> in the command above. You will then be asked for a username, use <code>__token__</code> as the username and  then provide the token as a password.</p>"},{"location":"dev_guide/versioning/","title":"Semantic Versioning","text":"<p>We use semantic versioning, aka semver, for our releases and patches. Please follow the rules that are described on their site.</p> <p>TL;DR</p> <p>The version number has the format <code>MAJOR.MINOR.PATH</code>, we increment the</p> <ul> <li>MAJOR version when we make incompatible changes</li> <li>MINOR version when we add or change functionality in a backward compatible manner</li> <li>PATCH version when we make backward compatible bug fixes</li> </ul> <p>The rules above apply when MAJOR &gt;= 1, which are considered stable releases.</p> <p>As long as MAJOR == 0, we are in initial development and anything may change. The MINOR number will be increased for adding or removing functionality and the PATCH number will be increased for all kinds of fixes.</p> <p>You might occasionally see pre-release and build metadata added to the version number. We will use the following metadata:</p> <ul> <li><code>-dev.X</code> \u2014 a development release where X &gt;= 1. This will be used for releases where we need to   test PyPI installations and/or GitHub actions. A development release can be added to any PATCH    number. An example development release: <code>2.3.1-dev.1</code>.</li> <li><code>-rc.X</code> \u2014 a release candidate where X &gt;= 1. This is a pre-release and contains all the intended   features. The release is believed to be stable enough for public testing, but isn't yet considered   the final production version. There might be more than one release candidate. Release    candidates are usually used for releases where PATCH == 0. For example, when we   have a third release candidate <code>1.2.0-rc.3</code> the actual released version will then be <code>1.2.0</code>.</li> </ul>"},{"location":"dev_guide/versioning/#why-not-calver","title":"Why not CalVer?","text":"<p>We do not use Calendar Versioning for the following reason:</p> <ul> <li>Calendar versioning is preferred for projects that have a release schedule that is based on dates,   like every week or every three months.</li> <li>Semantic versioning is preferred when no date related release schedule is foreseen, also major   version 0 means that API is not yet fixed and everything can change. Our project is in that state   right now.</li> </ul>"},{"location":"libs/","title":"Libraries","text":"<p>The libraries are those packages that make up the CGSE framework.</p> <p>The libraries are located under the <code>libs</code> folder, and we currently find the following packages there:</p> <ul> <li><code>cgse-common</code></li> <li><code>cgse-core</code></li> <li><code>cgse-coordinates</code></li> <li><code>cgse-gui</code></li> </ul>"},{"location":"libs/cgse-common/","title":"Common Code","text":"<p>This package <code>cgse-common</code> contains modules that are used by all other packages. </p> Module Name Description <code>egse.bits</code> convenience functions to work with bits, bytes and integers <code>egse.calibration</code> functions to handle conversions and apply correction <code>egse.command</code> classes and functions to work with commands that operate hardware devices <code>egse.config</code> convenience functions to configure the system and find folders and files <code>egse.control</code> defines abstract classes and convenience functions for any control server <code>egse.decorators</code> a collection of useful decorator functions <code>egse.device</code> defines the generic interfaces to connect devices <code>egse.env</code> functionality to work with and check your environment variables <code>egse.exceptions</code> common Exceptions and Errors <code>egse.hk</code> functions to retrieve and convert housekeping parameter values <code>egse.metrics</code> functions to define and update metrics <code>egse.mixin</code> defines the mixin classes for dynamic commanding <code>egse.monitoring</code> the monitoring application / function <code>egse.observer</code> the classic observer and observable <code>egse.obsid</code> functions to define and work with the OBSID <code>egse.persistence</code> the persistence layer interface <code>egse.plugin</code> functions to load plugins and settings from entry-points <code>egse.process</code> functions and classes to work with processes and sub-processes <code>egse.protocol</code> base class for communicating commands with the hardware or the control server <code>egse.proxy</code> base class for the Proxy objects for each device controller <code>egse.reload</code> a slightly better approach to reloading modules and function <code>egse.resource</code> convenience functions to use resources in your code <code>egse.response</code> defines the classes to handle responses from the control servers <code>egse.services</code> provides the services to the control servers <code>egse.settings</code> provides functions to handle user and configuration settings <code>egse.setup</code> defines the Setup, containing the complete configuration for a test <code>egse.state</code> classes and functions to handle state, e.g. the GlobalState <code>egse.system</code> convenience functions that provide information on system specific functionality <code>egse.version</code> functions to load specific version information <code>egse.zmq_ser</code> serialization function used in a ZeroMQ context"},{"location":"libs/cgse-common/settings/","title":"The Settings","text":"<p>The Settings class contains all static information needed to configure your system, the environment you are using and the test equipment. The Settings also contain all the IP addresses and port number for all the known devices, together with other static information like the device name, default settings for the device like speed, timeout, delay time, firmware version, etc. We will go into more details about the content later, let\u2019s now first look at the format and usage of the Settings.</p>"},{"location":"libs/cgse-common/settings/#loading-the-settings","title":"Loading the Settings","text":"<p>The Settings can be loaded as follows:</p> <pre><code>&gt;&gt;&gt; from egse.settings import Settings\n&gt;&gt;&gt; settings = Settings.load()\n</code></pre> <p>The <code>settings</code> object will be a dictionary where the keys are the top-level groups that are defined in the settings for each package. For a system that has only <code>cgse-common</code> and <code>cgse-core</code> installed, the <code>settings</code> will contain something like this:</p> <pre><code>&gt;&gt;&gt; print(settings)\nSettings\n\u251c\u2500\u2500 PACKAGES\n\u2502   \u251c\u2500\u2500 CGSE_COMMON: Common classes, functions, decorators, etc. for the CGSE\n\u2502   \u2514\u2500\u2500 CGSE_CORE: The core services of the CGSE\n\u251c\u2500\u2500 SITE\n\u2502   \u251c\u2500\u2500 ID: LAB42\n\u2502   \u251c\u2500\u2500 SSH_SERVER: localhost\n\u2502   \u2514\u2500\u2500 SSH_PORT: 22\n\u251c\u2500\u2500 PROCESS\n\u2502   \u2514\u2500\u2500 METRICS_INTERVAL: 10\n\u251c\u2500\u2500 Logging Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 LOGGING_PORT: 7000\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 7001\n\u2502   \u251c\u2500\u2500 METRICS_PORT: 7003\n\u2502   \u251c\u2500\u2500 MAX_NR_LOG_FILES: 20\n\u2502   \u251c\u2500\u2500 MAX_SIZE_LOG_FILES: 20\n\u2502   \u251c\u2500\u2500 TEXTUALOG_IP_ADDRESS: 127.0.0.1\n\u2502   \u2514\u2500\u2500 TEXTUALOG_LISTENING_PORT: 19996\n\u251c\u2500\u2500 Configuration Manager Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 6000\n\u2502   \u251c\u2500\u2500 MONITORING_PORT: 6001\n\u2502   \u251c\u2500\u2500 SERVICE_PORT: 6002\n\u2502   \u251c\u2500\u2500 METRICS_PORT: 6003\n\u2502   \u251c\u2500\u2500 DELAY: 1\n\u2502   \u2514\u2500\u2500 STORAGE_MNEMONIC: CM\n\u2514\u2500\u2500 Storage Control Server\n    \u251c\u2500\u2500 PROTOCOL: tcp\n    \u251c\u2500\u2500 HOSTNAME: localhost\n    \u251c\u2500\u2500 COMMANDING_PORT: 6100\n    \u251c\u2500\u2500 MONITORING_PORT: 6101\n    \u251c\u2500\u2500 SERVICE_PORT: 6102\n    \u251c\u2500\u2500 METRICS_PORT: 6103\n    \u2514\u2500\u2500 DELAY: 1\n</code></pre> <p>If you only need the settings for a particular component, specify that group's name:</p> <pre><code>&gt;&gt;&gt; storage_settings = Settings.load(\"Storage Control Server\")\n\n&gt;&gt;&gt; print(storage_settings)\nStorage\nControl\nServer\n\u251c\u2500\u2500 PROTOCOL: tcp\n\u251c\u2500\u2500 HOSTNAME: localhost\n\u251c\u2500\u2500 COMMANDING_PORT: 6100\n\u251c\u2500\u2500 MONITORING_PORT: 6101\n\u251c\u2500\u2500 SERVICE_PORT: 6102\n\u251c\u2500\u2500 METRICS_PORT: 6103\n\u2514\u2500\u2500 DELAY: 1\n</code></pre> <p>The values can be accessed as usual with a dictionary, by specifying the name of the parameter as the key:</p> <pre><code>&gt;&gt;&gt; print(storage_settings[\"COMMANDING_PORT\"])\n6100\n</code></pre> <p>We usually only go one level deep when defining settings, and as a convenience, that first level of variables can also be accessed with the dot-notation.</p> <pre><code>&gt;&gt;&gt; print(storage_settings.COMMANDING_PORT)\n6100\n</code></pre>"},{"location":"libs/cgse-common/settings/#entry-points","title":"Entry-points","text":"<p>The Settings are collected from a set of YAML files which are provided by the packages through the entry-point <code>cgse.settings</code>. The default Settings file is named <code>settings.yaml</code> but this can be changed by the entry-point (see below).</p> <p>Let's take a look at how the settings are provided for the <code>cgse-core</code> package. First, the <code>pyproject.toml</code> file of the project shall define the entry-point. In the snippet below, the entry-point <code>cgse-core</code> is defined for the group <code>cgse.settings</code>.</p> <pre><code>[project.entry-points.\"cgse.settings\"]\ncgse-core = \"cgse_core:settings.yaml\"\n</code></pre> <p>The entry-point itself has the following format: <code>&lt;name&gt; = \"&lt;module&gt;.&lt;filename&gt;\"</code>, where</p> <ul> <li><code>&lt;name&gt;</code> is the name of the entry-point given in the <code>pyproject.toml</code> file, usually this is the package name,</li> <li><code>&lt;module&gt;</code> is a valid module name that can be imported and from which the location can be determined, and</li> <li><code>&lt;filename&gt;</code> is the name of the target file, e.g. a YAML file.</li> </ul> <p>Note</p> <p>The module name for this entry point has an underscore instead of a dash, i.e. <code>cgse_core</code> instead of  <code>cgse-core</code>. The reason is that module names with a dash will generate a SyntaxError during import.</p> <p>The above example will load the settings for this package from the <code>settings.yaml</code> file that is located in the <code>cgse_core</code> module. That is, the package shall also provide this as follows:</p> <pre><code>cgse-core\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 cgse_core\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 settings.yaml\n</code></pre> <p>The <code>settigs.yaml</code> file for this module looks something like this:</p> <pre><code>PACKAGES:\n    CGSE_CORE: The core services of the CGSE\n\nLogging Control Server:                          # LOG_CS\n\n    PROTOCOL:                       tcp\n    HOSTNAME:                 localhost          # The hostname that client shall connect to, e.g. pleiad01 @ KU Leuven\n    LOGGING_PORT:                  7000\n    COMMANDING_PORT:               7001\n    METRICS_PORT:                  7003          # The HTTP port where Prometheus will connect to for retrieving metrics\n    MAX_NR_LOG_FILES:                20          # The maximum number of log files that will be maintained in a roll-over\n    MAX_SIZE_LOG_FILES:              20          # The maximum size one log file can become\n    TEXTUALOG_IP_ADDRESS:     127.0.0.1          # The IP address of the textualog listening server\n    TEXTUALOG_LISTENING_PORT:     19996          # The port number on which the textualog server is listening\n\nConfiguration Manager Control Server:            # CM_CS\n\n    ...\n</code></pre> <p>Warning</p> <p>Please note that the module where the Settings YAML file resides is a Python package and not  a namespace. That means it shall have a <code>__init__.py</code> file as shown in the example of the  <code>cgse_core</code> module above.</p> <p>If the <code>__init__.py</code> file is not there, you will get an error like below:</p> <pre><code>ERROR:egse.plugin:The entry-point 'cgse-coordinates' is ill defined. The module part doesn't \nexist or is a namespace. No settings are loaded for this entry-point.\n</code></pre>"},{"location":"libs/cgse-common/settings/#local-settings","title":"Local Settings","text":"<p>You can, and you should, define local settings for your project and put those settings in a known folder on your system. The usual place is <code>~/cgse/local-settings.yaml</code>. This file will be automatically loaded by the <code>Settings.load()</code> function when you define the local settings environment variable. That variable name is <code>&lt;PROJECT&gt;_LOCAL_SETTINGS</code> where <code>&lt;PROJECT&gt;</code> is the name of your project as defined by the <code>PROJECT</code> environment variable. For a <code>PROJECT=LAB23</code> the local settings would be defined as follows:</p> <pre><code>$ export LAB23_LOCAL_SETTINGS=~/cgse/local-settings-lab23.yaml\n</code></pre> <p>The local settings take higher precedence that will overwrite the global settings when loaded. You only need to define the settings that actually change for your local installation, respect the full hierarchy when specifying those settings. You are allowed to define new entries at any level in the Settings hierarchy.</p> <p>The usual parameters to put into a local settings file are:</p> <ul> <li>the SITE ID</li> <li>the hostnames of the different devices that you use</li> <li>the hostname of the server where core services or device control servers are running</li> <li>port numbers that have been changed from the default</li> </ul>"},{"location":"libs/cgse-common/settings/#terminal-command","title":"Terminal Command","text":"<p>You can check the current settings from the terminal with the following command:</p> <pre><code>$ py -m egse.settings\nSettings\n\u251c\u2500\u2500 PACKAGES\n\u2502   \u251c\u2500\u2500 CGSE_COMMON: Common classes, functions, decorators, etc. for the CGSE\n\u2502   \u2514\u2500\u2500 CGSE_CORE: The core services of the CGSE\n\u251c\u2500\u2500 SITE\n\u2502   \u251c\u2500\u2500 ID: LAB42\n\u2502   \u251c\u2500\u2500 SSH_SERVER: localhost\n\u2502   \u2514\u2500\u2500 SSH_PORT: 22\n\u251c\u2500\u2500 PROCESS\n\u2502   \u2514\u2500\u2500 METRICS_INTERVAL: 10\n\u251c\u2500\u2500 Logging Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 LOGGING_PORT: 7000\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 7001\n... ...\n\u2514\u2500\u2500 Storage Control Server\n    \u251c\u2500\u2500 PROTOCOL: tcp\n    \u251c\u2500\u2500 HOSTNAME: localhost\n    \u251c\u2500\u2500 COMMANDING_PORT: 6100\n    \u251c\u2500\u2500 MONITORING_PORT: 6101\n    \u251c\u2500\u2500 SERVICE_PORT: 6102\n    \u251c\u2500\u2500 METRICS_PORT: 6103\n    \u2514\u2500\u2500 DELAY: 1\nMemoized locations:\n['/Users/rik/github/cgse/libs/cgse-common/src/cgse_common/settings.yaml', '/Users/rik/github/cgse/libs/cgse-core/src/cgse_core/settings.yaml', '/Users/rik/cgse/local_settings_ariel.yaml']\n</code></pre> <p>The memoized locations are the settings files that have been loaded and cached. Once the application has started and the settings have been loaded, they can only be reloaded by explicitly forcing a reload as follows:</p> <pre><code>&gt;&gt;&gt; settings = Settings.load(force=True)\n</code></pre> <p>Warning</p> <p>The <code>force</code> reload does however not guarantee that the settings will propagate properly throughout the application or to client apps. Settings can be saved in local variables or class instances that have no knowledge of a Settings reload. So, be careful when changing your Settings. If there are parameters that change often and are not as  static as thought, maybe they belong in the Setup instead of the Settings. Examples are:</p> <ul> <li>calibration parameters</li> <li>SUT parameters</li> <li>conversion functions</li> <li>coordinates and reference frames</li> <li>models</li> </ul>"},{"location":"libs/cgse-common/settings/#the-design-of-the-load-method","title":"The design of the <code>load()</code> method","text":"<p>A word about the <code>Settings.load()</code> method. Depending on the parameters provided, this method either loads all  settings, a group of settings or just one single YAML file. We have already explained how to load a specific group  of settings by giving the name of the group as a parameter. When you want to load just one YAML file, you need to  specify its location also. When a location is given as a str or a Path, the Settings will be loaded from that file  only, using the default <code>settings.yaml</code> name or another name given through the <code>filename</code> argument.</p> <p>This can be used to e.g. load command files for a device:</p> <pre><code>&gt;&gt;&gt; commands = Settings.load(location=\"~\", filename=\"DAQ5610.yaml\")\n</code></pre> <p>The mechanism behind the <code>Settings.load()</code> method is shown in the following diagram. For simplicity, parameters are  not shown and only the success path is presented, not any exceptions or error handling.</p> <p></p>"},{"location":"libs/cgse-common/setup/","title":"The Setup","text":""},{"location":"libs/cgse-coordinates/","title":"Reference Coordinates","text":""},{"location":"libs/cgse-core/","title":"Core Services","text":""},{"location":"libs/cgse-gui/","title":"GUI Components","text":""},{"location":"projects/","title":"Projects","text":"<p>The projects are those packages that add functionality to the CGSE framework.</p> <p>The projects live under the folder <code>projects</code>, and they are organised in generic and specific projects. Generic  projects do not have an implementation that is specific for one particular project, while, obviously, specific  projects have. We currently have the following generic packages:</p> <ul> <li><code>cgse-tools</code></li> <li><code>symetrie-hexapod</code></li> <li><code>keithley-tempcontrol</code></li> </ul> <p>and then there are the project specific packages:</p> <ul> <li><code>plato-fits</code></li> <li><code>plato-hdf5</code></li> <li><code>plato-spw</code></li> </ul>"},{"location":"projects/cgse-tools/","title":"Tools for the CGSE framework","text":""},{"location":"projects/symetrie-hexapod/","title":"The Sym\u00e9trie Hexapods","text":""},{"location":"projects/symetrie-hexapod/#settings-up-your-system-for-the-puna-hexapod","title":"Settings up your system for the PUNA Hexapod","text":"<p>Warning</p> <p>We need some work here... we want to be able to use multiple hexapods in the same Setup and  they can be the same type or different types. So, how do we specify two PUNA hexapods used  to position two different parts of your test equiopment?  </p> <p>The system needs to know the following information on the hexapod:</p> <ul> <li>device name: specified in the Setup under <code>setup.gse.hexapod.device_args.device_name</code></li> <li>device id: specified in the Setup under <code>setup.gse.hexapod.device_args.device_id</code></li> </ul> <p>These above settings can olso be specified in the environment variables:</p> <ul> <li>SYMETRIE_HEXAPOD_NAME</li> <li>SYMETRIE_HEXAPOD_ID</li> </ul>"},{"location":"user_guide/","title":"User Guide","text":"<p>Welcome to the CGSE user guide! An in-depth reference on how to use the CGSE.</p>"}]}