{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Tip</p> <p>See the navigation links in the header or side-bar.</p> <p>Click  (top left) on mobile.</p>"},{"location":"#welcome","title":"Welcome","text":"<p>Welcome to the CGSE framework documentation.</p> <p>Get started or go straight to the Tutorial</p>"},{"location":"#what-is-the-cgse","title":"What is the CGSE?","text":"<p>The CGSE (Common-EGSE) is a comprehensive framework for managing and operating test equipment in laboratory environments. EGSE stands for Electrical Ground Support Equipment, encompassing all hardware and software systems used to test, calibrate, and validate space instruments throughout their development lifecycle.</p> <p>The CGSE architecture typically includes:</p> <ul> <li> <p>Computing infrastructure: A dedicated server running the CGSE software suite   for test execution, data collection, and archiving, paired with client   workstations that provide user interfaces for equipment control and monitoring</p> </li> <li> <p>Temperature control systems: Precision controllers that regulate thermal   conditions by managing heaters and continuously monitoring temperature   sensors, essential for thermal vacuum testing and temperature calibration   procedures</p> </li> <li> <p>Mechanism controllers: Specialized systems that operate positioning equipment   such as hexapods (six-degree-of-freedom motion platforms), linear stages,   rotation stages, and other mechanical actuators with high precision</p> </li> <li> <p>Optical test equipment: Controllers for various optical instruments including   lasers, light sources, attenuators, spectrometers, and optical power meters   used in optical alignment and performance verification</p> </li> <li> <p>Additional instrumentation: Any measurement or control device with network   connectivity (Ethernet, USB) and an accessible API, including power supplies,   signal generators, multimeters, oscilloscopes, and custom test fixtures</p> </li> </ul> <p>The CGSE framework provides standardized interfaces, automated test sequences, data management capabilities, and synchronization between these diverse systems, enabling reproducible and efficient testing campaigns.</p>"},{"location":"getting_started/","title":"Getting started","text":"<p>All you need to get started using and building the CGSE.</p>"},{"location":"getting_started/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9.x (we do not yet support higher versions, but are working to extend the list)</li> <li>macOS or Linux</li> </ul>"},{"location":"getting_started/#virtual-environment","title":"Virtual environment","text":"<p>You should always work inside a virtual environment to somehow containerize your project such that it doesn't  pollute your global environment and you can run different projects next to each other. Create and activate a new  virtual environment as follows. It should be Python &gt;= 3.9</p> <pre><code>$ python -m venv venv\n$ source venv/bin/activate\n</code></pre>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>The easiest way to install the CGSE is to use the <code>pip</code> command. Since the CGSE is a monorepo and consists of  several packages, you will need to make your choice which package you need for your project. You can however start  with the <code>cgse-common</code> which contains all common code that is generic and useful as a basis for other packages.</p> <pre><code>$ pip install cgse-common\n</code></pre> <p>Check the list of packages that are part of the CGSE repo and can be installed with <code>pip</code>. The  packages are described in more detail in the sections Libs and Projects.</p>"},{"location":"getting_started/#set-up-your-environment","title":"Set up your environment","text":"<p>To check your installation and set up your environment, here are a few tips.</p> <p>The version of the core packages and any plugin packages can be verified as follows. The version you installed will  probably be higher and more lines will appear when other packages are installed.</p> <pre><code>$ py -m egse.version\nCGSE version in Settings: 0.5.0\nInstalled version for cgse-common= 0.5.0\n</code></pre> <p>Check your environment with the command below. This will probably print out some warning since you have not defined  the expected environment variables yet. There are two mandatory environment variables: <code>PROJECT</code> and <code>SITE_ID</code>. The  former shall contain the name of your project without spaces and preferably a single word or an acronym like PLATO,  ARIEL, MARVEL, MERCATOR. The latter is the name of the site or lab where the tests will be performed. Good names are  KUL, ESA, LAB23.</p> <p>The other environment variables follow the pattern <code>&lt;PROJECT&gt;_...</code>, i.e. they all start with the project name as  defined  in the PROJECT environment variable. You should define at least <code>&lt;PROJECT&gt;_DATA_STORAGE_LOCATION</code>. The configuration  data and log file location will be derived from it unless they are explicitly set themselves. </p> <p>Let's define the three expected environment variables:</p> <pre><code>$ export PROJECT=ARIEL\n$ export SITE_ID=VACUUM_LAB\n$ export ARIEL_DATA_STORAGE_LOCATION=~/data\n</code></pre> <p>Rerunning the above command now gives:</p> <pre><code>$ py -m egse.env\nEnvironment variables:\n    PROJECT = ARIEL\n    SITE_ID = VACUUM_LAB\n    ARIEL_DATA_STORAGE_LOCATION = /Users/rik/data\n    ARIEL_CONF_DATA_LOCATION = not set\n    ARIEL_CONF_REPO_LOCATION = not set\n    ARIEL_LOG_FILE_LOCATION = not set\n    ARIEL_LOCAL_SETTINGS = not set\n\nGenerated locations and filenames\n    get_data_storage_location() = '/Users/rik/data/VACUUM_LAB'  \u27f6 ERROR: The data storage location doesn't exist!\n    get_conf_data_location() = '/Users/rik/data/VACUUM_LAB/conf'  \u27f6 ERROR: The configuration data location doesn't exist!\n    get_conf_repo_location() = None  \u27f6 ERROR: The configuration repository location doesn't exist!\n    get_log_file_location() = '/Users/rik/data/VACUUM_LAB/log'  \u27f6 ERROR: The log files location doesn't exist!\n    get_local_settings() = None  \u27f6 ERROR: The local settings file is not defined or doesn't exist!\n\nuse the '--full' flag to get a more detailed report, '--doc' for help on the variables.\n</code></pre> <p>Note</p> <p>The folders that do not exist (and are not None) can be created by adding the option <code>--mkdir</code> to the above  command.</p>"},{"location":"getting_started/#check-your-settings","title":"Check your Settings","text":"<p>Settings contains the static configuration of your system, test setup, equipment, including the System Under Test  (SUT). You can test your settings with the command below. Let's first also set the <code>ARIEL_LOCALSETTINGS</code> environment  variables:</p> <p><pre><code>$ export ARIEL_LOCAL_SETTINGS=~/cgse/local_settings_ariel_vacuum_lab.yaml\n$ py -m egse.settings\nSettings\n\u251c\u2500\u2500 PACKAGES\n\u2502   \u2514\u2500\u2500 CGSE_COMMON: Common classes, functions, decorators, etc. for the CGSE\n\u251c\u2500\u2500 SITE\n\u2502   \u251c\u2500\u2500 ID: VACUUM_LAB\n\u2502   \u251c\u2500\u2500 SSH_SERVER: localhost\n\u2502   \u2514\u2500\u2500 SSH_PORT: 22\n\u2514\u2500\u2500 PROCESS\n    \u2514\u2500\u2500 METRICS_INTERVAL: 10\nMemoized locations:\n['/Users/rik/tmp/gettings-started/venv/lib/python3.9/site-packages/cgse_common/settings.yaml', \n'/Users/rik/cgse/local_settings_ariel_vacuum_lab.yaml']\n</code></pre> These Settings will grow when you add more packages to your installation or when you define settings yourself in the  local settings file.</p>"},{"location":"help/","title":"Help","text":"<p>The best way to get help for something that you couldn't find in the documentation on this site, is to contact one of  the authors.</p>"},{"location":"help/#bugs-and-feature-requests","title":"Bugs and Feature requests","text":"<p>Report any bugs or issues through GitHub on the CGSE issues page.  </p>"},{"location":"initialize/","title":"Initialize your project","text":"<p>So, we have seen how to get started with some basic commands and only the <code>cgse-common</code> package. It's time now to initialize your project properly with all the necessary services.</p>"},{"location":"initialize/#set-up-your-environment","title":"Set up your environment","text":"<p>I assume you are in the same environment that we have set up in the previous section where also the <code>cgse-common</code> package was installed. We will install another package that will provide us with the full functionality of the <code>cgse</code> command. Install the <code>cgse-tools</code> and <code>cgse-core</code> packages which depends on <code>cgse-core</code> and will also install that package.</p> <pre><code>$ pip install cgse-tools cgse-core\n</code></pre> <p>You should now have at least the follow three packages installed in your virtual environment:</p> <pre><code>$ pip list | grep cgse\ncgse-common       0.5.0\ncgse-core         0.5.0\ncgse-tools        0.5.0\n</code></pre>"},{"location":"initialize/#the-cgse-command","title":"The <code>cgse</code> command","text":"<p>The two new packages that have been installed (<code>cgse-core</code> and <code>cgse-tools</code>) provide the <code>cgse</code> command that we will use to initialize your environment, but this command is also used to inspect different parts of the system, manage core services and device drivers, etc.</p> <p>When you run the <code>cgse</code> command without any arguments, it will show something like this:</p> <pre><code>$ cgse\n\n Usage: cgse [OPTIONS] COMMAND [ARGS]...\n\n The main cgse command to inspect, configure, monitor the core services and device control servers.\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --install-completion          Install completion for the current shell.                                                                                      \u2502\n\u2502 --show-completion             Show completion for the current shell, to copy it or customize the installation.                                               \u2502\n\u2502 --help                        Show this message and exit.                                                                                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 version   Prints the version of the cgse-core and other registered packages.                                                                                 \u2502\n\u2502 init      Initialize your project.                                                                                                                           \u2502\n\u2502 top       A top-like interface for core services and device control servers.                                                                                 \u2502\n\u2502 core      handle core services: start, stop, status                                                                                                          \u2502\n\u2502 show      Show information about settings, environment, setup, ...                                                                                           \u2502\n\u2502 check     Check installation, settings, required files, etc.                                                                                                 \u2502\n\u2502 dev-x     device-x is an imaginary device that serves as an example                                                                                          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>The <code>cgse</code> command is actually an app that is the starting point for a number of commands that can be used to maintain the system, manage and inspect services and devices. For example, to check the version of the different components, use:</p> <pre><code>$ cgse version\nCGSE-COMMON installed version = 0.5.0 \u2014 Software framework to support hardware testing\nCGSE-CORE installed version = 0.5.0 \u2014 Core services for the CGSE framework\nCGSE-TOOLS installed version = 0.5.0 \u2014 Tools for CGSE\n</code></pre> <p>We will for now concentrate on the <code>init</code> command. This command will guide us through a number of steps to define the location of our device data, configuration data, etc. We will basically define some environment variables that are used by the CGSE framework. The PROJECT is he name of the project your will be working on, the SITE_ID is the identifier for the LAB or Setup that you are using to perform the tests. As you see below, the environment variables all start with the project name allowing you to work on different projects simultaneously. If you accept all the defaults, the result of the <code>cgse init</code> command will look something like this:</p> <pre><code>$ cgse init --project marvel\nPlease note default values are given between [brackets].\nWhat is the name of the project [MARVEL] ?:\nWhat is the site identifier ?: lab02\nWhere can the project data be stored [~/data/MARVEL/LAB02/] ?:\nWhere will the configuration data be located [~/data/MARVEL/LAB02/conf/] ?:\nWhere will the logging messages be stored [~/data/MARVEL/LAB02/log/] ?:\nWhere shall I create a local settings YAML file [~/data/MARVEL/LAB02/local_settings.yaml] ?:\nShall I add the environment to your ~/bash_profile ? [y/n]: n\n\n# -&gt; Add the following lines to your bash profile or equivalent\n\nexport PROJECT=MARVEL\nexport SITE_ID=LAB02\nexport MARVEL_DATA_STORAGE_LOCATION=~/data/MARVEL/LAB02/\nexport MARVEL_CONF_DATA_LOCATION=~/data/MARVEL/LAB02/conf/\nexport MARVEL_LOG_FILE_LOCATION=~/data/MARVEL/LAB02/log/\nexport MARVEL_LOCAL_SETTINGS=~/data/MARVEL/LAB02/local_settings.yaml\n</code></pre> <p>If you answered 'Y' to the last question, you should log in to the shell again with <code>exec bash -login</code> or a similar command for other shells, or you should start a new terminal to activate the environment variables.</p> <p>Add this point you are ready to go and start the core services and any device control servers that you need. You can explore other commands of the <code>cgse</code> app in the user guide.</p>"},{"location":"package_list/","title":"Packages in the CGSE","text":"<p>The CGSE is a monorepo and consists of numerous packages. Each of these packages are individually installable from  PyPI. We maintain a list here with all the packages in the monorepo.</p> Package Description <code>cgse-common</code> The common code used by all other packages <code>cgse-core</code> The core services <code>cgse-coordinates</code> Coordinate reference Frames <code>cgse-gui</code> GUI components and styles (PyQt5) <code>cgse-tools</code> Plugin that adds functions to the <code>cgse</code> command <code>symetrie-hexapod</code> Device drivers for the Sym\u00e9trie Hexapods <code>keithley-tempcontrol</code> Device driver for the Keithley temperature controller <code>plato-fits</code> FITS driver with PLATO specific format <code>plato-hdf5</code> HDF5 driver with PLATO specific format <code>plato-spw</code> SpaceWire driver with PATO specific packets <p>The following is a non-exhaustive list of known external packages that work well with the CGSE  in terms of commanding and monitoring.</p> Package Description <code>cgse-dummy</code> Provides a dummy device driver to demonstrate plugins, commands and how to develop an external package for the CGSE."},{"location":"roadmap/","title":"Roadmap","text":"<p>Don't worry, the feature set will grow ...</p>"},{"location":"roadmap/#features","title":"Features","text":""},{"location":"roadmap/#the-cgse-command","title":"The <code>cgse</code> Command","text":"<p>Provide a <code>cgse</code> command that is extensible with new commands and command groups:</p> <ul> <li> a command to initialise your environment.</li> <li> a command to check versions of installed packages.</li> <li> a command to check your installation, settings, setups, environment ..</li> <li> a command group to handle core services</li> <li> a command to list running CGSE processes.</li> <li> device drivers shall be able to plug in their own command groups.</li> </ul>"},{"location":"roadmap/#settings-setup-and-the-environment","title":"Settings, Setup and the environment","text":"<ul> <li> A modular/decomposed <code>settings.yaml</code> file.</li> <li> A clear set of environment variables.</li> <li> automatic submit of new Setups to GitHub.</li> <li> a TUI for inspecting the loaded Setup.</li> </ul>"},{"location":"roadmap/#common-functionality","title":"Common functionality","text":"<ul> <li> Reference Frames and coordinate transformations -&gt; Graphs</li> <li> Metrics for all devices will be handled using InfluxDB</li> <li> Use of Grafana to visualize the metrics</li> </ul>"},{"location":"roadmap/#core-services","title":"Core Services","text":"<ul> <li> Process Manager needs to be added with optimised design and performance</li> <li> Synoptic Manager</li> <li> Distributed Service Registry</li> <li> dynamic port assignment for all services -&gt; service registry</li> </ul>"},{"location":"roadmap/#devices","title":"Devices","text":"<ul> <li> The Sym\u00e9trie Hexapods: PUNA, ZONDA, JORAN</li> <li> The Keithley Data Acquisition Multimeter</li> <li> The Lakeshore temperature controller</li> </ul>"},{"location":"roadmap/#projects","title":"Projects","text":"<ul> <li> Ariel HDF5 format plugin</li> <li> Ariel FITS format plugin</li> </ul>"},{"location":"roadmap/#guis-and-tuis","title":"GUIs and TUIs","text":"<ul> <li> A Process Manager TUI</li> <li> <code>tui-executor</code> integration</li> </ul>"},{"location":"roadmap/#maintenance-and-refactoring","title":"Maintenance and refactoring","text":"<ul> <li> Allow core services to register and/or re-register to another core service as a listener</li> <li> The storage manager shall be able to restore registrations from    devices after a restart/crash. This means the registration to the Storage    manager needs to be persistent -&gt; SQLite ?</li> <li> Refactor the commanding protocol</li> <li> The Proxy and Protocol classes should be refactored for full dynamic commanding. Eliminate the   use of command YAML files, replace <code>dynamic_interface</code> with <code>dynamic_command</code>.</li> <li> Introduce asyncio into the commanding protocol, e.g. <code>get_status()</code>    and <code>get_housekeeping()</code> shall be handled asynchronously.</li> <li> GlobalState Setup needs some redesign, especially <code>GlobalState.setup</code> which should not consult   the configuration manager by default.</li> </ul>"},{"location":"roadmap/#removals","title":"Removals","text":"<ul> <li> The <code>get_common_egse_root()</code> is of no use anymore and needs to be    removed or replaced in some   cases.</li> </ul>"},{"location":"roadmap/#testing","title":"Testing","text":"<ul> <li> Add unit testing with <code>nox</code> running tests for Python 3.9, 3.10, 3.11, and 3.12</li> <li> Add proper unit tests for all packages \u2013 using <code>pytest</code></li> <li> Add a CI test suite</li> <li> Use GitHub Actions for running tests before merging</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Welcome to the CGSE Tutorial!</p> <p>By the end of this page you should have a solid understanding of the core features of the CGSE.</p>"},{"location":"api/","title":"API","text":"<p>This is a API-level reference to the CGSE API. Click the links to your left (or in the   menu) to open a reference for each module.</p> <p>If you are new to the CGSE, you may want to read the Gettings Started  first.</p>"},{"location":"api/bits/","title":"egse.bits","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/bits/#egse.bits","title":"egse.bits","text":"<p>This module contains a number of convenience functions to work with bits, bytes and integers.</p> <p>Functions:</p> Name Description <code>beautify_binary</code> <p>Returns a binary representation of the given value. The bits are presented</p> <code>bit_set</code> <p>Return True if the bit is set.</p> <code>bits_set</code> <p>Return True if all the bits are set.</p> <code>clear_bit</code> <p>Set bit to 0 for the given value.</p> <code>clear_bits</code> <p>Set the given bits in value to 0.</p> <code>crc_calc</code> <p>Calculate the checksum for (part of) the data.</p> <code>extract_bits</code> <p>Extracts a specified number of bits from an integer starting at a given position.</p> <code>humanize_bytes</code> <p>Represents the size <code>n</code> in human-readable form, i.e. as byte, KiB, MiB, GiB, ...</p> <code>s16</code> <p>Return the signed equivalent of a hex or binary number.</p> <code>s32</code> <p>Return the signed equivalent of a hex or binary number.</p> <code>set_bit</code> <p>Set bit to 1 for the given value.</p> <code>set_bits</code> <p>Set the given bits in value to 1.</p> <code>toggle_bit</code> <p>Toggle the bit in the given value.</p>"},{"location":"api/bits/#egse.bits.beautify_binary","title":"beautify_binary","text":"<pre><code>beautify_binary(value, sep=' ', group=8, prefix='', size=0)\n</code></pre> <p>Returns a binary representation of the given value. The bits are presented in groups of 8 bits for clarity by default (can be changed with the <code>group</code> keyword).</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the value to beautify</p> required <code>sep</code> <code>str</code> <p>the separator character to be used, default is a space</p> <code>' '</code> <code>group</code> <code>int</code> <p>the number of bits to group together, default is 8</p> <code>8</code> <code>prefix</code> <code>str</code> <p>a string to prefix the result, default is ''</p> <code>''</code> <code>size</code> <code>int</code> <p>number of digits</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>a binary string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; status = 2**14 + 2**7\n&gt;&gt;&gt; assert beautify_binary(status) == \"01000000 10000000\"\n</code></pre>"},{"location":"api/bits/#egse.bits.bit_set","title":"bit_set","text":"<pre><code>bit_set(value, bit)\n</code></pre> <p>Return True if the bit is set.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the value to check</p> required <code>bit</code> <code>int</code> <p>the index of the bit to check, starting from 0 at the LSB</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the bit is set (1).</p>"},{"location":"api/bits/#egse.bits.bits_set","title":"bits_set","text":"<pre><code>bits_set(value, *args)\n</code></pre> <p>Return True if all the bits are set.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the value to check</p> required <code>args</code> <code>Union[int, Iterable[int]]</code> <p>a set of indices of the bits to check, starting from 0 at the LSB. All the indices can be given as separate arguments, or they can be passed in as a list.</p> <code>()</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if all the bits are set (1).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert bits_set(0b0101_0000_1011, [0, 1, 3, 8, 10])\n&gt;&gt;&gt; assert bits_set(0b0101_0000_1011, [3, 8])\n&gt;&gt;&gt; assert not bits_set(0b0101_0000_1011, [1, 2, 3])\n</code></pre>"},{"location":"api/bits/#egse.bits.clear_bit","title":"clear_bit","text":"<pre><code>clear_bit(value, bit)\n</code></pre> <p>Set bit to 0 for the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the integer value that needs a bit set or unset</p> required <code>bit</code> <code>int</code> <p>the index of the bit to set/unset, starting from 0 at the LSB</p> required <p>Returns:</p> Type Description <code>int</code> <p>the changed value.</p>"},{"location":"api/bits/#egse.bits.clear_bits","title":"clear_bits","text":"<pre><code>clear_bits(value, bits)\n</code></pre> <p>Set the given bits in value to 0.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the value where the given bits shall be changed</p> required <code>bits</code> <code>tuple</code> <p>a tuple with start and stop bits</p> required <p>Returns:</p> Type Description <code>int</code> <p>the changed value</p>"},{"location":"api/bits/#egse.bits.crc_calc","title":"crc_calc","text":"<pre><code>crc_calc(data, start, len_)\n</code></pre> <p>Calculate the checksum for (part of) the data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[bytes | int]</code> <p>the data for which the checksum needs to be calculated</p> required <code>start</code> <code>int</code> <p>offset into the data array [byte]</p> required <code>len_</code> <code>int</code> <p>number of bytes to incorporate into the calculation</p> required <p>Returns:</p> Type Description <code>int</code> <p>the calculated checksum.</p> Reference <p>The description of the CRC calculation for RMAP is given in the ECSS document Space Engineering: SpaceWire - Remote Memory Access Protocol, section A.3 on page 80 [ECSS\u2010E\u2010ST\u201050\u201052C].</p>"},{"location":"api/bits/#egse.bits.extract_bits","title":"extract_bits","text":"<pre><code>extract_bits(value, start_position, num_bits)\n</code></pre> <p>Extracts a specified number of bits from an integer starting at a given position.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The input integer.</p> required <code>start_position</code> <code>int</code> <p>The starting bit position (0-based index).</p> required <code>num_bits</code> <code>int</code> <p>The number of bits to extract.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The extracted bits as an integer.</p>"},{"location":"api/bits/#egse.bits.humanize_bytes","title":"humanize_bytes","text":"<pre><code>humanize_bytes(n, base=2, precision=3)\n</code></pre> <p>Represents the size <code>n</code> in human-readable form, i.e. as byte, KiB, MiB, GiB, ...</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>number of byte</p> required <code>base</code> <code>(int, str)</code> <p>binary (2) or decimal (10)</p> <code>2</code> <code>precision</code> <code>int</code> <p>the number of decimal places [default=3]</p> <code>3</code> <p>Returns:</p> Type Description <code>str</code> <p>a human-readable size, like 512 byte or 2.300 TiB</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when base is different from 2 (binary) or 10 (decimal).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert humanize_bytes(55) == \"55 bytes\"\n&gt;&gt;&gt; assert humanize_bytes(1024) == \"1.000 KiB\"\n&gt;&gt;&gt; assert humanize_bytes(1000, base=10) == \"1.000 kB\"\n&gt;&gt;&gt; assert humanize_bytes(1000000000) == '953.674 MiB'\n&gt;&gt;&gt; assert humanize_bytes(1000000000, base=10) == '1.000 GB'\n&gt;&gt;&gt; assert humanize_bytes(1073741824) == '1.000 GiB'\n&gt;&gt;&gt; assert humanize_bytes(1024**5 - 1, precision=0) == '1024 TiB'\n</code></pre> Note <p>Please note that, by default, I use the IEC standard (International Engineering Consortium) which is in <code>base=2</code> (binary), i.e. 1024 bytes = 1.0 KiB. If you need SI units (International System of Units), you need to specify <code>base=10</code> (decimal), i.e. 1000 bytes = 1.0 kB.</p>"},{"location":"api/bits/#egse.bits.s16","title":"s16","text":"<pre><code>s16(value)\n</code></pre> <p>Return the signed equivalent of a hex or binary number.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>an integer value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The negative equivalent of a twos-complement binary number.</p> <p>Examples:</p> <p>Since integers in Python are objects and stored in a variable number of bits, Python doesn't know the concept of twos-complement for negative integers. For example, this 16-bit number</p> <pre><code>&gt;&gt;&gt; 0b1000_0000_0001_0001\n32785\n</code></pre> <p>which in twos-complement is actually a negative value:</p> <pre><code>&gt;&gt;&gt; s16(0b1000_0000_0001_0001)\n-32751\n</code></pre> <p>The 'bin()' fuction will return a strange representation of this number:</p> <pre><code>&gt;&gt;&gt; bin(-32751)\n'-0b111111111101111'\n</code></pre> <p>when we however mask the value we get:</p> <pre><code>&gt;&gt;&gt; bin(-32751 &amp; 0b1111_1111_1111_1111)\n'0b1000000000010001'\n</code></pre> See <p>Twos complement in Python and         Pythons representation of negative integers and         Signed equivalent of a twos-complement hex-value and         SO Twos complement in Python.</p>"},{"location":"api/bits/#egse.bits.s32","title":"s32","text":"<pre><code>s32(value)\n</code></pre> <p>Return the signed equivalent of a hex or binary number.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>an integer value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The negative equivalent of a twos-complement binary number.</p> <p>Examples:</p> <p>Since integers in Python are objects and stored in a variable number of bits, Python doesn't know the concept of twos-complement for negative integers. For example, this 32-bit number</p> <pre><code>&gt;&gt;&gt; 0b1000_0000_0000_0000_0000_0000_0001_0001\n2147483665\n</code></pre> <p>which in twos-complement is actually a negative value:</p> <pre><code>&gt;&gt;&gt; s32(0b1000_0000_0000_0000_0000_0000_0001_0001)\n-2147483631\n</code></pre>"},{"location":"api/bits/#egse.bits.set_bit","title":"set_bit","text":"<pre><code>set_bit(value, bit)\n</code></pre> <p>Set bit to 1 for the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the integer value that needs a bit set or unset</p> required <code>bit</code> <code>int</code> <p>the index of the bit to set/unset, starting from 0 at the LSB</p> required <p>Returns:</p> Type Description <code>int</code> <p>the changed value.</p>"},{"location":"api/bits/#egse.bits.set_bits","title":"set_bits","text":"<pre><code>set_bits(value, bits)\n</code></pre> <p>Set the given bits in value to 1.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the value where the given bits shall be changed</p> required <code>bits</code> <code>tuple</code> <p>a tuple with start and stop bits</p> required <p>Returns:</p> Type Description <code>int</code> <p>the changed value.</p>"},{"location":"api/bits/#egse.bits.toggle_bit","title":"toggle_bit","text":"<pre><code>toggle_bit(value, bit)\n</code></pre> <p>Toggle the bit in the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the integer value that needs a bit toggled</p> required <code>bit</code> <code>int</code> <p>the index of the bit to toggle, starting from 0 at the LSB</p> required <p>Returns:</p> Type Description <code>int</code> <p>the changed value.</p>"},{"location":"api/calibration/","title":"egse.calibration","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/calibration/#egse.calibration","title":"egse.calibration","text":"<p>This module provides functions to calibrate sensor values.</p> <p>Functions:</p> Name Description <code>apply_gain_offset</code> <p>Applies the given gain and offset to the given counts.</p> <code>callendar_van_dusen</code> <p>Solves the Callendar - van Dusen equation for temperature.</p> <code>chebychev</code> <p>Solves the Chebychev equation for temperature.</p> <code>counts_to_resistance</code> <p>Converts the given counts for the given sensor to resistance.</p> <code>counts_to_temperature</code> <p>Converts the given counts for the given sensor to temperature.</p> <code>resistance_to_temperature</code> <p>Converts the given resistance for the given sensor to temperature.</p> <code>solve_temperature</code> <p>Solves the temperature from the temperature -&gt; resistance polynomial.</p>"},{"location":"api/calibration/#egse.calibration.apply_gain_offset","title":"apply_gain_offset","text":"<pre><code>apply_gain_offset(counts, gain, offset)\n</code></pre> <p>Applies the given gain and offset to the given counts.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>float</code> <p>Uncalibrated, raw data [ADU]</p> required <code>gain</code> <code>float</code> <p>Gain to apply</p> required <code>offset</code> <code>float</code> <p>Offset to apply</p> required <p>Returns:</p> Type Description <code>float</code> <p>Counts after applying the given gain and offset.</p>"},{"location":"api/calibration/#egse.calibration.callendar_van_dusen","title":"callendar_van_dusen","text":"<pre><code>callendar_van_dusen(\n    resistance, ref_resistance, standard, setup\n)\n</code></pre> <p>Solves the Callendar - van Dusen equation for temperature.</p> <p>Parameters:</p> Name Type Description Default <code>resistance</code> <code>float</code> <p>Resistance [Ohm] for which to calculate the temperature</p> required <code>ref_resistance</code> <code>float</code> <p>Resistance [Ohm] for a temperature of 0\u00b0C</p> required <code>standard</code> <code>str</code> <p>Sensor standard</p> required <code>setup</code> <code>Setup</code> <p>Setup</p> required <p>Returns:</p> Type Description <code>float</code> <p>Temperature [\u00b0C] corresponding to the given resistance.</p>"},{"location":"api/calibration/#egse.calibration.chebychev","title":"chebychev","text":"<pre><code>chebychev(resistance, sensor_info)\n</code></pre> <p>Solves the Chebychev equation for temperature.</p> <p>Implemented as specified in the calibration certificate of the LakeShore Cernox sensors.</p> <p>Parameters:</p> Name Type Description Default <code>resistance</code> <code>float</code> <p>Resistance [Ohm] for which to calculate the temperature</p> required <code>sensor_info</code> <code>navdict</code> <p>Calibration information</p> required <p>Returns:</p> Type Description <code>float</code> <p>Temperature [\u00b0C] corresponding to the given resistance.</p>"},{"location":"api/calibration/#egse.calibration.counts_to_resistance","title":"counts_to_resistance","text":"<pre><code>counts_to_resistance(sensor_name, counts, sensor_info)\n</code></pre> <p>Converts the given counts for the given sensor to resistance.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_name</code> <code>str</code> <p>Sensor name</p> required <code>counts</code> <code>float</code> <p>Uncalibrated, raw data [ADU]</p> required <code>sensor_info</code> <code>navdict</code> <p>Calibration information for the given sensor (type)</p> required <p>Returns:</p> Type Description <code>float</code> <p>Resistance [Ohm] for the given sensor.</p>"},{"location":"api/calibration/#egse.calibration.counts_to_temperature","title":"counts_to_temperature","text":"<pre><code>counts_to_temperature(\n    sensor_name, counts, sensor_info, setup\n)\n</code></pre> <p>Converts the given counts for the given sensor to temperature.</p> <p>This conversion can be done as follows:</p> <pre><code>- (1) Directly from counts to temperature, by applying the gain and offset;\n- (2) Directly from counts to temperature, by applying a function;\n- (3) From counts, via resistance, to temperature.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sensor_name</code> <code>str</code> <p>Sensor name</p> required <code>counts</code> <code>float</code> <p>Uncalibrated, raw data [ADU]</p> required <code>sensor_info</code> <code>navdict</code> <p>Calibration information for the given sensor (type)</p> required <code>setup</code> <code>Setup</code> <p>Setup</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>Calibrated temperature [\u00b0C] for the given sensor</p>"},{"location":"api/calibration/#egse.calibration.resistance_to_temperature","title":"resistance_to_temperature","text":"<pre><code>resistance_to_temperature(\n    sensor_name, resistance, sensor_info, setup\n)\n</code></pre> <p>Converts the given resistance for the given sensor to temperature.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_name</code> <code>str</code> <p>Sensor name</p> required <code>resistance</code> <code>float</code> <p>Resistance [Ohm]</p> required <code>sensor_info</code> <code>navdict</code> <p>Calibration information for the given sensor (type)</p> required <code>setup</code> <code>Setup</code> <p>Setup</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>Temperature [\u00b0C] for the given sensor.</p>"},{"location":"api/calibration/#egse.calibration.solve_temperature","title":"solve_temperature","text":"<pre><code>solve_temperature(\n    temperature_to_resistance_coefficients, resistance\n)\n</code></pre> <p>Solves the temperature from the temperature -&gt; resistance polynomial.</p> <p>For the given temperature -&gt; resistance polynomial and the given resistance, we determine what the corresponding temperature is by:</p> <ul> <li>Finding the roots of polynomial(temperature) = resistance;</li> <li>Discarding the roots with an imaginary component;</li> <li>Selecting the remaining root in the relevant temperature regime (here: [-200\u00b0C, 200\u00b0C]).</li> </ul>"},{"location":"api/command/","title":"egse.command","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/command/#egse.command","title":"egse.command","text":"<p>This module defines a number of classes and helper functions to define and work with commands that operate hardware devices. The goal is to be able to define / create commands transparently from a YAML file without having to write (too much) code.</p>"},{"location":"api/command/#egse.command--definitions","title":"Definitions","text":"<p>command</p> <p>a string that is sent to a device over an interface like TCP/IP or USB. This string is generated by the get_cmd_string() method of the Command class.</p> <p>The string contains format like syntax that looks like an f-string, but is interpreted differently. See further: How to format device command strings.</p> <p>Command</p> <p>the base class for commands. This class contains the definition of the command and provides methods to parse and check arguments. The Command can be 'called' or 'executed' in which case a number of actions are performed based on the provided arguments.</p> <p>CommandExecution</p> <p>this class contains all the information needed to execute a command, without actually executing it. A CommandExecution contains the command definition and the parameters for the execution. It is mainly served as a communication mechanism to the control servers, i.e. the client side (Proxy) defines a command execution and the server then executes the command.</p> <p>CommandError</p> <p>a catch-all exception for unrecoverable errors in this module</p> <p>InvalidArgumentsError</p> <p>a CommandError raised when the arguments provided are themselve invalid or if the number of arguments is not matching expectations</p> <p>The basic interface is:</p> <pre><code>cmd = Command(name     = &lt;command name&gt;,\n              cmd      = &lt;command string&gt;,\n              response = &lt;callable to retreive a response&gt;,\n              wait     = &lt;callable to wait a specific time/delay&gt;)\n</code></pre> <p>where:</p> <ul> <li>name: a name for the command, this is just needed for reporting, not used in commanding</li> <li>cmd: the command string to send or execute, see further for details</li> <li>response: send a second command to read or get a response on the 'cmd' sent</li> <li>wait: a function object that will wait for a specific duration,   e.g. <code>partial(time.sleep, 10)</code>.</li> </ul>"},{"location":"api/command/#egse.command--formatting-device-command-strings","title":"Formatting device command strings","text":"<p>The <code>cmd</code> argument is a string that contains placeholders (replacement fields) for future arguments that will be passed when calling the Command. The replacement fields are marked with curly braces and are mandatory. When a name is provided in the curly braces, the argument shall be provided as a keyword argument, otherwise a positional argument is expected. In the current implementation the <code>cmd</code> can only contain either positional arguments or keyword argument, not a mix of both.</p> <p>The replacement fields may also have a format specifier to specify a precise format for that field.</p> <p>Examples</p> <pre><code>moveAbsolute = Command(\n    name = \"moveAbsolute\",\n    cmd  = \"&amp;2 Q70=0 Q71={tx:.6f} Q72={ty:.6f} Q73={tz:.6f} \"\n           \"Q74={rx:.6f} Q75={ry:.6f} Q76={rz:.6f} Q20=11\"\n)\n\nresponse = moveAbsolute(1, 1, 1, 0, 0, 20)\nresponse = moveAbsolute(tx=1, ty=1, tz=1, rx=0, ry=0, rz=20)\n</code></pre>"},{"location":"api/command/#egse.command--questions","title":"Questions","text":"<p>Do we need additional hooks into this commanding?</p> <ul> <li>add a meaning to the check, what is it and what is it used for?</li> <li>add a output processor possibility. A callback function that will process the   output value before returning it by the call.</li> <li>provide an execute method for the CommandExecution that executes the command   with the saved parameters</li> </ul> <p>Classes:</p> Name Description <code>ClientServerCommand</code> <code>Command</code> <p>A Command is basically a string that is send to a device and for which the</p> <code>CommandError</code> <p>A Command Exception as a base class for this module.</p> <code>CommandExecution</code> <p>This class contains all the information that is needed to execute a command</p> <code>InvalidArgumentsError</code> <p>The arguments provided are invalid</p> <code>InvalidCommandExecution</code> <p>A invalid command execution.</p> <p>Functions:</p> Name Description <code>dry_run</code> <p>This decorator prepares the function to handle a dry run.</p> <code>get_function</code> <p>Returns a function (unbound method) from a given class.</p> <code>get_method</code> <p>Returns a bound method from a given class instance.</p> <code>load_commands</code> <p>Loads the command definitions from the given <code>command_settings</code> and builds an internal</p> <code>parse_format_string</code> <p>Parse and decode the format string.</p>"},{"location":"api/command/#egse.command.ClientServerCommand","title":"ClientServerCommand","text":"<pre><code>ClientServerCommand(\n    name,\n    cmd,\n    response=None,\n    wait=None,\n    check=None,\n    description=None,\n    device_method=None,\n)\n</code></pre> <p>               Bases: <code>Command</code></p> <p>Methods:</p> Name Description <code>client_call</code> <p>This method is called at the client side. It is used by the Proxy</p> <code>server_call</code> <p>This method is called at the server side. It is used by the CommandProtocol class in the</p>"},{"location":"api/command/#egse.command.ClientServerCommand.client_call","title":"client_call","text":"<pre><code>client_call(other, *args, **kwargs)\n</code></pre> <p>This method is called at the client side. It is used by the Proxy as a generic command to send a command execution to the server.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>type</code> <p>a subclass of the Proxy class</p> required <code>args</code> <code>tuple</code> <p>arguments that will be passed on to this command when executed</p> <code>()</code> <code>kwargs</code> <code>dict</code> <p>keyword arguments that will be passed on to this command when executed</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>the response that is returned by calling the command (at the server side).</p>"},{"location":"api/command/#egse.command.ClientServerCommand.server_call","title":"server_call","text":"<pre><code>server_call(other, *args, **kwargs)\n</code></pre> <p>This method is called at the server side. It is used by the CommandProtocol class in the <code>execute</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>CommandProtocol</code> <p>a subclass of the CommandProtocol</p> required <code>args</code> <code>tuple</code> <p>arguments are passed on to the response method</p> <code>()</code> <code>kwargs</code> <code>dict</code> <p>keyword arguments are passed on to the response method</p> <code>{}</code> <p>Returns:</p> Type Description <code>int</code> <p>0 on success and -1 on failure.</p>"},{"location":"api/command/#egse.command.Command","title":"Command","text":"<pre><code>Command(\n    name,\n    cmd,\n    response=None,\n    wait=None,\n    check=None,\n    description=None,\n    device_method=None,\n)\n</code></pre> <p>A Command is basically a string that is send to a device and for which the device returns a response.</p> <p>The command string can contain placeholders that will be filled when the command is 'called'.</p> <p>The arguments that are given will be filled into the formatted string. Arguments can be positional or keyword arguments, not both.</p>"},{"location":"api/command/#egse.command.CommandError","title":"CommandError","text":"<p>               Bases: <code>Error</code></p> <p>A Command Exception as a base class for this module.</p>"},{"location":"api/command/#egse.command.CommandExecution","title":"CommandExecution","text":"<pre><code>CommandExecution(cmd, *args, **kwargs)\n</code></pre> <p>This class contains all the information that is needed to execute a command with a set of parameters/arguments. The command is however not executed automatically. That is the responsibility of the caller to actually execute the command with the given parameters.</p> Developer info <p>you can see this as a partial (functools) which defines the command and its arguments, but doesn't execute until explicitly called. You can execute the command by calling the <code>cmd</code> with the given arguments:</p> <pre><code>ce = CommandExecution(cmd, 20.0)\n...\nresponse = ce.run()\n</code></pre>"},{"location":"api/command/#egse.command.InvalidArgumentsError","title":"InvalidArgumentsError","text":"<p>               Bases: <code>CommandError</code></p> <p>The arguments provided are invalid</p>"},{"location":"api/command/#egse.command.InvalidCommandExecution","title":"InvalidCommandExecution","text":"<pre><code>InvalidCommandExecution(exc, cmd, *args, **kwargs)\n</code></pre> <p>               Bases: <code>CommandExecution</code></p> <p>A invalid command execution.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>Exception</code> <p>the Exception that was raised and describes the problem</p> required <code>cmd</code> <code>type</code> <p>the Command object</p> required <code>*args</code> <code>tuple</code> <p>the positional arguments that were given</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>the keyword arguments that were given</p> <code>{}</code>"},{"location":"api/command/#egse.command.dry_run","title":"dry_run","text":"<pre><code>dry_run(func)\n</code></pre> <p>This decorator prepares the function to handle a dry run.</p> <p>A dry run is used to check the logic of an instrument commanding script without actually executing the instrument commands. The commands are instead added to the command sequence in the global state.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>the function that needs to be executed</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A wrapper around the given function.</p>"},{"location":"api/command/#egse.command.get_function","title":"get_function","text":"<pre><code>get_function(parent_class, method_name)\n</code></pre> <p>Returns a function (unbound method) from a given class.</p> <p>Parameters:</p> Name Type Description Default <code>parent_class</code> <code>type</code> <p>the class that provides the method</p> required <code>method_name</code> <code>str</code> <p>name of the method that is requested</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>the method [type: function].</p> Note <p>The function returned is an unbound class instance method and therefore this function expects as its first argument the class instance, i.e. self, when you call it as a function.</p>"},{"location":"api/command/#egse.command.get_method","title":"get_method","text":"<pre><code>get_method(parent_obj, method_name)\n</code></pre> <p>Returns a bound method from a given class instance.</p> <p>Parameters:</p> Name Type Description Default <code>parent_obj</code> <code>type</code> <p>the class instance that provides the method</p> required <code>method_name</code> <code>str</code> <p>name of the method that is requested</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>the method [type: method].</p> Note <p>The method returned is an bound class instance method and therefore this method does not expects as its first argument the class instance, i.e. self, when you call this as a function.</p>"},{"location":"api/command/#egse.command.load_commands","title":"load_commands","text":"<pre><code>load_commands(\n    protocol_class,\n    command_settings,\n    command_class,\n    device_class,\n)\n</code></pre> <p>Loads the command definitions from the given <code>command_settings</code> and builds an internal dictionary containing the command names as keys and the corresponding <code>Command</code> class objects as values.</p> <p>The purpose of this function is to gather information about the commands that will be transferred from the control server to the proxy. The actual response or device method will therefore be a function instead of an instance method (because the instance will not be known in the Proxy).</p> <p>The <code>command_settings</code> is usually loaded from a YAML configuration file containing the command definitions for the device.</p> <p>Parameters:</p> Name Type Description Default <code>protocol_class</code> <code>type[CommandProtocol]</code> <p>the CommandProtocol or a subclass</p> required <code>command_settings</code> <code>dict</code> <p>a dictionary containing the command definitions for this device</p> required <code>command_class</code> <code>type[Command]</code> <p>the type of command to create, a subclass of Command</p> required <code>device_class</code> <code>type</code> <p>the type of the base device class from which the methods are loaded</p> required <p>Returns:</p> Type Description <code>dict[str, Command]</code> <p>A dictionary with command names and their corresponding commands.</p>"},{"location":"api/command/#egse.command.parse_format_string","title":"parse_format_string","text":"<pre><code>parse_format_string(fstring)\n</code></pre> <p>Parse and decode the format string.</p>"},{"location":"api/config/","title":"egse.config","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/config/#egse.config","title":"egse.config","text":"<p>This module provides convenience functions to properly configure the CGSE and to find paths and resources.</p> <p>Classes:</p> Name Description <code>WorkingDirectory</code> <p>WorkingDirectory is a context manager to temporarily change the working directory while</p> <p>Functions:</p> Name Description <code>find_dir</code> <p>Find the first folder that matches the given pattern.</p> <code>find_dirs</code> <p>Generator for returning directory paths from a walk started at <code>root</code> and matching pattern.</p> <code>find_file</code> <p>Find the path to the given file starting from the root directory of the</p> <code>find_files</code> <p>Generator for returning file paths from a top folder, matching the pattern.</p> <code>find_first_occurrence_of_dir</code> <p>Returns the full path of the directory that first matches the pattern. The directory hierarchy is</p> <code>find_root</code> <p>Find the root folder based on the files in <code>tests</code>.</p> <code>set_logger_levels</code> <p>Set the logging level for the given loggers.</p>"},{"location":"api/config/#egse.config.WorkingDirectory","title":"WorkingDirectory","text":"<pre><code>WorkingDirectory(path)\n</code></pre> <p>WorkingDirectory is a context manager to temporarily change the working directory while executing some code.</p> <p>This context manager has a property <code>path</code> which returns the absolute path of the current directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>(str, Path)</code> <p>the folder to change to within this context</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>when the given path doesn't exist.</p> Example <pre><code>with WorkingDirectory(find_dir(\"/egse/images\")) as wdir:\n    for file in wdir.path.glob('*'):\n        assert file.exists()  # do something with the image files\n</code></pre> <p>Attributes:</p> Name Type Description <code>path</code> <p>Resolve and return the current Path of the context.</p>"},{"location":"api/config/#egse.config.WorkingDirectory.path","title":"path  <code>property</code>","text":"<pre><code>path\n</code></pre> <p>Resolve and return the current Path of the context.</p>"},{"location":"api/config/#egse.config.find_dir","title":"find_dir","text":"<pre><code>find_dir(pattern, root)\n</code></pre> <p>Find the first folder that matches the given pattern.</p> <p>Note that if there are more folders that match the pattern in the distribution, this function only returns the first occurrence that is found, which might not be what you want. To be sure only one folder is returned, use the <code>find_dirs()</code> function and check if there is just one item returned in the list.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>pattern to match (use * for wildcard)</p> required <code>root</code> <code>Path | str</code> <p>the top level folder to search</p> required <p>Returns:</p> Type Description <code>Path | None</code> <p>the first occurrence of the directory pattern or None when not found.</p>"},{"location":"api/config/#egse.config.find_dirs","title":"find_dirs","text":"<pre><code>find_dirs(pattern, root)\n</code></pre> <p>Generator for returning directory paths from a walk started at <code>root</code> and matching pattern.</p> <p>The pattern can contain the asterisk '*' as a wildcard.</p> <p>The pattern can contain a directory separator '/' which means the last part of the path needs to match these folders.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>pattern to match (use * for wildcard)</p> required <code>root</code> <code>str</code> <p>the top level folder to search</p> required <p>Returns:</p> Name Type Description <code>Generator</code> <code>None</code> <p>Paths of folders matching pattern, from root.</p> Example <pre><code>&gt;&gt;&gt; for folder in find_dirs(\"/egse/images\"):\n...     assert folder.match('*/egse/images')\n\n&gt;&gt;&gt; folders = list(find_dirs(\"/egse/images\"))\n&gt;&gt;&gt; assert len(folders)\n</code></pre>"},{"location":"api/config/#egse.config.find_file","title":"find_file","text":"<pre><code>find_file(name, root, in_dir=None)\n</code></pre> <p>Find the path to the given file starting from the root directory of the distribution.</p> <p>Note that if there are more files with the given name found in the distribution, this function only returns the first file that is found, which might not be what you want. To be sure only one file is returned, use the <code>find_files()</code> function and check if there is just one file returned in the list.</p> <p>When the file shall be in a specific directory, use the <code>in_dir</code> keyword. This requires that the path ends with the given string in <code>in_dir</code>.</p> <pre><code>&gt;&gt;&gt; file_pattern = 'EtherSpaceLink*.dylib'\n&gt;&gt;&gt; in_dir = 'lib/CentOS-7'\n&gt;&gt;&gt; file = find_file(file_pattern, root='.', in_dir=in_dir)\n&gt;&gt;&gt; assert file.match(\"*/lib/CentOS-7/EtherSpace*\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the file</p> required <code>root</code> <code>Path | str</code> <p>the top level folder to search</p> required <code>in_dir</code> <code>str</code> <p>the 'leaf' directory in which the file shall be</p> <code>None</code> <p>Returns:</p> Type Description <code>Path | None</code> <p>the first occurrence of the file or None when not found.</p>"},{"location":"api/config/#egse.config.find_files","title":"find_files","text":"<pre><code>find_files(pattern, root, in_dir=None)\n</code></pre> <p>Generator for returning file paths from a top folder, matching the pattern.</p> <p>The top folder can be specified as e.g. <code>__file__</code> in which case the parent of that file will be used as the top root folder. Note that when you specify '.' as the root argument the current working directory will be taken as the root folder, which is probably not what you intended.</p> <p>When the file shall be in a specific directory, use the <code>in_dir</code> keyword. This requires that the path ends with the given string in <code>in_dir</code>.</p> <pre><code>&gt;&gt;&gt; file_pattern = 'EtherSpaceLink*.dylib'\n&gt;&gt;&gt; in_dir = 'lib/CentOS-7'\n&gt;&gt;&gt; for file in find_files(file_pattern, root='.', in_dir=in_dir):\n...     assert file.match(\"*lib/CentOS-7/EtherSpaceLink*\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str) </code> <p>sorting pattern (use * for wildcard)</p> required <code>root</code> <code>Path | str</code> <p>the top level folder to search</p> required <code>in_dir</code> <code>str</code> <p>the 'leaf' directory in which the file shall be</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Paths of files matching pattern, from root.</p>"},{"location":"api/config/#egse.config.find_first_occurrence_of_dir","title":"find_first_occurrence_of_dir","text":"<pre><code>find_first_occurrence_of_dir(pattern, root)\n</code></pre> <p>Returns the full path of the directory that first matches the pattern. The directory hierarchy is traversed in alphabetical order. The pattern is matched first against all directories in the root folder, if there is no match, the first folder in root is traversed until a match is found. If no match is found, the second folder in root is traversed.</p> <p>Note that the pattern may contain parent directories, like <code>/egse/data/icons</code> or <code>egse/*/icons</code>, in which case the full pattern is matched.</p> <p>In the case that you pass an empty string for the root argument, it will resolve into the current working directory.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>a filename pattern</p> required <code>root</code> <code>Path | str</code> <p>the root folder to start the hierarchical search</p> required <p>Returns:</p> Type Description <code>Path | None</code> <p>The full path of the matched pattern or None if no match could be found.</p>"},{"location":"api/config/#egse.config.find_root","title":"find_root","text":"<pre><code>find_root(path, tests=(), default=None)\n</code></pre> <p>Find the root folder based on the files in <code>tests</code>.</p> <p>The algorithm crawls backward over the directory structure until one of the items in <code>tests</code> is matched. and it will return that directory as a <code>Path</code>.</p> <p>When no root folder can be determined, the <code>default</code> parameter is returned as a Path (or None).</p> <p>When nothing is provided in <code>tests</code>, all matches will fail and the <code>default</code> parameter will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, PurePath] | None</code> <p>folder from which the search is started</p> required <code>tests</code> <code>Tuple[str, ...]</code> <p>names (files or dirs) to test for existence</p> <code>()</code> <code>default</code> <code>str</code> <p>returned when no root is found</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[PurePath, None]</code> <p>a Path which is the root folder.</p>"},{"location":"api/config/#egse.config.set_logger_levels","title":"set_logger_levels","text":"<pre><code>set_logger_levels(logger_levels=None)\n</code></pre> <p>Set the logging level for the given loggers.</p>"},{"location":"api/control/","title":"egse.control","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/control/#egse.control","title":"egse.control","text":"<p>This module defines the abstract class for any Control Server and some convenience functions.</p> <p>Classes:</p> Name Description <code>ControlServer</code> <p>Base class for all device control servers and for the Storage Manager and Configuration Manager.</p> <p>Functions:</p> Name Description <code>is_control_server_active</code> <p>Checks if the Control Server is running.</p>"},{"location":"api/control/#egse.control.ControlServer","title":"ControlServer","text":"<pre><code>ControlServer(device_id=None)\n</code></pre> <p>Base class for all device control servers and for the Storage Manager and Configuration Manager.</p> <p>A Control Server reads commands from a ZeroMQ socket and executes these commands by calling the <code>execute()</code> method of the commanding protocol class.</p> <p>The subclass shall define the following:</p> <ul> <li>Define the device protocol class -&gt; <code>self.device_protocol</code></li> <li>Bind the command socket to the device protocol -&gt; <code>self.dev_ctrl_cmd_sock</code></li> <li>Register the command socket in the poll set -&gt; <code>self.poller</code></li> </ul> <p>Methods:</p> Name Description <code>after_serve</code> <p>This method needs to be overridden by the subclass if certain actions need to be executed after the control</p> <code>before_serve</code> <p>This method needs to be overridden by the subclass if certain actions need to be executed before the control</p> <code>get_average_execution_times</code> <p>Returns the average execution times of all functions that have been monitored by this process.</p> <code>get_commanding_port</code> <p>Returns the commanding port used by the Control Server.</p> <code>get_communication_protocol</code> <p>Returns the communication protocol used by the Control Server.</p> <code>get_ip_address</code> <p>Returns the IP address of the current host.</p> <code>get_monitoring_port</code> <p>Returns the monitoring port used by the Control Server.</p> <code>get_process_status</code> <p>Returns the process status of the Control Server.</p> <code>get_service_port</code> <p>Returns the service port used by the Control Server.</p> <code>get_storage_mnemonic</code> <p>Returns the storage mnemonics used by the Control Server.</p> <code>handle_scheduled_tasks</code> <p>Executes or reschedules tasks in the <code>serve()</code> event loop.</p> <code>is_storage_manager_active</code> <p>Checks if the Storage Manager is active.</p> <code>notify_listeners</code> <p>Notifies registered listeners about an event.</p> <code>propagate_metrics</code> <p>Propagates the given housekeeping information to the metrics database.</p> <code>quit</code> <p>Interrupts the Control Server.</p> <code>register_as_listener</code> <p>Registers a listener with the specified proxy.</p> <code>register_to_storage_manager</code> <p>Registers this Control Server to the Storage Manager.</p> <code>schedule_task</code> <p>Schedules a task to run in the control server event loop.</p> <code>serve</code> <p>Activation of the Control Server.</p> <code>set_hk_delay</code> <p>Sets the delay time for housekeeping.</p> <code>set_logging_level</code> <p>Sets the logging level to the given level.</p> <code>set_mon_delay</code> <p>Sets the delay time for monitoring.</p> <code>set_scheduled_task_delay</code> <p>Sets the delay time between successive executions of scheduled tasks.</p> <code>store_housekeeping_information</code> <p>Sends housekeeping information to the Storage Manager.</p> <code>unregister_as_listener</code> <p>Removes a registered listener from the specified proxy.</p> <code>unregister_from_storage_manager</code> <p>Unregisters the Control Server from the Storage Manager.</p>"},{"location":"api/control/#egse.control.ControlServer.after_serve","title":"after_serve","text":"<pre><code>after_serve()\n</code></pre> <p>This method needs to be overridden by the subclass if certain actions need to be executed after the control server has been deactivated.</p>"},{"location":"api/control/#egse.control.ControlServer.before_serve","title":"before_serve","text":"<pre><code>before_serve()\n</code></pre> <p>This method needs to be overridden by the subclass if certain actions need to be executed before the control server is activated.</p>"},{"location":"api/control/#egse.control.ControlServer.get_average_execution_times","title":"get_average_execution_times","text":"<pre><code>get_average_execution_times()\n</code></pre> <p>Returns the average execution times of all functions that have been monitored by this process.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the average execution times of all functions that have been monitored by this process. The dictionary keys are the function names, and the values are the average execution times in ms.</p>"},{"location":"api/control/#egse.control.ControlServer.get_commanding_port","title":"get_commanding_port  <code>abstractmethod</code>","text":"<pre><code>get_commanding_port()\n</code></pre> <p>Returns the commanding port used by the Control Server.</p> <p>Returns:</p> Type Description <code>int</code> <p>Commanding port used by the Control Server, as specified in the settings.</p>"},{"location":"api/control/#egse.control.ControlServer.get_communication_protocol","title":"get_communication_protocol  <code>abstractmethod</code>","text":"<pre><code>get_communication_protocol()\n</code></pre> <p>Returns the communication protocol used by the Control Server.</p> <p>Returns:</p> Type Description <code>str</code> <p>Communication protocol used by the Control Server, as specified in the settings.</p>"},{"location":"api/control/#egse.control.ControlServer.get_ip_address","title":"get_ip_address","text":"<pre><code>get_ip_address()\n</code></pre> <p>Returns the IP address of the current host.</p>"},{"location":"api/control/#egse.control.ControlServer.get_monitoring_port","title":"get_monitoring_port  <code>abstractmethod</code>","text":"<pre><code>get_monitoring_port()\n</code></pre> <p>Returns the monitoring port used by the Control Server.</p> <p>Returns:</p> Type Description <code>int</code> <p>Monitoring port used by the Control Server, as specified in the settings.</p>"},{"location":"api/control/#egse.control.ControlServer.get_process_status","title":"get_process_status","text":"<pre><code>get_process_status()\n</code></pre> <p>Returns the process status of the Control Server.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the process status of the Control Server.</p>"},{"location":"api/control/#egse.control.ControlServer.get_service_port","title":"get_service_port  <code>abstractmethod</code>","text":"<pre><code>get_service_port()\n</code></pre> <p>Returns the service port used by the Control Server.</p> <p>Returns:</p> Type Description <code>int</code> <p>Service port used by the Control Server, as specified in the settings.</p>"},{"location":"api/control/#egse.control.ControlServer.get_storage_mnemonic","title":"get_storage_mnemonic","text":"<pre><code>get_storage_mnemonic()\n</code></pre> <p>Returns the storage mnemonics used by the Control Server.</p> <p>This is a string that will appear in the filename with the housekeeping information of the device, as a way of identifying the device.  If this is not implemented in the subclass, then the class name will be used.</p> <p>Returns:</p> Type Description <code>str</code> <p>Storage mnemonics used by the Control Server, as specified in the settings.</p>"},{"location":"api/control/#egse.control.ControlServer.handle_scheduled_tasks","title":"handle_scheduled_tasks","text":"<pre><code>handle_scheduled_tasks()\n</code></pre> <p>Executes or reschedules tasks in the <code>serve()</code> event loop.</p>"},{"location":"api/control/#egse.control.ControlServer.is_storage_manager_active","title":"is_storage_manager_active","text":"<pre><code>is_storage_manager_active()\n</code></pre> <p>Checks if the Storage Manager is active.</p> <p>This method has to be implemented by the subclass if you need to store information.</p> <p>Note: You might want to set a specific timeout when checking for the Storage Manager.</p> <p>Note: If this method returns True, the following methods shall also be implemented by the subclass:</p> <ul> <li>register_to_storage_manager()</li> <li>unregister_from_storage_manager()</li> <li>store_housekeeping_information()</li> </ul> <p>Returns:</p> Type Description <code>bool</code> <p>True if the Storage Manager is active; False otherwise.</p>"},{"location":"api/control/#egse.control.ControlServer.notify_listeners","title":"notify_listeners","text":"<pre><code>notify_listeners(event_id=0, context=None)\n</code></pre> <p>Notifies registered listeners about an event.</p> <p>This function creates an Event object with the provided <code>event_id</code> and <code>context</code> and notifies all registered listeners with the created event.</p> <p>Parameters:</p> Name Type Description Default <code>event_id</code> <code>int</code> <p>The identifier for the event. Defaults to 0.</p> <code>0</code> <code>context</code> <code>dict</code> <p>Additional context information associated with the event. Defaults to None.</p> <code>None</code> Note <p>The notification is performed by the <code>notify_listeners</code> method of the <code>listeners</code> object associated with this instance. The notification is executed in a daemon thread to avoid blocking the commanding chain.</p>"},{"location":"api/control/#egse.control.ControlServer.propagate_metrics","title":"propagate_metrics","text":"<pre><code>propagate_metrics(hk)\n</code></pre> <p>Propagates the given housekeeping information to the metrics database.</p> <p>Nothing will be written to the metrics database if the <code>hk</code> dict doesn't contain any metrics (except for the timestamp).</p> <p>Parameters:</p> Name Type Description Default <code>hk</code> <code>dict</code> <p>Dictionary containing parameter name and value of all device housekeeping. There is also        a timestamp that represents the date/time when the HK was received from the device.</p> required"},{"location":"api/control/#egse.control.ControlServer.quit","title":"quit","text":"<pre><code>quit()\n</code></pre> <p>Interrupts the Control Server.</p>"},{"location":"api/control/#egse.control.ControlServer.register_as_listener","title":"register_as_listener","text":"<pre><code>register_as_listener(proxy, listener)\n</code></pre> <p>Registers a listener with the specified proxy.</p> <p>This function attempts to add the provided listener to the specified proxy. It employs a retry mechanism to handle potential ConnectionError exceptions, making up to 5 attempts to add the listener.</p> <p>Parameters:</p> Name Type Description Default <code>proxy</code> <code>Type</code> <p>A callable object representing the proxy to which the listener will be added.</p> required <code>listener</code> <code>dict</code> <p>The listener to be registered. Should be a dictionary containing listener details.</p> required <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the connection to the proxy encounters issues even after multiple retry attempts.</p> Note <p>The function runs in a separate daemon thread to avoid blocking the main thread.</p>"},{"location":"api/control/#egse.control.ControlServer.register_to_storage_manager","title":"register_to_storage_manager","text":"<pre><code>register_to_storage_manager()\n</code></pre> <p>Registers this Control Server to the Storage Manager.</p> <p>By doing so, the housekeeping information of the device will be sent to the Storage Manager, which will store the information in a dedicated CSV file.</p> <p>This method has to be overwritten by the subclasses if they have housekeeping information that must be stored.</p> <p>Subclasses need to overwrite this method if they have housekeeping information to be stored.</p> <p>The following   information is required for the registration:</p> <ul> <li>origin: Storage mnemonic, which can be retrieved from <code>self.get_storage_mnemonic()</code></li> <li>persistence_class: Persistence layer (one of the TYPES in egse.storage.persistence)</li> <li>prep: depending on the type of the persistence class (see respective documentation)</li> </ul> <p>The <code>egse.storage</code> module provides a convenience method that can be called from the method in the subclass:</p> <pre><code>&gt;&gt;&gt; from egse.storage import register_to_storage_manager  # noqa\n</code></pre> Note <p>the <code>egse.storage</code> module might not be available, it is provided by the <code>cgse-core</code> package.</p>"},{"location":"api/control/#egse.control.ControlServer.schedule_task","title":"schedule_task","text":"<pre><code>schedule_task(callback, after=0.0, when=None)\n</code></pre> <p>Schedules a task to run in the control server event loop.</p> <p>The <code>callback</code> function will be executed as soon as possible in the <code>serve()</code> event loop.</p> <p>Some simple scheduling options are available:</p> <ul> <li>after: the task will only execute 'x' seconds after the time of scheduling. I.e.   the task will be rescheduled until time &gt; scheduled time + 'x' seconds.</li> <li>when: the task will only execute when the condition is True.</li> </ul> <p>The <code>after</code> and the <code>when</code> arguments can be combined.</p> Note <ul> <li>This function is intended to be used in order to prevent a deadlock.</li> <li>Since the <code>callback</code> function is executed in the <code>serve()</code> event loop, it shall not block!</li> </ul>"},{"location":"api/control/#egse.control.ControlServer.serve","title":"serve","text":"<pre><code>serve()\n</code></pre> <p>Activation of the Control Server.</p> <p>This comprises the following steps:</p> <ul> <li>Executing the <code>before_serve</code> method;</li> <li>Checking if the Storage Manager is active and registering the Control Server to it;</li> <li>Start listening  for keyboard interrupts;</li> <li>Start accepting (listening to) commands;</li> <li>Start sending out monitoring information;</li> <li>Start sending out housekeeping information;</li> <li>Start listening for quit commands;</li> <li>After a quit command has been received:<ul> <li>Unregister from the Storage Manager;</li> <li>Execute the <code>after_serve</code> method;</li> <li>Close all sockets;</li> <li>Clean up all threads.</li> </ul> </li> </ul>"},{"location":"api/control/#egse.control.ControlServer.set_hk_delay","title":"set_hk_delay","text":"<pre><code>set_hk_delay(seconds)\n</code></pre> <p>Sets the delay time for housekeeping.</p> <p>The delay time is the time between two successive executions of the <code>get_housekeeping()</code> function of the device protocol.</p> <p>It might happen that the delay time that is set is longer than what you requested. That is the case when the execution of the <code>get_housekeeping()</code> function takes longer than the requested delay time. That should prevent the server from blocking when a too short delay time is requested.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Number of seconds between the housekeeping calls</p> required <p>Returns:</p> Type Description <code>float</code> <p>Delay that was set [ms].</p>"},{"location":"api/control/#egse.control.ControlServer.set_logging_level","title":"set_logging_level","text":"<pre><code>set_logging_level(level)\n</code></pre> <p>Sets the logging level to the given level.</p> <p>Allowed logging levels are:</p> <ul> <li>\"CRITICAL\" or \"FATAL\" or 50</li> <li>\"ERROR\" or 40</li> <li>\"WARNING\" or \"WARN\" or 30</li> <li>\"INFO\" or 20</li> <li>\"DEBUG\" or 10</li> <li>\"NOTSET\" or 0</li> </ul> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | str</code> <p>Logging level to use, specified as either a string or an integer</p> required"},{"location":"api/control/#egse.control.ControlServer.set_mon_delay","title":"set_mon_delay","text":"<pre><code>set_mon_delay(seconds)\n</code></pre> <p>Sets the delay time for monitoring.</p> <p>The delay time is the time between two successive executions of the <code>get_status()</code> function of the device protocol.</p> <p>It might happen that the delay time that is set is longer than what you requested. That is the case when the execution of the <code>get_status()</code> function takes longer than the requested delay time. That should prevent the server from blocking when a too short delay time is requested.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Number of seconds between the monitoring calls</p> required <p>Returns:</p> Type Description <code>float</code> <p>Delay that was set [ms].</p>"},{"location":"api/control/#egse.control.ControlServer.set_scheduled_task_delay","title":"set_scheduled_task_delay","text":"<pre><code>set_scheduled_task_delay(seconds)\n</code></pre> <p>Sets the delay time between successive executions of scheduled tasks.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>the time interval between two successive executions [seconds]</p> required"},{"location":"api/control/#egse.control.ControlServer.store_housekeeping_information","title":"store_housekeeping_information","text":"<pre><code>store_housekeeping_information(data)\n</code></pre> <p>Sends housekeeping information to the Storage Manager.</p> <p>This method has to be overwritten by the subclasses if they want the device housekeeping information to be saved.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>a dictionary containing parameter name and value of all device housekeeping. There is also a timestamp that represents the date/time when the HK was received from the device.</p> required"},{"location":"api/control/#egse.control.ControlServer.unregister_as_listener","title":"unregister_as_listener","text":"<pre><code>unregister_as_listener(proxy, listener)\n</code></pre> <p>Removes a registered listener from the specified proxy.</p> <p>This function attempts to remove the provided listener from the specified proxy. It employs a retry mechanism to handle potential ConnectionError exceptions, making up to 5 attempts to add the listener.</p> <p>Parameters:</p> Name Type Description Default <code>proxy</code> <code>Type</code> <p>A callable object representing the proxy from which the listener will be removed.</p> required <code>listener</code> <code>dict</code> <p>The listener to be removed. Should be a dictionary containing listener details.</p> required <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the connection to the proxy encounters issues even after multiple retry attempts.</p> Note <p>The function runs in a separate thread but will block until the de-registration is finished. The reason being that this method is usually called in a <code>after_serve</code> block so it needs to finish before the ZeroMQ context is destroyed.</p>"},{"location":"api/control/#egse.control.ControlServer.unregister_from_storage_manager","title":"unregister_from_storage_manager","text":"<pre><code>unregister_from_storage_manager()\n</code></pre> <p>Unregisters the Control Server from the Storage Manager.</p> <p>This method has to be overwritten by the subclasses.</p> <p>The following information is required for the registration:</p> <ul> <li>origin: Storage mnemonic, which can be retrieved from <code>self.get_storage_mnemonic()</code></li> </ul> <p>The <code>egse.storage</code> module provides a convenience method that can be called from the method in the subclass:</p> <pre><code>&gt;&gt;&gt; from egse.storage import unregister_from_storage_manager  # noqa\n</code></pre> Note <p>the <code>egse.storage</code> module might not be available, it is provided by the <code>cgse-core</code> package.</p>"},{"location":"api/control/#egse.control.is_control_server_active","title":"is_control_server_active","text":"<pre><code>is_control_server_active(endpoint=None, timeout=0.5)\n</code></pre> <p>Checks if the Control Server is running.</p> <p>This function sends a Ping message to the Control Server and expects a Pong answer back within the timeout period.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Endpoint to connect to, i.e. ://: <code>None</code> <code>timeout</code> <code>float</code> <p>Timeout when waiting for a reply [s, default=0.5]</p> <code>0.5</code>"},{"location":"api/counter/","title":"egse.counter","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/counter/#egse.counter","title":"egse.counter","text":"<p>This module manages files that have a counter in their filename.</p> <p>Functions:</p> Name Description <code>counter_exists</code> <p>Returns True if the given file exists, False otherwise.</p> <code>counter_filename</code> <p>Creates an absolute filename to be used as a counter file. A counter file usually has a 'count' extension</p> <code>get_next_counter</code> <p>Read the counter from a dedicated file, add one and save the counter back to the file.</p> <code>new_counter</code> <p>Create a counter based on the files that already exist for the given pattern.</p>"},{"location":"api/counter/#egse.counter.counter_exists","title":"counter_exists","text":"<pre><code>counter_exists(filename)\n</code></pre> <p>Returns True if the given file exists, False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>path of the counter file</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the given filename exists, False otherwise.</p> <p>Raises:</p> Type Description <code>OSError</code> <p>might be raised by Path.</p> Note <p>No checking is done if the file is indeed a counter file, i.e. if it contains the correct content.   So, this function basically only checks if the given Path exists and if it is a regular file.</p>"},{"location":"api/counter/#egse.counter.counter_filename","title":"counter_filename","text":"<pre><code>counter_filename(location, filename)\n</code></pre> <p>Creates an absolute filename to be used as a counter file. A counter file usually has a 'count' extension but that is not enforced by this module. The location can be a relative path, even '.' or '..' are accepted.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Path</code> <p>the location of the counter file.</p> required <code>filename</code> <code>Path | str</code> <p>the name of the counter file, use the '.count' extension.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>An absolute filename.</p> Note <p>If the file doesn't exist, it is NOT created.</p>"},{"location":"api/counter/#egse.counter.determine_counter_from_dir_list","title":"determine_counter_from_dir_list","text":"<pre><code>determine_counter_from_dir_list(\n    location, pattern, index=-1\n)\n</code></pre> <p>Determine counter for a new file at the given location and with the given pattern. The next counter is determined from the sorted list of files that match the given pattern.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>Location where the file should be stored.</p> required <code>pattern</code> <code>str</code> <p>Pattern for the filename.</p> required <code>index</code> <code>int</code> <p>the location of the counter in the filename after it is split on '_' [default=-1]</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The value of the next counter, 1 if no previous files were found or if an error occurred.</p>"},{"location":"api/counter/#egse.counter.get_next_counter","title":"get_next_counter","text":"<pre><code>get_next_counter(filename)\n</code></pre> <p>Read the counter from a dedicated file, add one and save the counter back to the file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>full pathname of the file that contains the required counter</p> required <p>Returns:</p> Type Description <code>int</code> <p>The value of the next counter, 1 if no previous files were found or if an error occurred.</p> Note <p>This will create the counter file if it doesn't exist.</p>"},{"location":"api/counter/#egse.counter.new_counter","title":"new_counter","text":"<pre><code>new_counter(filename, pattern)\n</code></pre> <p>Create a counter based on the files that already exist for the given pattern.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>the name of the counter file</p> required <code>pattern</code> <code>str</code> <p>a pattern to match the filenames</p> required <p>Returns:</p> Type Description <code>int</code> <p>The next counter value as an integer.</p>"},{"location":"api/decorators/","title":"egse.decorators","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/decorators/#egse.decorators","title":"egse.decorators","text":"<p>A collection of useful decorator functions.</p> <p>Classes:</p> Name Description <code>Nothing</code> <p>Just to get a nice repr for Nothing. It is kind of a Null object...</p> <code>Profiler</code> <p>A simple profiler class that provides some useful functions to profile a function.</p> <code>classproperty</code> <p>Defines a read-only class property.</p> <p>Functions:</p> Name Description <code>async_timer</code> <p>Print the runtime of the decorated async function.</p> <code>average_time</code> <p>This is a decorator that is intended mainly as a development aid. When you decorate your function with</p> <code>borg</code> <p>Use the Borg pattern to make a class with a shared state between its instances and subclasses.</p> <code>debug</code> <p>Logs the function signature and return value.</p> <code>deprecate</code> <p>Deprecate a function or method. This will print a warning with the function name and where</p> <code>dynamic_interface</code> <p>Adds a static variable <code>__dynamic_interface</code> to a method.</p> <code>execution_count</code> <p>Counts the number of times the function has been executed.</p> <code>implements_protocol</code> <p>Decorator to verify and document protocol compliance at class definition time.</p> <code>profile</code> <p>Prints the function signature and return value to stdout.</p> <code>profile_func</code> <p>A time profiler decorator.</p> <code>query_command</code> <p>Adds a static variable <code>__query_command</code> to a method.</p> <code>read_command</code> <p>Adds a static variable <code>__read_command</code> to a method.</p> <code>retry</code> <p>Decorator that retries a function multiple times with a delay between attempts.</p> <code>retry_with_exponential_backoff</code> <p>Decorator for retrying a function with exponential backoff.</p> <code>singleton</code> <p>Use class as a singleton.</p> <code>spy_on_attr_change</code> <p>Tweak an object to show attributes changing. The changes are reported as WARNING log messages</p> <code>static_vars</code> <p>Define static variables in a function.</p> <code>time_it</code> <p>Print the runtime of the decorated function.</p> <code>timer</code> <p>Print the runtime of the decorated function.</p> <code>to_be_implemented</code> <p>Print a warning message that this function/method has to be implemented.</p> <code>transaction_command</code> <p>Adds a static variable <code>__transaction_command</code> to a method.</p> <code>write_command</code> <p>Adds a static variable <code>__write_command</code> to a method.</p>"},{"location":"api/decorators/#egse.decorators.Nothing","title":"Nothing","text":"<p>Just to get a nice repr for Nothing. It is kind of a Null object...</p>"},{"location":"api/decorators/#egse.decorators.Profiler","title":"Profiler","text":"<p>A simple profiler class that provides some useful functions to profile a function.</p> <ul> <li>count: count the number of times this function is executed</li> <li>duration: measure the total and average duration of the function [seconds]</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from egse.decorators import Profiler\n&gt;&gt;&gt; @Profiler.count()\n... def square(x):\n...     return x**2\n</code></pre> <pre><code>&gt;&gt;&gt; x = [square(x) for x in range(1_000_000)]\n</code></pre> <pre><code>&gt;&gt;&gt; print(f\"Function 'square' called {square.get_count()} times.\")\n&gt;&gt;&gt; print(square)\n</code></pre> <pre><code>&gt;&gt;&gt; @Profiler.duration()\n... def square(x):\n...     time.sleep(0.1)\n...     return x**2\n</code></pre> <pre><code>&gt;&gt;&gt; x = [square(x) for x in range(100)]\n</code></pre> <pre><code>&gt;&gt;&gt; print(f\"Function 'square' takes on average {square.get_average_duration():.6f} seconds.\")\n&gt;&gt;&gt; print(square)\n</code></pre>"},{"location":"api/decorators/#egse.decorators.classproperty","title":"classproperty","text":"<pre><code>classproperty(func)\n</code></pre> <p>Defines a read-only class property.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class Message:\n...     def __init__(self, msg):\n...         self._msg = msg\n...\n...     @classproperty\n...     def name(cls):\n...         return cls.__name__\n\n&gt;&gt;&gt; msg = Message(\"a simple doctest\")\n&gt;&gt;&gt; assert \"Message\" == msg.name\n</code></pre>"},{"location":"api/decorators/#egse.decorators.async_timer","title":"async_timer","text":"<pre><code>async_timer(*, name='timer', level=INFO, precision=4)\n</code></pre> <p>Print the runtime of the decorated async function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>a name for the Timer, will be printed in the logging message</p> <code>'timer'</code> <code>level</code> <code>int</code> <p>the logging level for the time message [default=INFO]</p> <code>INFO</code> <code>precision</code> <code>int</code> <p>the number of decimals for the time [default=3 (ms)]</p> <code>4</code>"},{"location":"api/decorators/#egse.decorators.average_time","title":"average_time","text":"<pre><code>average_time(\n    *, name=\"average_time\", level=INFO, precision=6\n)\n</code></pre> <p>This is a decorator that is intended mainly as a development aid. When you decorate your function with <code>@average_time</code>, the execution time of your function will be kept and accumulated. At anytime in your code, you can request the total execution time and the number of calls:</p> <pre><code>@average_time()\ndef my_function():\n    ...\ntotal_execution_time, call_count = my_function.report()\n</code></pre> <p>Requesting the report will automatically log the average runtime and the number of calls. If you need to reset the execution time and the number of calls during your testing, use:</p> <pre><code>my_function.reset()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A name for the timer that will be used during reporting, default='average_time'</p> <code>'average_time'</code> <code>level</code> <code>int</code> <p>the required log level, default=logging.INFO</p> <code>INFO</code> <code>precision</code> <code>int</code> <p>the precision used to report the average time, default=6</p> <code>6</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function.</p>"},{"location":"api/decorators/#egse.decorators.borg","title":"borg","text":"<pre><code>borg(cls)\n</code></pre> <p>Use the Borg pattern to make a class with a shared state between its instances and subclasses.</p> from <p>we don't need no singleton</p>"},{"location":"api/decorators/#egse.decorators.debug","title":"debug","text":"<pre><code>debug(func)\n</code></pre> <p>Logs the function signature and return value.</p>"},{"location":"api/decorators/#egse.decorators.deprecate","title":"deprecate","text":"<pre><code>deprecate(reason=None, alternative=None)\n</code></pre> <p>Deprecate a function or method. This will print a warning with the function name and where it is called from. If the optional parameters <code>reason</code> and <code>alternative</code> are given, that information will be printed with the warning.</p> <p>Examples:</p> <pre><code>@deprecate(reason=\"it doesn't follow PEP8\", alternative=\"set_color()\")\ndef setColor(self, color):\n    self.set_color(color)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Optional[str]</code> <p>provide a short explanation why this function is deprecated. Generates 'because {reason}'</p> <code>None</code> <code>alternative</code> <code>Optional[str]</code> <p>provides an alternative function/parameters to be used. Generates 'Use {alternative} as an alternative'</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function.</p>"},{"location":"api/decorators/#egse.decorators.dynamic_interface","title":"dynamic_interface","text":"<pre><code>dynamic_interface(func)\n</code></pre> <p>Adds a static variable <code>__dynamic_interface</code> to a method.</p> <p>The intended use of this function is as a decorator for functions in an interface class.</p> <p>The static variable is currently used by the Proxy class to check if a method is meant to be overridden dynamically. The idea behind this is to loosen the contract of an abstract base class (ABC) into an interface. For an ABC, the abstract methods must be implemented at construction/initialization. This is not possible for the Proxy subclasses as they load their commands (i.e. methods) from the control server, and the method will be added to the Proxy interface after loading. Nevertheless, we like the interface already defined for auto-completion during development or interactive use.</p> <p>When a Proxy subclass that implements an interface with methods decorated by the <code>@dynamic_interface</code> does overwrite one or more of the decorated methods statically, these methods will not be dynamically overwritten when loading the interface from the control server. A warning will be logged instead.</p>"},{"location":"api/decorators/#egse.decorators.execution_count","title":"execution_count","text":"<pre><code>execution_count(func)\n</code></pre> <p>Counts the number of times the function has been executed.</p>"},{"location":"api/decorators/#egse.decorators.implements_protocol","title":"implements_protocol","text":"<pre><code>implements_protocol(protocol)\n</code></pre> <p>Decorator to verify and document protocol compliance at class definition time.</p> Usage <p>@implements_protocol(AsyncRegistryBackend) class MyBackend:     ...</p>"},{"location":"api/decorators/#egse.decorators.profile","title":"profile","text":"<pre><code>profile(func)\n</code></pre> <p>Prints the function signature and return value to stdout.</p> <p>This function checks the <code>Settings.profiling()</code> value and only prints out profiling information if this returns True.</p> <p>Profiling can be activated with <code>Settings.set_profiling(True)</code>.</p>"},{"location":"api/decorators/#egse.decorators.profile_func","title":"profile_func","text":"<pre><code>profile_func(\n    output_file=None,\n    sort_by=\"cumulative\",\n    lines_to_print=None,\n    strip_dirs=False,\n)\n</code></pre> <p>A time profiler decorator.</p> <p>Parameters:</p> Name Type Description Default <code>output_file</code> <code>str</code> <p>str or None. Default is None Path of the output file. If only name of the file is given, it's saved in the current directory. If it's None, the name of the decorated function is used.</p> <code>None</code> <code>sort_by</code> <code>str</code> <p>str or SortKey enum or tuple/list of str/SortKey enum Sorting criteria for the Stats object. For a list of valid string and SortKey refer to: https://docs.python.org/3/library/profile.html#pstats.Stats.sort_stats</p> <code>'cumulative'</code> <code>lines_to_print</code> <code>int</code> <p>int or None Number of lines to print. Default (None) is for all the lines. This is useful in reducing the size of the printout, especially that sorting by 'cumulative', the time consuming operations are printed toward the top of the file.</p> <code>None</code> <code>strip_dirs</code> <code>bool</code> <p>bool Whether to remove the leading path info from file names. This is also useful in reducing the size of the printout</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Profile of the decorated function</p> Note <p>This code was taken from this gist: a profile decorator.</p> <p>Inspired by and modified the profile decorator of Giampaolo Rodola: profile decorato.</p>"},{"location":"api/decorators/#egse.decorators.query_command","title":"query_command","text":"<pre><code>query_command(func)\n</code></pre> <p>Adds a static variable <code>__query_command</code> to a method.</p>"},{"location":"api/decorators/#egse.decorators.read_command","title":"read_command","text":"<pre><code>read_command(func)\n</code></pre> <p>Adds a static variable <code>__read_command</code> to a method.</p>"},{"location":"api/decorators/#egse.decorators.retry","title":"retry","text":"<pre><code>retry(times=3, wait=10.0, exceptions=None)\n</code></pre> <p>Decorator that retries a function multiple times with a delay between attempts.</p> <p>This decorator can be applied to a function to handle specified exceptions by retrying the function execution. It will make up to 'times' attempts with a waiting period of 'wait' seconds between each attempt. Any exception from the list provided in the <code>exceptions</code> argument will be ignored for the given <code>times</code>.</p> <p>If after times attempts still an exception is raised, it will be passed through the calling function, otherwise the functions return value will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>times</code> <code>int</code> <p>The number of retry attempts. Defaults to 3.</p> <code>3</code> <code>wait</code> <code>float</code> <p>The waiting period between retries in seconds. Defaults to 10.0.</p> <code>10.0</code> <code>exceptions</code> <code>List[Exception] or None</code> <p>List of exception types to catch and retry. Defaults to None, which catches all exceptions.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>The decorated function.</p> Example <p>Apply the retry decorator to a function with specific retry settings:</p> <pre><code>@retry(times=5, wait=15.0, exceptions=[ConnectionError, TimeoutError])\ndef my_function():\n    # Function logic here\n</code></pre> Note <p>The decorator catches specified exceptions and retries the function, logging information about each retry attempt.</p>"},{"location":"api/decorators/#egse.decorators.retry_with_exponential_backoff","title":"retry_with_exponential_backoff","text":"<pre><code>retry_with_exponential_backoff(\n    max_attempts=5,\n    initial_wait=1.0,\n    backoff_factor=2,\n    exceptions=None,\n)\n</code></pre> <p>Decorator for retrying a function with exponential backoff.</p> <p>This decorator can be applied to a function to handle specified exceptions by retrying the function execution. It will make up to 'max_attempts' attempts with a waiting period that grows exponentially between each attempt (dependent on the backoff_factor). Any exception from the list provided in the <code>exceptions</code> argument will be ignored for the given <code>max_attempts</code>.</p> <p>If after all attempts still an exception is raised, it will be passed through the calling function, otherwise the functions return value will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>max_attempts</code> <code>int</code> <p>The maximum number of attempts to make.</p> <code>5</code> <code>initial_wait</code> <code>float</code> <p>The initial waiting time in seconds before retrying after the first failure.</p> <code>1.0</code> <code>backoff_factor</code> <code>int</code> <p>The factor by which the wait time increases after each failure.</p> <code>2</code> <code>exceptions</code> <code>List</code> <p>list of exceptions to ignore, if None all exceptions will be ignored <code>max_attempts</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The response from the executed function.</p>"},{"location":"api/decorators/#egse.decorators.singleton","title":"singleton","text":"<pre><code>singleton(cls)\n</code></pre> <p>Use class as a singleton.</p> from <p>Decorator library: Signleton</p>"},{"location":"api/decorators/#egse.decorators.spy_on_attr_change","title":"spy_on_attr_change","text":"<pre><code>spy_on_attr_change(obj, obj_name=None)\n</code></pre> <p>Tweak an object to show attributes changing. The changes are reported as WARNING log messages in the <code>egse.spy</code> logger.</p> <p>Note this is not a decorator, but a function that changes the class of an object.</p> <p>Note that this function is a debugging aid and should not be used in production code!</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>any object that you want to monitor</p> required <code>obj_name</code> <code>str</code> <p>the variable name of the object that was given in the code, if None than the class name will be printed.</p> <code>None</code> Example <pre><code>class X:\n   pass\n\nx = X()\nspy_on_attr_change(x, obj_name=\"x\")\nx.a = 5\n</code></pre> From <p>Adding a dunder to an object</p>"},{"location":"api/decorators/#egse.decorators.static_vars","title":"static_vars","text":"<pre><code>static_vars(**kwargs)\n</code></pre> <p>Define static variables in a function.</p> <p>The static variable can be accessed with . inside the function body. Example <pre><code>@static_vars(count=0)\ndef special_count():\n    return special_count.count += 2\n</code></pre>"},{"location":"api/decorators/#egse.decorators.time_it","title":"time_it","text":"<pre><code>time_it(count=1000, precision=4)\n</code></pre> <p>Print the runtime of the decorated function.</p> <p>This is a simple replacement for the builtin <code>timeit</code> function. The purpose is to simplify calling a function with some parameters.</p> <p>The intended way to call this is as a function:</p> <pre><code>value = function(args)\n\nvalue = time_it(10_000)(function)(args)\n</code></pre> <p>The <code>time_it</code> function can be called as a decorator in which case it will always call the function <code>count</code> times which is probably not what you want.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>the number of executions [default=1000].</p> <code>1000</code> <code>precision</code> <code>int</code> <p>the number of significant digits [default=4]</p> <code>4</code> <p>Returns:</p> Name Type Description <code>value</code> <code>Callable</code> <p>the return value of the last function execution.</p> See also <p>the <code>Timer</code> context manager located in <code>egse.system</code>.</p> Usage <pre><code>@time_it(count=10000)\ndef function(args):\n    pass\n\ntime_it(10000)(function)(args)\n</code></pre>"},{"location":"api/decorators/#egse.decorators.timer","title":"timer","text":"<pre><code>timer(*, name='timer', level=INFO, precision=4)\n</code></pre> <p>Print the runtime of the decorated function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>a name for the Timer, will be printed in the logging message</p> <code>'timer'</code> <code>level</code> <code>int</code> <p>the logging level for the time message [default=INFO]</p> <code>INFO</code> <code>precision</code> <code>int</code> <p>the number of decimals for the time [default=3 (ms)]</p> <code>4</code>"},{"location":"api/decorators/#egse.decorators.to_be_implemented","title":"to_be_implemented","text":"<pre><code>to_be_implemented(func)\n</code></pre> <p>Print a warning message that this function/method has to be implemented.</p>"},{"location":"api/decorators/#egse.decorators.transaction_command","title":"transaction_command","text":"<pre><code>transaction_command(func)\n</code></pre> <p>Adds a static variable <code>__transaction_command</code> to a method.</p>"},{"location":"api/decorators/#egse.decorators.write_command","title":"write_command","text":"<pre><code>write_command(func)\n</code></pre> <p>Adds a static variable <code>__write_command</code> to a method.</p>"},{"location":"api/device/","title":"egse.device","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/device/#egse.device","title":"egse.device","text":"<p>This module defines the generic interfaces to connect devices.</p> <p>Classes:</p> Name Description <code>AsyncDeviceTransport</code> <p>Base class for the asynchronous device transport layer.</p> <code>DeviceConnectionError</code> <p>A generic error for all connection type of problems.</p> <code>DeviceConnectionInterface</code> <p>Generic connection interface for all Device classes and Controllers.</p> <code>DeviceConnectionObservable</code> <p>An observable for the connection state of a device. An observer can be added with the</p> <code>DeviceConnectionObserver</code> <p>An observer for the connection state of a device. Add the subclass of this class to</p> <code>DeviceConnectionState</code> <p>Defines connection states for device connections.</p> <code>DeviceControllerError</code> <p>Any error that is returned by the device controller.</p> <code>DeviceError</code> <p>Generic device error.</p> <code>DeviceFactoryInterface</code> <p>Base class for creating a device factory class to access devices.</p> <code>DeviceInterface</code> <p>Generic interface for all device classes.</p> <code>DeviceInterfaceError</code> <p>Any error that is returned or raised by the higher level interface to the device.</p> <code>DeviceTimeoutError</code> <p>A timeout on a device that we could not handle.</p> <code>DeviceTransport</code> <p>Base class for the device transport layer.</p>"},{"location":"api/device/#egse.device.AsyncDeviceTransport","title":"AsyncDeviceTransport","text":"<p>Base class for the asynchronous device transport layer.</p> <p>Methods:</p> Name Description <code>query</code> <p>Send a query to the device and wait for the response.</p> <code>read</code> <p>Reads a bytes object back from the instrument and returns it unaltered.</p> <code>trans</code> <p>Send a single command to the device controller and block until a response from the</p> <code>write</code> <p>Sends a complete command to the device, handle line termination, and write timeouts.</p>"},{"location":"api/device/#egse.device.AsyncDeviceTransport.query","title":"query  <code>async</code>","text":"<pre><code>query(command)\n</code></pre> <p>Send a query to the device and wait for the response.</p> <p>This <code>query</code> method is an alias for the <code>trans</code> command. For some commands it might be more intuitive to use the <code>query</code> instead of the <code>trans</code>action. No need to override this method as it delegates to <code>trans</code>.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>the query command.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The response to the query.</p>"},{"location":"api/device/#egse.device.AsyncDeviceTransport.read","title":"read  <code>async</code>","text":"<pre><code>read()\n</code></pre> <p>Reads a bytes object back from the instrument and returns it unaltered.</p>"},{"location":"api/device/#egse.device.AsyncDeviceTransport.trans","title":"trans  <code>async</code>","text":"<pre><code>trans(command)\n</code></pre> <p>Send a single command to the device controller and block until a response from the controller.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>is the command to be sent to the instrument</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Either a string returned by the controller (on success), or an error message (on failure).</p> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>when there was an I/O problem during communication with the controller.</p> <code>DeviceTimeoutError</code> <p>when there was a timeout in either sending the command or receiving the response.</p>"},{"location":"api/device/#egse.device.AsyncDeviceTransport.write","title":"write  <code>async</code>","text":"<pre><code>write(command)\n</code></pre> <p>Sends a complete command to the device, handle line termination, and write timeouts.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>the command to be sent to the instrument.</p> required"},{"location":"api/device/#egse.device.DeviceConnectionError","title":"DeviceConnectionError","text":"<pre><code>DeviceConnectionError(device_name, message)\n</code></pre> <p>               Bases: <code>DeviceError</code></p> <p>A generic error for all connection type of problems.</p> <p>Parameters:</p> Name Type Description Default <code>device_name</code> <code>str</code> <p>The name of the device</p> required <code>message</code> <code>str</code> <p>a clear and brief description of the problem</p> required"},{"location":"api/device/#egse.device.DeviceConnectionInterface","title":"DeviceConnectionInterface","text":"<pre><code>DeviceConnectionInterface()\n</code></pre> <p>               Bases: <code>DeviceConnectionObservable</code></p> <p>Generic connection interface for all Device classes and Controllers.</p> <p>This interface shall be implemented in the Controllers that directly connect to the hardware, but also in the simulators to guarantee an identical interface as the controllers.</p> <p>This interface will be implemented in the Proxy classes through the YAML definitions. Therefore, the YAML files shall define at least the following commands: <code>connect</code>, <code>disconnect</code>, <code>reconnect</code>, <code>is_connected</code>.</p> <p>Methods:</p> Name Description <code>add_observer</code> <p>Add an observer.</p> <code>connect</code> <p>Connect to the device controller.</p> <code>disconnect</code> <p>Disconnect from the device controller.</p> <code>get_observers</code> <p>Returns a copy of the registered observers.</p> <code>is_connected</code> <p>Check if the device is connected.</p> <code>notify_observers</code> <p>Notify the observers of a possible state change.</p> <code>reconnect</code> <p>Reconnect the device controller.</p>"},{"location":"api/device/#egse.device.DeviceConnectionInterface.add_observer","title":"add_observer","text":"<pre><code>add_observer(observer)\n</code></pre> <p>Add an observer.</p>"},{"location":"api/device/#egse.device.DeviceConnectionInterface.connect","title":"connect","text":"<pre><code>connect()\n</code></pre> <p>Connect to the device controller.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>when the connection can not be opened.</p>"},{"location":"api/device/#egse.device.DeviceConnectionInterface.disconnect","title":"disconnect","text":"<pre><code>disconnect()\n</code></pre> <p>Disconnect from the device controller.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>when the connection can not be closed.</p>"},{"location":"api/device/#egse.device.DeviceConnectionInterface.get_observers","title":"get_observers","text":"<pre><code>get_observers()\n</code></pre> <p>Returns a copy of the registered observers.</p>"},{"location":"api/device/#egse.device.DeviceConnectionInterface.is_connected","title":"is_connected","text":"<pre><code>is_connected()\n</code></pre> <p>Check if the device is connected.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the device is connected and responds to a command, False otherwise.</p>"},{"location":"api/device/#egse.device.DeviceConnectionInterface.notify_observers","title":"notify_observers","text":"<pre><code>notify_observers(state)\n</code></pre> <p>Notify the observers of a possible state change.</p>"},{"location":"api/device/#egse.device.DeviceConnectionInterface.reconnect","title":"reconnect","text":"<pre><code>reconnect()\n</code></pre> <p>Reconnect the device controller.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>when the device can not  be reconnected for some reason.</p>"},{"location":"api/device/#egse.device.DeviceConnectionObservable","title":"DeviceConnectionObservable","text":"<pre><code>DeviceConnectionObservable()\n</code></pre> <p>An observable for the connection state of a device. An observer can be added with the <code>add_observer()</code> method. Whenever the connection state of the device changes, the subclass is responsible for notifying the observers by calling the <code>notify_observers()</code> method with the correct state.</p> <p>Methods:</p> Name Description <code>add_observer</code> <p>Add an observer.</p> <code>get_observers</code> <p>Returns a copy of the registered observers.</p> <code>notify_observers</code> <p>Notify the observers of a possible state change.</p>"},{"location":"api/device/#egse.device.DeviceConnectionObservable.add_observer","title":"add_observer","text":"<pre><code>add_observer(observer)\n</code></pre> <p>Add an observer.</p>"},{"location":"api/device/#egse.device.DeviceConnectionObservable.get_observers","title":"get_observers","text":"<pre><code>get_observers()\n</code></pre> <p>Returns a copy of the registered observers.</p>"},{"location":"api/device/#egse.device.DeviceConnectionObservable.notify_observers","title":"notify_observers","text":"<pre><code>notify_observers(state)\n</code></pre> <p>Notify the observers of a possible state change.</p>"},{"location":"api/device/#egse.device.DeviceConnectionObserver","title":"DeviceConnectionObserver","text":"<pre><code>DeviceConnectionObserver()\n</code></pre> <p>An observer for the connection state of a device. Add the subclass of this class to the class that inherits from DeviceConnectionObservable. The observable will notify an update of its state by calling the <code>update_connection_state()</code> method.</p> <p>Methods:</p> Name Description <code>update_connection_state</code> <p>Updates the connection state with the given state.</p> <p>Attributes:</p> Name Type Description <code>state</code> <p>Returns the current connection state of the device.</p>"},{"location":"api/device/#egse.device.DeviceConnectionObserver.state","title":"state  <code>property</code>","text":"<pre><code>state\n</code></pre> <p>Returns the current connection state of the device.</p>"},{"location":"api/device/#egse.device.DeviceConnectionObserver.update_connection_state","title":"update_connection_state","text":"<pre><code>update_connection_state(state)\n</code></pre> <p>Updates the connection state with the given state.</p>"},{"location":"api/device/#egse.device.DeviceConnectionState","title":"DeviceConnectionState","text":"<p>               Bases: <code>IntEnum</code></p> <p>Defines connection states for device connections.</p> <p>Attributes:</p> Name Type Description <code>DEVICE_CONNECTED</code> <p>The device is connected.</p> <code>DEVICE_NOT_CONNECTED</code> <p>The device is not connected.</p>"},{"location":"api/device/#egse.device.DeviceConnectionState.DEVICE_CONNECTED","title":"DEVICE_CONNECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEVICE_CONNECTED = 1\n</code></pre> <p>The device is connected.</p>"},{"location":"api/device/#egse.device.DeviceConnectionState.DEVICE_NOT_CONNECTED","title":"DEVICE_NOT_CONNECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEVICE_NOT_CONNECTED = 2\n</code></pre> <p>The device is not connected.</p>"},{"location":"api/device/#egse.device.DeviceControllerError","title":"DeviceControllerError","text":"<pre><code>DeviceControllerError(device_name, message)\n</code></pre> <p>               Bases: <code>DeviceError</code></p> <p>Any error that is returned by the device controller.</p> <p>When the device controller is connected through an e.g. Ethernet interface, it will usually return error codes as part of the response to a command. When such an error is returned, raise this <code>DeviceControllerError</code> instead of passing the return code (response) to the caller.</p> <p>Parameters:</p> Name Type Description Default <code>device_name</code> <code>str</code> <p>The name of the device</p> required <code>message</code> <code>str</code> <p>a clear and brief description of the problem</p> required"},{"location":"api/device/#egse.device.DeviceError","title":"DeviceError","text":"<pre><code>DeviceError(device_name, message)\n</code></pre> <p>               Bases: <code>Error</code></p> <p>Generic device error.</p> <p>Parameters:</p> Name Type Description Default <code>device_name</code> <code>str</code> <p>The name of the device</p> required <code>message</code> <code>str</code> <p>a clear and brief description of the problem</p> required"},{"location":"api/device/#egse.device.DeviceFactoryInterface","title":"DeviceFactoryInterface","text":"<p>Base class for creating a device factory class to access devices.</p> <p>This interface defines one interface method that shall be implemented by the Factory: <pre><code>create(device_name: str, *, device_id: str, **_ignored)\n</code></pre></p> <p>Methods:</p> Name Description <code>create</code> <p>Create and return a device class that implements the expected device interface.</p>"},{"location":"api/device/#egse.device.DeviceFactoryInterface.create","title":"create","text":"<pre><code>create(device_name, *, device_id, **_ignored)\n</code></pre> <p>Create and return a device class that implements the expected device interface. The <code>device_name</code> and <code>device_id</code> can be useful for identifying the specific device.</p> <p>Additional keyword arguments can be passed to the device factory in order to forward them to the device constructor, but they will usually be ignored.</p>"},{"location":"api/device/#egse.device.DeviceInterface","title":"DeviceInterface","text":"<pre><code>DeviceInterface()\n</code></pre> <p>               Bases: <code>DeviceConnectionInterface</code></p> <p>Generic interface for all device classes.</p> <p>Methods:</p> Name Description <code>add_observer</code> <p>Add an observer.</p> <code>connect</code> <p>Connect to the device controller.</p> <code>disconnect</code> <p>Disconnect from the device controller.</p> <code>get_observers</code> <p>Returns a copy of the registered observers.</p> <code>is_connected</code> <p>Check if the device is connected.</p> <code>is_simulator</code> <p>Checks whether the device is a simulator rather than a real hardware controller.</p> <code>notify_observers</code> <p>Notify the observers of a possible state change.</p> <code>reconnect</code> <p>Reconnect the device controller.</p>"},{"location":"api/device/#egse.device.DeviceInterface.add_observer","title":"add_observer","text":"<pre><code>add_observer(observer)\n</code></pre> <p>Add an observer.</p>"},{"location":"api/device/#egse.device.DeviceInterface.connect","title":"connect","text":"<pre><code>connect()\n</code></pre> <p>Connect to the device controller.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>when the connection can not be opened.</p>"},{"location":"api/device/#egse.device.DeviceInterface.disconnect","title":"disconnect","text":"<pre><code>disconnect()\n</code></pre> <p>Disconnect from the device controller.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>when the connection can not be closed.</p>"},{"location":"api/device/#egse.device.DeviceInterface.get_observers","title":"get_observers","text":"<pre><code>get_observers()\n</code></pre> <p>Returns a copy of the registered observers.</p>"},{"location":"api/device/#egse.device.DeviceInterface.is_connected","title":"is_connected","text":"<pre><code>is_connected()\n</code></pre> <p>Check if the device is connected.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the device is connected and responds to a command, False otherwise.</p>"},{"location":"api/device/#egse.device.DeviceInterface.is_simulator","title":"is_simulator","text":"<pre><code>is_simulator()\n</code></pre> <p>Checks whether the device is a simulator rather than a real hardware controller.</p> <p>This can be useful for testing purposes or when doing actual movement simulations.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the Device is a Simulator; False if the Device is connected to real hardware.</p>"},{"location":"api/device/#egse.device.DeviceInterface.notify_observers","title":"notify_observers","text":"<pre><code>notify_observers(state)\n</code></pre> <p>Notify the observers of a possible state change.</p>"},{"location":"api/device/#egse.device.DeviceInterface.reconnect","title":"reconnect","text":"<pre><code>reconnect()\n</code></pre> <p>Reconnect the device controller.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>when the device can not  be reconnected for some reason.</p>"},{"location":"api/device/#egse.device.DeviceInterfaceError","title":"DeviceInterfaceError","text":"<pre><code>DeviceInterfaceError(device_name, message)\n</code></pre> <p>               Bases: <code>DeviceError</code></p> <p>Any error that is returned or raised by the higher level interface to the device.</p> <p>Parameters:</p> Name Type Description Default <code>device_name</code> <code>str</code> <p>The name of the device</p> required <code>message</code> <code>str</code> <p>a clear and brief description of the problem</p> required"},{"location":"api/device/#egse.device.DeviceTimeoutError","title":"DeviceTimeoutError","text":"<pre><code>DeviceTimeoutError(device_name, message)\n</code></pre> <p>               Bases: <code>DeviceError</code></p> <p>A timeout on a device that we could not handle.</p> <p>Parameters:</p> Name Type Description Default <code>device_name</code> <code>str</code> <p>The name of the device</p> required <code>message</code> <code>str</code> <p>a clear and brief description of the problem</p> required"},{"location":"api/device/#egse.device.DeviceTransport","title":"DeviceTransport","text":"<p>Base class for the device transport layer.</p> <p>Methods:</p> Name Description <code>query</code> <p>Send a query to the device and wait for the response.</p> <code>read</code> <p>Reads a bytes object back from the instrument and returns it unaltered.</p> <code>trans</code> <p>Send a single command to the device controller and block until a response from the</p> <code>write</code> <p>Sends a complete command to the device, handle line termination, and write timeouts.</p>"},{"location":"api/device/#egse.device.DeviceTransport.query","title":"query","text":"<pre><code>query(command)\n</code></pre> <p>Send a query to the device and wait for the response.</p> <p>This <code>query</code> method is an alias for the <code>trans</code> command. For some commands it might be more intuitive to use the <code>query</code> instead of the <code>trans</code>action. No need to override this method as it delegates to <code>trans</code>.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>the query command.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The response to the query.</p>"},{"location":"api/device/#egse.device.DeviceTransport.read","title":"read","text":"<pre><code>read()\n</code></pre> <p>Reads a bytes object back from the instrument and returns it unaltered.</p>"},{"location":"api/device/#egse.device.DeviceTransport.trans","title":"trans","text":"<pre><code>trans(command)\n</code></pre> <p>Send a single command to the device controller and block until a response from the controller.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>is the command to be sent to the instrument</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Either a string returned by the controller (on success), or an error message (on failure).</p> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>when there was an I/O problem during communication with the controller.</p> <code>DeviceTimeoutError</code> <p>when there was a timeout in either sending the command or receiving the response.</p>"},{"location":"api/device/#egse.device.DeviceTransport.write","title":"write","text":"<pre><code>write(command)\n</code></pre> <p>Sends a complete command to the device, handle line termination, and write timeouts.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>the command to be sent to the instrument.</p> required"},{"location":"api/dicts/","title":"egse.dicts","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/dicts/#egse.dicts","title":"egse.dicts","text":"<p>This module provides convenience functions to inspect and compare dictionaries when debugging.</p> <p>Functions:</p> Name Description <code>flatten_dict</code> <p>Flatten the given dictionary concatenating the keys with a colon '<code>:</code>'.</p> <code>log_differences</code> <p>Takes two flattened dictionaries and compares them. This function only compares those</p> <code>log_key_differences</code> <p>Takes two dictionaries and compares the top-level keys. The differences are logged in a Rich Table at level=INFO.</p>"},{"location":"api/dicts/#egse.dicts.flatten_dict","title":"flatten_dict","text":"<pre><code>flatten_dict(source_dict)\n</code></pre> <p>Flatten the given dictionary concatenating the keys with a colon '<code>:</code>'.</p> <p>Parameters:</p> Name Type Description Default <code>source_dict</code> <code>dict</code> <p>the original dictionary that will be flattened</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A new flattened dictionary.</p> Example <pre><code>&gt;&gt;&gt; d = {\"A\": 1, \"B\": {\"E\": {\"F\": 2}}, \"C\": {\"D\": 3}}\n&gt;&gt;&gt; flatten_dict(d)\n{'A': 1, 'B:E:F': 2, 'C:D': 3}\n\n&gt;&gt;&gt; d = {\"A\": 'a', \"B\": {\"C\": {\"D\": 'd', \"E\": 'e'}, \"F\": 'f'}}\n&gt;&gt;&gt; flatten_dict(d)\n{'A': 'a', 'B:C:D': 'd', 'B:C:E': 'e', 'B:F': 'f'}\n</code></pre>"},{"location":"api/dicts/#egse.dicts.log_differences","title":"log_differences","text":"<pre><code>log_differences(dict_1, dict_2)\n</code></pre> <p>Takes two flattened dictionaries and compares them. This function only compares those keys that are common to both dictionaries. The key-value pairs that are unique to one of the dictionaries are ignored. To inspect if there are keys unique to one dictionary, use the log_key_differences() function.</p> <p>The differences are logged in a Rich Table at level=INFO.</p> Example <pre><code>&gt;&gt;&gt; d1 = { \"A\": 1, \"B\": 2, \"C\": 3 }\n&gt;&gt;&gt; d2 = { \"A\": 1, \"B\": 5, \"C\": 3 }\n&gt;&gt;&gt; log_differences(d1, d2)\n\n2025-02-28 09:20:51,639:         MainProcess:    INFO:   37:__main__            :Value Differences\n\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Name \u2503 old value \u2503 new value \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 B    \u2502 2         \u2502 5         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api/dicts/#egse.dicts.log_key_differences","title":"log_key_differences","text":"<pre><code>log_key_differences(dict_1, dict_2)\n</code></pre> <p>Takes two dictionaries and compares the top-level keys. The differences are logged in a Rich Table at level=INFO. Keys that are present on both dictionaries are not logged.</p> Example <pre><code>&gt;&gt;&gt; d1 = {\"A\": 1, \"B\": 2, \"C\": 3}\n&gt;&gt;&gt; d2 = {\"B\": 2, \"C\": 3, \"D\": 4}\n&gt;&gt;&gt; log_key_differences(d1, d2)\n2025-02-28 09:08:29,916:         MainProcess:    INFO:   60:__main__            :Key differences\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Dictionary 1 \u2503 Dictionary 2 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 A            \u2502              \u2502\n\u2502              \u2502 D            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api/dummy/","title":"egse.dummy","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/dummy/#egse.dummy","title":"egse.dummy","text":"<p>This module provides a dummy implementation for classes of the commanding chain.</p> <p>Start the control server with: <pre><code>py -m egse.dummy start-cs\n</code></pre> and stop the server with: <pre><code>py -m egse.dummy stop-cs\n</code></pre> Commands that can be used with the proxy:</p> <ul> <li>info \u2013 returns an info message from the dummy device, e.g. \"Dummy Device &lt;version&gt;\"</li> <li>get_value \u2013 returns a random float between 0.0 and 1.0</li> <li>division \u2013 returns the result of the division between arguments 'a' and 'b'.     This can be used also to induce a ZeroDivisionError that should return a Failure     object.</li> </ul> <p>The device simulator can be started with: <pre><code>py -m egse.dummy start-dev\n</code></pre></p> <p>Classes:</p> Name Description <code>DummyCommand</code> <p>The Command class for the dummy device.</p> <code>DummyControlServer</code> <p>DummyControlServer - Command and monitor dummy device controllers.</p> <code>DummyController</code> <p>The controller class for the dummy device.</p> <code>DummyDeviceEthernetInterface</code> <p>Defines the low-level interface to the Dummy Device.</p> <code>DummyInterface</code> <p>The interface for the dummy device.</p> <code>DummyProtocol</code> <p>The protocol class for the dummy device.</p> <code>DummyProxy</code> <p>The Proxy class for the dummy device.</p> <p>Functions:</p> Name Description <code>is_dummy_cs_active</code> <p>Returns True if the dummy device control server is active.</p> <code>start_cs</code> <p>Start the dummy control server on localhost.</p> <code>start_dev</code> <p>Start the dummy device simulator.</p> <code>stop_cs</code> <p>Send a quit service command to the dummy control server.</p> <p>Attributes:</p> Name Type Description <code>CONNECT_TIMEOUT</code> <p>The maximum time in seconds to wait for establishing a socket connect.</p> <code>DEV_HOST</code> <p>The hostname or IP address of the Dummy Device.</p> <code>DEV_NAME</code> <p>The name used for theDummy Device, this is used in Exceptions and in the info command.</p> <code>DEV_PORT</code> <p>The port number for the Dummy Device.</p> <code>READ_TIMEOUT</code> <p>The maximum time in seconds to wait for a socket receive command.</p> <code>WRITE_TIMEOUT</code> <p>The maximum time in seconds to wait for a socket send command.</p>"},{"location":"api/dummy/#egse.dummy.CONNECT_TIMEOUT","title":"CONNECT_TIMEOUT  <code>module-attribute</code>","text":"<pre><code>CONNECT_TIMEOUT = 3.0\n</code></pre> <p>The maximum time in seconds to wait for establishing a socket connect.</p>"},{"location":"api/dummy/#egse.dummy.DEV_HOST","title":"DEV_HOST  <code>module-attribute</code>","text":"<pre><code>DEV_HOST = 'localhost'\n</code></pre> <p>The hostname or IP address of the Dummy Device.</p>"},{"location":"api/dummy/#egse.dummy.DEV_NAME","title":"DEV_NAME  <code>module-attribute</code>","text":"<pre><code>DEV_NAME = 'Dummy Device'\n</code></pre> <p>The name used for theDummy Device, this is used in Exceptions and in the info command.</p>"},{"location":"api/dummy/#egse.dummy.DEV_PORT","title":"DEV_PORT  <code>module-attribute</code>","text":"<pre><code>DEV_PORT = 4446\n</code></pre> <p>The port number for the Dummy Device.</p>"},{"location":"api/dummy/#egse.dummy.READ_TIMEOUT","title":"READ_TIMEOUT  <code>module-attribute</code>","text":"<pre><code>READ_TIMEOUT = 10.0\n</code></pre> <p>The maximum time in seconds to wait for a socket receive command.</p>"},{"location":"api/dummy/#egse.dummy.WRITE_TIMEOUT","title":"WRITE_TIMEOUT  <code>module-attribute</code>","text":"<pre><code>WRITE_TIMEOUT = 1.0\n</code></pre> <p>The maximum time in seconds to wait for a socket send command.</p>"},{"location":"api/dummy/#egse.dummy.DummyCommand","title":"DummyCommand","text":"<pre><code>DummyCommand(\n    name,\n    cmd,\n    response=None,\n    wait=None,\n    check=None,\n    description=None,\n    device_method=None,\n)\n</code></pre> <p>               Bases: <code>ClientServerCommand</code></p> <p>The Command class for the dummy device.</p> <p>Methods:</p> Name Description <code>client_call</code> <p>This method is called at the client side. It is used by the Proxy</p> <code>server_call</code> <p>This method is called at the server side. It is used by the CommandProtocol class in the</p>"},{"location":"api/dummy/#egse.dummy.DummyCommand.client_call","title":"client_call","text":"<pre><code>client_call(other, *args, **kwargs)\n</code></pre> <p>This method is called at the client side. It is used by the Proxy as a generic command to send a command execution to the server.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>type</code> <p>a subclass of the Proxy class</p> required <code>args</code> <code>tuple</code> <p>arguments that will be passed on to this command when executed</p> <code>()</code> <code>kwargs</code> <code>dict</code> <p>keyword arguments that will be passed on to this command when executed</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>the response that is returned by calling the command (at the server side).</p>"},{"location":"api/dummy/#egse.dummy.DummyCommand.server_call","title":"server_call","text":"<pre><code>server_call(other, *args, **kwargs)\n</code></pre> <p>This method is called at the server side. It is used by the CommandProtocol class in the <code>execute</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>CommandProtocol</code> <p>a subclass of the CommandProtocol</p> required <code>args</code> <code>tuple</code> <p>arguments are passed on to the response method</p> <code>()</code> <code>kwargs</code> <code>dict</code> <p>keyword arguments are passed on to the response method</p> <code>{}</code> <p>Returns:</p> Type Description <code>int</code> <p>0 on success and -1 on failure.</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer","title":"DummyControlServer","text":"<pre><code>DummyControlServer()\n</code></pre> <p>               Bases: <code>ControlServer</code></p> <p>DummyControlServer - Command and monitor dummy device controllers.</p> <p>The sever binds to the following ZeroMQ sockets:</p> <ul> <li> <p>a REQ-REP socket that can be used as a command server. Any client can connect and   send a command to the dummy device controller.</p> </li> <li> <p>a PUB-SUP socket that serves as a monitoring server. It will send out status   information to all the connected clients every DELAY seconds.</p> </li> </ul> <p>Methods:</p> Name Description <code>before_serve</code> <p>This method needs to be overridden by the subclass if certain actions need to be executed before the control</p> <code>get_average_execution_times</code> <p>Returns the average execution times of all functions that have been monitored by this process.</p> <code>get_ip_address</code> <p>Returns the IP address of the current host.</p> <code>get_process_status</code> <p>Returns the process status of the Control Server.</p> <code>handle_scheduled_tasks</code> <p>Executes or reschedules tasks in the <code>serve()</code> event loop.</p> <code>is_storage_manager_active</code> <p>Checks if the Storage Manager is active.</p> <code>notify_listeners</code> <p>Notifies registered listeners about an event.</p> <code>propagate_metrics</code> <p>Propagates the given housekeeping information to the metrics database.</p> <code>quit</code> <p>Interrupts the Control Server.</p> <code>register_as_listener</code> <p>Registers a listener with the specified proxy.</p> <code>register_to_storage_manager</code> <p>Registers this Control Server to the Storage Manager.</p> <code>schedule_task</code> <p>Schedules a task to run in the control server event loop.</p> <code>serve</code> <p>Activation of the Control Server.</p> <code>set_hk_delay</code> <p>Sets the delay time for housekeeping.</p> <code>set_logging_level</code> <p>Sets the logging level to the given level.</p> <code>set_mon_delay</code> <p>Sets the delay time for monitoring.</p> <code>set_scheduled_task_delay</code> <p>Sets the delay time between successive executions of scheduled tasks.</p> <code>store_housekeeping_information</code> <p>Sends housekeeping information to the Storage Manager.</p> <code>unregister_as_listener</code> <p>Removes a registered listener from the specified proxy.</p> <code>unregister_from_storage_manager</code> <p>Unregisters the Control Server from the Storage Manager.</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.before_serve","title":"before_serve","text":"<pre><code>before_serve()\n</code></pre> <p>This method needs to be overridden by the subclass if certain actions need to be executed before the control server is activated.</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.get_average_execution_times","title":"get_average_execution_times","text":"<pre><code>get_average_execution_times()\n</code></pre> <p>Returns the average execution times of all functions that have been monitored by this process.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the average execution times of all functions that have been monitored by this process. The dictionary keys are the function names, and the values are the average execution times in ms.</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.get_ip_address","title":"get_ip_address","text":"<pre><code>get_ip_address()\n</code></pre> <p>Returns the IP address of the current host.</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.get_process_status","title":"get_process_status","text":"<pre><code>get_process_status()\n</code></pre> <p>Returns the process status of the Control Server.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the process status of the Control Server.</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.handle_scheduled_tasks","title":"handle_scheduled_tasks","text":"<pre><code>handle_scheduled_tasks()\n</code></pre> <p>Executes or reschedules tasks in the <code>serve()</code> event loop.</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.is_storage_manager_active","title":"is_storage_manager_active","text":"<pre><code>is_storage_manager_active()\n</code></pre> <p>Checks if the Storage Manager is active.</p> <p>This method has to be implemented by the subclass if you need to store information.</p> <p>Note: You might want to set a specific timeout when checking for the Storage Manager.</p> <p>Note: If this method returns True, the following methods shall also be implemented by the subclass:</p> <ul> <li>register_to_storage_manager()</li> <li>unregister_from_storage_manager()</li> <li>store_housekeeping_information()</li> </ul> <p>Returns:</p> Type Description <code>bool</code> <p>True if the Storage Manager is active; False otherwise.</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.notify_listeners","title":"notify_listeners","text":"<pre><code>notify_listeners(event_id=0, context=None)\n</code></pre> <p>Notifies registered listeners about an event.</p> <p>This function creates an Event object with the provided <code>event_id</code> and <code>context</code> and notifies all registered listeners with the created event.</p> <p>Parameters:</p> Name Type Description Default <code>event_id</code> <code>int</code> <p>The identifier for the event. Defaults to 0.</p> <code>0</code> <code>context</code> <code>dict</code> <p>Additional context information associated with the event. Defaults to None.</p> <code>None</code> Note <p>The notification is performed by the <code>notify_listeners</code> method of the <code>listeners</code> object associated with this instance. The notification is executed in a daemon thread to avoid blocking the commanding chain.</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.propagate_metrics","title":"propagate_metrics","text":"<pre><code>propagate_metrics(hk)\n</code></pre> <p>Propagates the given housekeeping information to the metrics database.</p> <p>Nothing will be written to the metrics database if the <code>hk</code> dict doesn't contain any metrics (except for the timestamp).</p> <p>Parameters:</p> Name Type Description Default <code>hk</code> <code>dict</code> <p>Dictionary containing parameter name and value of all device housekeeping. There is also        a timestamp that represents the date/time when the HK was received from the device.</p> required"},{"location":"api/dummy/#egse.dummy.DummyControlServer.quit","title":"quit","text":"<pre><code>quit()\n</code></pre> <p>Interrupts the Control Server.</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.register_as_listener","title":"register_as_listener","text":"<pre><code>register_as_listener(proxy, listener)\n</code></pre> <p>Registers a listener with the specified proxy.</p> <p>This function attempts to add the provided listener to the specified proxy. It employs a retry mechanism to handle potential ConnectionError exceptions, making up to 5 attempts to add the listener.</p> <p>Parameters:</p> Name Type Description Default <code>proxy</code> <code>Type</code> <p>A callable object representing the proxy to which the listener will be added.</p> required <code>listener</code> <code>dict</code> <p>The listener to be registered. Should be a dictionary containing listener details.</p> required <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the connection to the proxy encounters issues even after multiple retry attempts.</p> Note <p>The function runs in a separate daemon thread to avoid blocking the main thread.</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.register_to_storage_manager","title":"register_to_storage_manager","text":"<pre><code>register_to_storage_manager()\n</code></pre> <p>Registers this Control Server to the Storage Manager.</p> <p>By doing so, the housekeeping information of the device will be sent to the Storage Manager, which will store the information in a dedicated CSV file.</p> <p>This method has to be overwritten by the subclasses if they have housekeeping information that must be stored.</p> <p>Subclasses need to overwrite this method if they have housekeeping information to be stored.</p> <p>The following   information is required for the registration:</p> <ul> <li>origin: Storage mnemonic, which can be retrieved from <code>self.get_storage_mnemonic()</code></li> <li>persistence_class: Persistence layer (one of the TYPES in egse.storage.persistence)</li> <li>prep: depending on the type of the persistence class (see respective documentation)</li> </ul> <p>The <code>egse.storage</code> module provides a convenience method that can be called from the method in the subclass:</p> <pre><code>&gt;&gt;&gt; from egse.storage import register_to_storage_manager  # noqa\n</code></pre> Note <p>the <code>egse.storage</code> module might not be available, it is provided by the <code>cgse-core</code> package.</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.schedule_task","title":"schedule_task","text":"<pre><code>schedule_task(callback, after=0.0, when=None)\n</code></pre> <p>Schedules a task to run in the control server event loop.</p> <p>The <code>callback</code> function will be executed as soon as possible in the <code>serve()</code> event loop.</p> <p>Some simple scheduling options are available:</p> <ul> <li>after: the task will only execute 'x' seconds after the time of scheduling. I.e.   the task will be rescheduled until time &gt; scheduled time + 'x' seconds.</li> <li>when: the task will only execute when the condition is True.</li> </ul> <p>The <code>after</code> and the <code>when</code> arguments can be combined.</p> Note <ul> <li>This function is intended to be used in order to prevent a deadlock.</li> <li>Since the <code>callback</code> function is executed in the <code>serve()</code> event loop, it shall not block!</li> </ul>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.serve","title":"serve","text":"<pre><code>serve()\n</code></pre> <p>Activation of the Control Server.</p> <p>This comprises the following steps:</p> <ul> <li>Executing the <code>before_serve</code> method;</li> <li>Checking if the Storage Manager is active and registering the Control Server to it;</li> <li>Start listening  for keyboard interrupts;</li> <li>Start accepting (listening to) commands;</li> <li>Start sending out monitoring information;</li> <li>Start sending out housekeeping information;</li> <li>Start listening for quit commands;</li> <li>After a quit command has been received:<ul> <li>Unregister from the Storage Manager;</li> <li>Execute the <code>after_serve</code> method;</li> <li>Close all sockets;</li> <li>Clean up all threads.</li> </ul> </li> </ul>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.set_hk_delay","title":"set_hk_delay","text":"<pre><code>set_hk_delay(seconds)\n</code></pre> <p>Sets the delay time for housekeeping.</p> <p>The delay time is the time between two successive executions of the <code>get_housekeeping()</code> function of the device protocol.</p> <p>It might happen that the delay time that is set is longer than what you requested. That is the case when the execution of the <code>get_housekeeping()</code> function takes longer than the requested delay time. That should prevent the server from blocking when a too short delay time is requested.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Number of seconds between the housekeeping calls</p> required <p>Returns:</p> Type Description <code>float</code> <p>Delay that was set [ms].</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.set_logging_level","title":"set_logging_level","text":"<pre><code>set_logging_level(level)\n</code></pre> <p>Sets the logging level to the given level.</p> <p>Allowed logging levels are:</p> <ul> <li>\"CRITICAL\" or \"FATAL\" or 50</li> <li>\"ERROR\" or 40</li> <li>\"WARNING\" or \"WARN\" or 30</li> <li>\"INFO\" or 20</li> <li>\"DEBUG\" or 10</li> <li>\"NOTSET\" or 0</li> </ul> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | str</code> <p>Logging level to use, specified as either a string or an integer</p> required"},{"location":"api/dummy/#egse.dummy.DummyControlServer.set_mon_delay","title":"set_mon_delay","text":"<pre><code>set_mon_delay(seconds)\n</code></pre> <p>Sets the delay time for monitoring.</p> <p>The delay time is the time between two successive executions of the <code>get_status()</code> function of the device protocol.</p> <p>It might happen that the delay time that is set is longer than what you requested. That is the case when the execution of the <code>get_status()</code> function takes longer than the requested delay time. That should prevent the server from blocking when a too short delay time is requested.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Number of seconds between the monitoring calls</p> required <p>Returns:</p> Type Description <code>float</code> <p>Delay that was set [ms].</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.set_scheduled_task_delay","title":"set_scheduled_task_delay","text":"<pre><code>set_scheduled_task_delay(seconds)\n</code></pre> <p>Sets the delay time between successive executions of scheduled tasks.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>the time interval between two successive executions [seconds]</p> required"},{"location":"api/dummy/#egse.dummy.DummyControlServer.store_housekeeping_information","title":"store_housekeeping_information","text":"<pre><code>store_housekeeping_information(data)\n</code></pre> <p>Sends housekeeping information to the Storage Manager.</p> <p>This method has to be overwritten by the subclasses if they want the device housekeeping information to be saved.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>a dictionary containing parameter name and value of all device housekeeping. There is also a timestamp that represents the date/time when the HK was received from the device.</p> required"},{"location":"api/dummy/#egse.dummy.DummyControlServer.unregister_as_listener","title":"unregister_as_listener","text":"<pre><code>unregister_as_listener(proxy, listener)\n</code></pre> <p>Removes a registered listener from the specified proxy.</p> <p>This function attempts to remove the provided listener from the specified proxy. It employs a retry mechanism to handle potential ConnectionError exceptions, making up to 5 attempts to add the listener.</p> <p>Parameters:</p> Name Type Description Default <code>proxy</code> <code>Type</code> <p>A callable object representing the proxy from which the listener will be removed.</p> required <code>listener</code> <code>dict</code> <p>The listener to be removed. Should be a dictionary containing listener details.</p> required <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the connection to the proxy encounters issues even after multiple retry attempts.</p> Note <p>The function runs in a separate thread but will block until the de-registration is finished. The reason being that this method is usually called in a <code>after_serve</code> block so it needs to finish before the ZeroMQ context is destroyed.</p>"},{"location":"api/dummy/#egse.dummy.DummyControlServer.unregister_from_storage_manager","title":"unregister_from_storage_manager","text":"<pre><code>unregister_from_storage_manager()\n</code></pre> <p>Unregisters the Control Server from the Storage Manager.</p> <p>This method has to be overwritten by the subclasses.</p> <p>The following information is required for the registration:</p> <ul> <li>origin: Storage mnemonic, which can be retrieved from <code>self.get_storage_mnemonic()</code></li> </ul> <p>The <code>egse.storage</code> module provides a convenience method that can be called from the method in the subclass:</p> <pre><code>&gt;&gt;&gt; from egse.storage import unregister_from_storage_manager  # noqa\n</code></pre> Note <p>the <code>egse.storage</code> module might not be available, it is provided by the <code>cgse-core</code> package.</p>"},{"location":"api/dummy/#egse.dummy.DummyController","title":"DummyController","text":"<pre><code>DummyController(control_server)\n</code></pre> <p>               Bases: <code>DummyInterface</code>, <code>EventInterface</code></p> <p>The controller class for the dummy device.</p> <p>This class is used to directly communicate with the device.</p>"},{"location":"api/dummy/#egse.dummy.DummyDeviceEthernetInterface","title":"DummyDeviceEthernetInterface","text":"<pre><code>DummyDeviceEthernetInterface(hostname=None, port=None)\n</code></pre> <p>               Bases: <code>DeviceConnectionInterface</code>, <code>DeviceTransport</code></p> <p>Defines the low-level interface to the Dummy Device.</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>the IP address or fully qualified hostname of the Dummy Device controller.</p> <code>None</code> <code>port</code> <code>int</code> <p>the IP port number to connect to.</p> <code>None</code> <p>Methods:</p> Name Description <code>add_observer</code> <p>Add an observer.</p> <code>connect</code> <p>Connects the TCP socket to the device controller.</p> <code>disconnect</code> <p>Disconnect the Ethernet connection from the device controller.</p> <code>get_observers</code> <p>Returns a copy of the registered observers.</p> <code>is_connected</code> <p>Check if the device is connected.</p> <code>notify_observers</code> <p>Notify the observers of a possible state change.</p> <code>query</code> <p>Send a query to the device and wait for the response.</p> <code>read</code> <p>Read a response from the device.</p> <code>reconnect</code> <p>Disconnect from the device, then connect again.</p> <code>trans</code> <p>Send a command to the device and wait for the response.</p> <code>write</code> <p>Send a command to the device.</p>"},{"location":"api/dummy/#egse.dummy.DummyDeviceEthernetInterface.add_observer","title":"add_observer","text":"<pre><code>add_observer(observer)\n</code></pre> <p>Add an observer.</p>"},{"location":"api/dummy/#egse.dummy.DummyDeviceEthernetInterface.connect","title":"connect","text":"<pre><code>connect()\n</code></pre> <p>Connects the TCP socket to the device controller.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when hostname or port number are not initialized properly.</p> <code>DeviceConnectionError</code> <p>on any socket error except timeouts.</p> <code>DeviceTimeoutError</code> <p>on a socket timeout.</p>"},{"location":"api/dummy/#egse.dummy.DummyDeviceEthernetInterface.disconnect","title":"disconnect","text":"<pre><code>disconnect()\n</code></pre> <p>Disconnect the Ethernet connection from the device controller.</p> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>on failure.</p>"},{"location":"api/dummy/#egse.dummy.DummyDeviceEthernetInterface.get_observers","title":"get_observers","text":"<pre><code>get_observers()\n</code></pre> <p>Returns a copy of the registered observers.</p>"},{"location":"api/dummy/#egse.dummy.DummyDeviceEthernetInterface.is_connected","title":"is_connected","text":"<pre><code>is_connected()\n</code></pre> <p>Check if the device is connected.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True is the device is connected, False otherwise.</p>"},{"location":"api/dummy/#egse.dummy.DummyDeviceEthernetInterface.notify_observers","title":"notify_observers","text":"<pre><code>notify_observers(state)\n</code></pre> <p>Notify the observers of a possible state change.</p>"},{"location":"api/dummy/#egse.dummy.DummyDeviceEthernetInterface.query","title":"query","text":"<pre><code>query(command)\n</code></pre> <p>Send a query to the device and wait for the response.</p> <p>This <code>query</code> method is an alias for the <code>trans</code> command. For some commands it might be more intuitive to use the <code>query</code> instead of the <code>trans</code>action. No need to override this method as it delegates to <code>trans</code>.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>the query command.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The response to the query.</p>"},{"location":"api/dummy/#egse.dummy.DummyDeviceEthernetInterface.read","title":"read","text":"<pre><code>read()\n</code></pre> <p>Read a response from the device.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>A bytes object containing the response from the device. No processing is done</p> <code>bytes</code> <p>on the response.</p> <p>Raises:</p> Type Description <code>DeviceTimeoutError</code> <p>when the read operation timed out.</p>"},{"location":"api/dummy/#egse.dummy.DummyDeviceEthernetInterface.reconnect","title":"reconnect","text":"<pre><code>reconnect()\n</code></pre> <p>Disconnect from the device, then connect again.</p>"},{"location":"api/dummy/#egse.dummy.DummyDeviceEthernetInterface.trans","title":"trans","text":"<pre><code>trans(command)\n</code></pre> <p>Send a command to the device and wait for the response.</p> <p>No processing is done on the command string, except for the encoding into a bytes object.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>the command string including terminators.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>A bytes object containing the response from the device. No processing is done</p> <code>bytes</code> <p>on the response.</p> <p>Raises:</p> Type Description <code>DeviceTimeoutError</code> <p>when the sendall() timed out, and a DeviceConnectionError if there was a socket related error.</p>"},{"location":"api/dummy/#egse.dummy.DummyDeviceEthernetInterface.write","title":"write","text":"<pre><code>write(command)\n</code></pre> <p>Send a command to the device.</p> <p>No processing is done on the command string, except for the encoding into a bytes object.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>the command string including terminators.</p> required <p>Raises:</p> Type Description <code>DeviceTimeoutError</code> <p>when the sendall() timed out, and a DeviceConnectionError if there was a socket related error.</p>"},{"location":"api/dummy/#egse.dummy.DummyInterface","title":"DummyInterface","text":"<p>The interface for the dummy device.</p> <p>Methods:</p> Name Description <code>division</code> <p>Return the division of the number 'a' divided by the number 'b'.</p> <code>get_value</code> <p>Return a float value from the device.</p> <code>info</code> <p>Return an info string from the device.</p>"},{"location":"api/dummy/#egse.dummy.DummyInterface.division","title":"division","text":"<pre><code>division(a, b)\n</code></pre> <p>Return the division of the number 'a' divided by the number 'b'. This method can also be used during testing to cause a ZeroDivisionError that will return a Failure object.</p>"},{"location":"api/dummy/#egse.dummy.DummyInterface.get_value","title":"get_value","text":"<pre><code>get_value(*args, **kwargs)\n</code></pre> <p>Return a float value from the device. This dummy implementation will return a random number between 0.0 and 1.0.</p>"},{"location":"api/dummy/#egse.dummy.DummyInterface.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Return an info string from the device.</p>"},{"location":"api/dummy/#egse.dummy.DummyProtocol","title":"DummyProtocol","text":"<pre><code>DummyProtocol(control_server)\n</code></pre> <p>               Bases: <code>CommandProtocol</code></p> <p>The protocol class for the dummy device.</p> <p>This class defines the communication between the client (usually a Proxy) and the server (the control server) for this device.</p> <p>Parameters:</p> Name Type Description Default <code>control_server</code> <code>ControlServer</code> <p>the control server for the dummy device.</p> required <p>Methods:</p> Name Description <code>bind</code> <p>Bind to a socket to listen for commands.</p> <code>build_device_method_lookup_table</code> <p>Fill the lookup table with device command methods that are bound to the device object.</p> <code>get_control_server</code> <p>Return the control server to which this protocol is associated.</p> <code>get_device</code> <p>Returns the device object for the device that is controlled by this protocol.</p> <code>handle_device_method</code> <p>Call the device method with the given arguments.</p> <code>is_alive</code> <p>This method can be overridden by a subclass to check whether any Thread or sub-process</p> <code>load_commands</code> <p>Loads the command definitions from the given <code>command_settings</code> and builds an internal</p> <code>receive</code> <p>Receive a serialized message from the ControlServer. The message will not</p> <code>send</code> <p>Send a message to the ControlServer. The message shall be fully populated</p> <code>send_commands</code> <p>Send the command definitions that were loaded for the specific device.</p> <code>update_connection_state</code> <p>Updates the connection state with the given state.</p> <p>Attributes:</p> Name Type Description <code>control_server</code> <p>Return the control server to which this protocol is associated.</p> <code>state</code> <p>Returns the current connection state of the device.</p>"},{"location":"api/dummy/#egse.dummy.DummyProtocol.control_server","title":"control_server  <code>property</code>","text":"<pre><code>control_server\n</code></pre> <p>Return the control server to which this protocol is associated.</p>"},{"location":"api/dummy/#egse.dummy.DummyProtocol.state","title":"state  <code>property</code>","text":"<pre><code>state\n</code></pre> <p>Returns the current connection state of the device.</p>"},{"location":"api/dummy/#egse.dummy.DummyProtocol.bind","title":"bind","text":"<pre><code>bind(socket)\n</code></pre> <p>Bind to a socket to listen for commands.</p>"},{"location":"api/dummy/#egse.dummy.DummyProtocol.build_device_method_lookup_table","title":"build_device_method_lookup_table","text":"<pre><code>build_device_method_lookup_table(device_obj)\n</code></pre> <p>Fill the lookup table with device command methods that are bound to the device object.</p> <p>Parameters:</p> Name Type Description Default <code>device_obj</code> <code>Any</code> <p>instance of a device command class</p> required"},{"location":"api/dummy/#egse.dummy.DummyProtocol.get_control_server","title":"get_control_server","text":"<pre><code>get_control_server()\n</code></pre> <p>Return the control server to which this protocol is associated.</p>"},{"location":"api/dummy/#egse.dummy.DummyProtocol.get_device","title":"get_device","text":"<pre><code>get_device()\n</code></pre> <p>Returns the device object for the device that is controlled by this protocol.</p>"},{"location":"api/dummy/#egse.dummy.DummyProtocol.handle_device_method","title":"handle_device_method","text":"<pre><code>handle_device_method(cmd, *args, **kwargs)\n</code></pre> <p>Call the device method with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>Command</code> <p>the devices command class that knows which device command shall be called</p> required <code>args</code> <code>list</code> <p>the arguments that will be passed on to the device command</p> <code>()</code> <code>kwargs</code> <code>dict</code> <p>the keyword arguments that will be passed on to the device command</p> <code>{}</code>"},{"location":"api/dummy/#egse.dummy.DummyProtocol.is_alive","title":"is_alive","text":"<pre><code>is_alive()\n</code></pre> <p>This method can be overridden by a subclass to check whether any Thread or sub-process that was started is still alive.</p>"},{"location":"api/dummy/#egse.dummy.DummyProtocol.load_commands","title":"load_commands","text":"<pre><code>load_commands(\n    command_settings, command_class, device_class\n)\n</code></pre> <p>Loads the command definitions from the given <code>command_settings</code> and builds an internal dictionary containing the command names as keys and the corresponding <code>Command</code> class objects as values.</p> <p>The <code>command_settings</code> is usually loaded from a YAML configuration file containing the command definitions for the device.</p> <p>Parameters:</p> Name Type Description Default <code>command_settings</code> <code>dict</code> <p>a dictionary containing the command definitions for this device</p> required <code>command_class</code> <code>Type[Command]</code> <p>the type of command to create, a subclass of Command</p> required <code>device_class</code> <code>Any</code> <p>the type of the base device class from which the methods are loaded</p> required"},{"location":"api/dummy/#egse.dummy.DummyProtocol.receive","title":"receive","text":"<pre><code>receive()\n</code></pre> <p>Receive a serialized message from the ControlServer. The message will not be decoded/de-serialized, but is returned as it was sent. Decoding shall be handled by the calling method.</p>"},{"location":"api/dummy/#egse.dummy.DummyProtocol.send","title":"send","text":"<pre><code>send(data)\n</code></pre> <p>Send a message to the ControlServer. The message shall be fully populated and is only serialized before sending over the ZeroMQ socket.</p> We need to add error handling here, e.g. what if the send() fails? Do we need <p>to implement retries as with Proxy?</p>"},{"location":"api/dummy/#egse.dummy.DummyProtocol.send_commands","title":"send_commands","text":"<pre><code>send_commands()\n</code></pre> <p>Send the command definitions that were loaded for the specific device.</p>"},{"location":"api/dummy/#egse.dummy.DummyProtocol.update_connection_state","title":"update_connection_state","text":"<pre><code>update_connection_state(state)\n</code></pre> <p>Updates the connection state with the given state.</p>"},{"location":"api/dummy/#egse.dummy.DummyProxy","title":"DummyProxy","text":"<pre><code>DummyProxy(\n    protocol=PROTOCOL,\n    hostname=HOSTNAME,\n    port=COMMANDING_PORT,\n    timeout=TIMEOUT,\n)\n</code></pre> <p>               Bases: <code>Proxy</code>, <code>DummyInterface</code>, <code>EventInterface</code></p> <p>The Proxy class for the dummy device.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>str</code> <p>the transport protocol [default is taken from settings file]</p> <code>PROTOCOL</code> <code>hostname</code> <code>str</code> <p>location of the control server (IP address) [default is taken from settings file]</p> <code>HOSTNAME</code> <code>port</code> <code>int</code> <p>TCP port on which the control server is listening for commands [default is taken from settings file]</p> <code>COMMANDING_PORT</code> <code>timeout</code> <code>int</code> <p>a socket timeout in milliseconds</p> <code>TIMEOUT</code> <p>Methods:</p> Name Description <code>division</code> <p>Return the division of the number 'a' divided by the number 'b'.</p> <code>get_commanding_port</code> <p>Returns the commanding port.</p> <code>get_commands</code> <p>Returns a list of command names that can be send to the device or the</p> <code>get_endpoint</code> <p>Returns the endpoint.</p> <code>get_ip_address</code> <p>Returns the hostname of the control server.</p> <code>get_monitoring_port</code> <p>Returns the monitoring port.</p> <code>get_service_port</code> <p>Returns the service port.</p> <code>get_service_proxy</code> <p>Return a ServiceProxy for the control server of this proxy object.</p> <code>get_value</code> <p>Return a float value from the device.</p> <code>handle_event</code> <p>Handles the specified event.</p> <code>has_commands</code> <p>Return <code>True</code> if commands have been loaded.</p> <code>info</code> <p>Return an info string from the device.</p> <code>load_commands</code> <p>Requests all available commands from the control server and adds them to</p> <code>send</code> <p>Sends a command to the control server and waits for a response.</p>"},{"location":"api/dummy/#egse.dummy.DummyProxy.division","title":"division","text":"<pre><code>division(a, b)\n</code></pre> <p>Return the division of the number 'a' divided by the number 'b'. This method can also be used during testing to cause a ZeroDivisionError that will return a Failure object.</p>"},{"location":"api/dummy/#egse.dummy.DummyProxy.get_commanding_port","title":"get_commanding_port","text":"<pre><code>get_commanding_port()\n</code></pre> <p>Returns the commanding port.</p>"},{"location":"api/dummy/#egse.dummy.DummyProxy.get_commands","title":"get_commands","text":"<pre><code>get_commands()\n</code></pre> <p>Returns a list of command names that can be send to the device or the control server.</p> <p>The commands are defined in the YAML settings file of the device. Special commands are available for the ServiceProxy which configure and control the control servers.</p>"},{"location":"api/dummy/#egse.dummy.DummyProxy.get_endpoint","title":"get_endpoint","text":"<pre><code>get_endpoint()\n</code></pre> <p>Returns the endpoint.</p>"},{"location":"api/dummy/#egse.dummy.DummyProxy.get_ip_address","title":"get_ip_address","text":"<pre><code>get_ip_address()\n</code></pre> <p>Returns the hostname of the control server.</p>"},{"location":"api/dummy/#egse.dummy.DummyProxy.get_monitoring_port","title":"get_monitoring_port","text":"<pre><code>get_monitoring_port()\n</code></pre> <p>Returns the monitoring port.</p>"},{"location":"api/dummy/#egse.dummy.DummyProxy.get_service_port","title":"get_service_port","text":"<pre><code>get_service_port()\n</code></pre> <p>Returns the service port.</p>"},{"location":"api/dummy/#egse.dummy.DummyProxy.get_service_proxy","title":"get_service_proxy","text":"<pre><code>get_service_proxy()\n</code></pre> <p>Return a ServiceProxy for the control server of this proxy object.</p>"},{"location":"api/dummy/#egse.dummy.DummyProxy.get_value","title":"get_value","text":"<pre><code>get_value(*args, **kwargs)\n</code></pre> <p>Return a float value from the device. This dummy implementation will return a random number between 0.0 and 1.0.</p>"},{"location":"api/dummy/#egse.dummy.DummyProxy.handle_event","title":"handle_event","text":"<pre><code>handle_event(event)\n</code></pre> <p>Handles the specified event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>An instance of the Event class representing the event to be handled.</p> required"},{"location":"api/dummy/#egse.dummy.DummyProxy.has_commands","title":"has_commands","text":"<pre><code>has_commands()\n</code></pre> <p>Return <code>True</code> if commands have been loaded.</p>"},{"location":"api/dummy/#egse.dummy.DummyProxy.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Return an info string from the device.</p>"},{"location":"api/dummy/#egse.dummy.DummyProxy.load_commands","title":"load_commands","text":"<pre><code>load_commands()\n</code></pre> <p>Requests all available commands from the control server and adds them to the Proxy public interface, i.e. each command will become a method for this Proxy.</p> <p>A warning will be issued when a command will overwrite an existing method of the Proxy class. The original method will not be overwritten and the behavior of the Proxy command will not be what is expected.</p>"},{"location":"api/dummy/#egse.dummy.DummyProxy.send","title":"send","text":"<pre><code>send(data, retries=REQUEST_RETRIES, timeout=None)\n</code></pre> <p>Sends a command to the control server and waits for a response.</p> <p>When not connected to the control server or when a timeout occurs, the <code>send()</code> command retries a number of times to send the command.</p> <p>The number of retries is hardcoded and currently set to '2', the request timeout is set to 2.5 seconds.</p> <p>The command data will be pickled before sending. Make sure the <code>data</code> argument can be dumped by pickle.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>the command that is sent to the control server, usually a string, but that is not enforced.</p> required <code>timeout</code> <code>int</code> <p>the time to wait for a reply [in milliseconds]</p> <code>None</code> <code>retries</code> <code>int</code> <p>the number of time we should retry to send the message</p> <code>REQUEST_RETRIES</code> <p>Returns:</p> Name Type Description <code>response</code> <p>the response from the control server or <code>None</code> when there was a problem or a timeout.</p>"},{"location":"api/dummy/#egse.dummy.is_dummy_cs_active","title":"is_dummy_cs_active","text":"<pre><code>is_dummy_cs_active()\n</code></pre> <p>Returns True if the dummy device control server is active.</p>"},{"location":"api/dummy/#egse.dummy.start_cs","title":"start_cs","text":"<pre><code>start_cs()\n</code></pre> <p>Start the dummy control server on localhost.</p>"},{"location":"api/dummy/#egse.dummy.start_dev","title":"start_dev","text":"<pre><code>start_dev()\n</code></pre> <p>Start the dummy device simulator.</p>"},{"location":"api/dummy/#egse.dummy.stop_cs","title":"stop_cs","text":"<pre><code>stop_cs()\n</code></pre> <p>Send a quit service command to the dummy control server.</p>"},{"location":"api/env/","title":"egse.env","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/env/#egse.env","title":"egse.env","text":"<p>This module provides functionality to work with and check your environment variables.</p> <p>The module provides functions to get/set the location of the data storage, the configuration data, and the log files. The locations are determined from the environment variables that are set for the project.</p> <p>Two important and mandatory environment variables are PROJECT and SITE_ID. The PROJECT environment variable is used to construct the names of the other environment variables that are specific to the project. The SITE_ID environment variable is used in the value that is returned for some the of project specific environment variables.</p> <p>Mandatory environment variables:</p> <ul> <li>PROJECT: the name of the project, e.g. PLATO, ARIEL. [shall be UPPER case]</li> <li>SITE_ID: the site identifier, e.g. the lab name or organisation acronym. [shall be UPPER case]</li> </ul> <p>The following environment variables are used by the project:</p> <ul> <li><code>&lt;PROJECT&gt;_DATA_STORAGE_LOCATION</code>: the root of the data storage location.</li> <li><code>&lt;PROJECT&gt;_CONF_DATA_LOCATION</code>: the location of the configuration data.</li> <li><code>&lt;PROJECT&gt;_CONF_REPO_LOCATION</code>: the location of the configuration data GitHub repository.</li> <li><code>&lt;PROJECT&gt;_LOG_FILE_LOCATION</code>: the location of the log files.</li> <li><code>&lt;PROJECT&gt;_LOCAL_SETTINGS</code>: the YAML file that contains site specific local settings.</li> </ul> <p>Do not use the environment variables directly in your code, but use the functions provided by this module to get the locations and settings.</p> <ul> <li><code>get_data_storage_location()</code>: returns the full path of the data storage location.</li> <li><code>get_conf_data_location()</code>: returns the full path of the location of the configuration data.</li> <li><code>get_conf_repo_location()</code>: returns the full path of the location of the configuration data repository.</li> <li><code>get_log_file_location()</code>: returns the full path of the location of the log files.</li> <li><code>get_local_settings()</code>: returns the fully qualified filename of the local settings YAML file.</li> </ul> <p>Warning</p> <p>These environment variables shall not be changed outside the processes that use them and also not using the <code>os.environ</code> within the code. For the known environment variables, use the dedicated 'setters' that are provided by this module. If there is a need to change the environment variables, e.g. in unit tests, make sure to call the <code>egse.env.initialize()</code> to reset the proper state.</p> <p>Functions:</p> Name Description <code>env_var</code> <p>Context manager to run some code that need alternate settings for environment variables.</p> <code>get_conf_data_location</code> <p>Returns the full path of the location of the configuration data for the site id.</p> <code>get_conf_data_location_env_name</code> <p>Returns the name of the environment variable for the project.</p> <code>get_conf_repo_location</code> <p>Returns the fully qualified name of the location of the repository with</p> <code>get_conf_repo_location_env_name</code> <p>Returns the name of the environment variable for the project.</p> <code>get_data_storage_location</code> <p>Returns the full path of the data storage location for the given site_id.</p> <code>get_data_storage_location_env_name</code> <p>Returns the name of the environment variable for the project.</p> <code>get_local_settings_env_name</code> <p>Returns the name of the environment variable for the project.</p> <code>get_local_settings_path</code> <p>Returns the fully qualified filename of the local settings YAML file. When the local settings environment</p> <code>get_log_file_location</code> <p>Returns the full path of the location of the log files. The log file location is read from the environment</p> <code>get_log_file_location_env_name</code> <p>Returns the name of the environment variable for the project.</p> <code>get_project_name</code> <p>Get the PROJECT name. Return None when the PROJECT is not set.</p> <code>get_site_id</code> <p>Get the SITE_ID. Return None if the SITE_ID is not set.</p> <code>set_conf_data_location</code> <p>Sets the environment variable and the internal representation to the given value.</p> <code>set_conf_repo_location</code> <p>Sets the environment variable and the internal representation to the given value.</p> <code>set_data_storage_location</code> <p>Sets the environment variable and the internal representation to the given value.</p> <code>set_local_settings</code> <p>Sets the environment variable and the internal representation to the given value.</p> <code>set_log_file_location</code> <p>Sets the environment variable and the internal representation to the given value.</p>"},{"location":"api/env/#egse.env.NoValue","title":"NoValue","text":"<p>Represents a no value object, an environment variable that was not set.</p> <p>The truth value of this object is always False, and it is equal to any other NoValue object.</p>"},{"location":"api/env/#egse.env.env_var","title":"env_var","text":"<pre><code>env_var(**kwargs)\n</code></pre> <p>Context manager to run some code that need alternate settings for environment variables. This will automatically initialize the CGSE environment upon entry and re-initialize upon exit.</p> Note <p>This context manager is different from the one in <code>egse.system</code> because of the CGSE environment changes.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>str | int | float | bool | None</code> <p>dictionary with environment variables that are needed</p> <code>{}</code> Example <pre><code>from egse.env import env_var\nwith env_var(PLATO_DATA_STORAGE_LOCATION=\"/Users/rik/data\"):\n    # do stuff that needs these alternate setting\n    ...\n</code></pre>"},{"location":"api/env/#egse.env.get_conf_data_location","title":"get_conf_data_location","text":"<pre><code>get_conf_data_location(site_id=None)\n</code></pre> <p>Returns the full path of the location of the configuration data for the site id.</p> <p>If the site_id is None, it is determined from the environment variable SITE_ID.</p> <p>When the <code>${PROJECT}_CONF_DATA_LOCATION</code> environment variable is not set, the configuration data location will be the <code>${PROJECT}_DATA_STORAGE_LOCATION + '/conf'</code>.</p> <p>Parameters:</p> Name Type Description Default <code>site_id</code> <code>str</code> <p>the site identifier (to be used instead of the SITE_ID environment variable)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The full path of location of the configuration data as a string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when the SITE_ID or the <code>${PROJECT}_DATA_STORAGE_LOCATION</code> is not set.</p>"},{"location":"api/env/#egse.env.get_conf_data_location_env_name","title":"get_conf_data_location_env_name","text":"<pre><code>get_conf_data_location_env_name()\n</code></pre> <p>Returns the name of the environment variable for the project.</p>"},{"location":"api/env/#egse.env.get_conf_repo_location","title":"get_conf_repo_location","text":"<pre><code>get_conf_repo_location()\n</code></pre> <p>Returns the fully qualified name of the location of the repository with configuration and calibration data.</p> <p>Returns None if no environment variable was defined or if the location doesn't exist. In both cases a Warning is issued.</p>"},{"location":"api/env/#egse.env.get_conf_repo_location_env_name","title":"get_conf_repo_location_env_name","text":"<pre><code>get_conf_repo_location_env_name()\n</code></pre> <p>Returns the name of the environment variable for the project.</p>"},{"location":"api/env/#egse.env.get_data_storage_location","title":"get_data_storage_location","text":"<pre><code>get_data_storage_location(site_id=None)\n</code></pre> <p>Returns the full path of the data storage location for the given site_id.</p> <p>If the site_id is None, it is determined from the environment variable SITE_ID.</p> <p>If the <code>${PROJECT}_DATA_STORAGE_LOCATION</code> environment variable does not end with the site_id, the site_id will be appended to the path on return. That means the actual data storage location will always be site specific.</p> Note <p>when you specify the <code>site_id</code> as an argument, it takes precedence     over the SITE_ID environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>site_id</code> <code>str</code> <p>the site identifier (to be used instead of the SITE_ID environment variable)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The full path of data storage location as a string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when the SITE_ID or the ${PROJECT}_DATA_STORAGE_LOCATION is not set.</p>"},{"location":"api/env/#egse.env.get_data_storage_location_env_name","title":"get_data_storage_location_env_name","text":"<pre><code>get_data_storage_location_env_name()\n</code></pre> <p>Returns the name of the environment variable for the project.</p>"},{"location":"api/env/#egse.env.get_local_settings_env_name","title":"get_local_settings_env_name","text":"<pre><code>get_local_settings_env_name()\n</code></pre> <p>Returns the name of the environment variable for the project.</p>"},{"location":"api/env/#egse.env.get_local_settings_path","title":"get_local_settings_path","text":"<pre><code>get_local_settings_path()\n</code></pre> <p>Returns the fully qualified filename of the local settings YAML file. When the local settings environment variable is not defined or is an empty string, None is returned.</p> Warning <p>The function will generate a warning when</p> <ul> <li>When the local settings environment variable is not defined, or</li> <li>when the path defined by the environment variable doesn't exist.</li> </ul>"},{"location":"api/env/#egse.env.get_log_file_location","title":"get_log_file_location","text":"<pre><code>get_log_file_location(site_id=None)\n</code></pre> <p>Returns the full path of the location of the log files. The log file location is read from the environment variable <code>${PROJECT}_LOG_FILE_LOCATION</code>. The location shall be independent of any setting that is subject to change.</p> <p>If the environment variable is not set, a default log file location is created from the data storage location as follows: <code>&lt;PROJECT&gt;_DATA_STORAGE_LOCATION/&lt;SITE_ID&gt;/log</code>.</p> <p>Parameters:</p> Name Type Description Default <code>site_id</code> <code>str</code> <p>the site identifier</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The full path of location of the log files as a string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when the SITE_ID or the ${PROJECT}_DATA_STORAGE_LOCATION is not set.</p>"},{"location":"api/env/#egse.env.get_log_file_location_env_name","title":"get_log_file_location_env_name","text":"<pre><code>get_log_file_location_env_name()\n</code></pre> <p>Returns the name of the environment variable for the project.</p>"},{"location":"api/env/#egse.env.get_project_name","title":"get_project_name","text":"<pre><code>get_project_name()\n</code></pre> <p>Get the PROJECT name. Return None when the PROJECT is not set.</p>"},{"location":"api/env/#egse.env.get_site_id","title":"get_site_id","text":"<pre><code>get_site_id()\n</code></pre> <p>Get the SITE_ID. Return None if the SITE_ID is not set.</p>"},{"location":"api/env/#egse.env.initialize","title":"initialize","text":"<pre><code>initialize()\n</code></pre> <p>Initialize the environment variables that are required for the CGSE to function properly. This function will print a warning if any of the mandatory environment variables is not set.</p> <p>This function is automatically called on import and can be called whenever the environment variables have been changed, e.g. in unit tests.</p>"},{"location":"api/env/#egse.env.print_env","title":"print_env","text":"<pre><code>print_env()\n</code></pre> <p>Prints out the mandatory and known environment variables at the time of the function call. The function and lineno is also printed for information.</p>"},{"location":"api/env/#egse.env.set_conf_data_location","title":"set_conf_data_location","text":"<pre><code>set_conf_data_location(location)\n</code></pre> <p>Sets the environment variable and the internal representation to the given value.</p> Warning <p>Issues a warning when the given location doesn't exist.</p>"},{"location":"api/env/#egse.env.set_conf_repo_location","title":"set_conf_repo_location","text":"<pre><code>set_conf_repo_location(location)\n</code></pre> <p>Sets the environment variable and the internal representation to the given value.</p> <p>When the location is None, the environment variable will be unset and its internal representation will be NoValue().</p> Warning <p>Issues a warning when the given location doesn't exist.</p>"},{"location":"api/env/#egse.env.set_data_storage_location","title":"set_data_storage_location","text":"<pre><code>set_data_storage_location(location)\n</code></pre> <p>Sets the environment variable and the internal representation to the given value.</p> Warning <p>Issues a warning when the given location doesn't exist.</p>"},{"location":"api/env/#egse.env.set_local_settings","title":"set_local_settings","text":"<pre><code>set_local_settings(path)\n</code></pre> <p>Sets the environment variable and the internal representation to the given value.</p> <p>When the path is set to None, the environment variable will be unset.</p> Warning <p>Issues a warning when the given path doesn't exist.</p>"},{"location":"api/env/#egse.env.set_log_file_location","title":"set_log_file_location","text":"<pre><code>set_log_file_location(location)\n</code></pre> <p>Sets the environment variable and the internal representation to the given value.</p> Warning <p>Issues a warning when the given location doesn't exist.</p>"},{"location":"api/env/#egse.env.set_project_name","title":"set_project_name","text":"<pre><code>set_project_name(name)\n</code></pre> <p>Set the environment variable PROJECT and its internal representation.</p>"},{"location":"api/env/#egse.env.set_site_id","title":"set_site_id","text":"<pre><code>set_site_id(name)\n</code></pre> <p>Set the environment variable SITE_ID and its internal representation.</p>"},{"location":"api/exceptions/","title":"egse.exceptions","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p> <pre><code>Exception\n \u251c\u2500\u2500 CGSEException\n \u2502    \u251c\u2500\u2500 Warning\n \u2502    \u2514\u2500\u2500 Error\n \u2502        \u251c\u2500\u2500 InvalidOperationError\n \u2502        \u251c\u2500\u2500 DeviceNotFoundError\n \u2502        \u251c\u2500\u2500 InternalStateError\n \u2502        \u2514\u2500\u2500 DeviceError\n \u2502             \u251c\u2500\u2500 DeviceControllerError\n \u2502             \u251c\u2500\u2500 DeviceConnectionError\n \u2502             \u251c\u2500\u2500 DeviceTimeoutError\n \u2502             \u2514\u2500\u2500 DeviceInterfaceError\n \u251c\u2500\u2500 Failure\n \u251c\u2500\u2500 HexapodError\n \u251c\u2500\u2500 PMACError\n \u251c\u2500\u2500 OGSEError\n \u251c\u2500\u2500 ESLError\n \u251c\u2500\u2500 FilterWheelError\n \u251c\u2500\u2500 FilterWheel8smc4Error\n \u251c\u2500\u2500 ShutterKSC1010Error\n \u251c\u2500\u2500 WindowSizeError\n \u251c\u2500\u2500 SettingsError\n \u2514\u2500\u2500 StagesError\n</code></pre>"},{"location":"api/exceptions/#egse.exceptions","title":"egse.exceptions","text":"<p>Classes:</p> Name Description <code>Abort</code> <p>Internal Exception to signal a process to abort.</p> <code>CGSEException</code> <p>The base exception for all errors and warnings in the Common-EGSE.</p> <code>DeviceNotFoundError</code> <p>Raised when a device could not be located, or loaded.</p> <code>Error</code> <p>The base class for all Common-EGSE Errors.</p> <code>FileIsEmptyError</code> <p>Raised when a file is empty and that is unexpected.</p> <code>InitialisationError</code> <p>Raised when an initialisation failed.</p> <code>InternalError</code> <p>Raised when an internal inconsistency occurred in a function, method or class.</p> <code>InternalStateError</code> <p>Raised when an object encounters an internal state inconsistency.</p> <code>InvalidInputError</code> <p>Exception raised when the input is invalid after editing.</p> <code>InvalidOperationError</code> <p>Raised when a certain operation is not valid in the given state,</p> <code>Warning</code> <p>The base class for all Common-EGSE Warnings.</p>"},{"location":"api/exceptions/#egse.exceptions.Abort","title":"Abort","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Internal Exception to signal a process to abort.</p>"},{"location":"api/exceptions/#egse.exceptions.CGSEException","title":"CGSEException","text":"<p>               Bases: <code>Exception</code></p> <p>The base exception for all errors and warnings in the Common-EGSE.</p>"},{"location":"api/exceptions/#egse.exceptions.DeviceNotFoundError","title":"DeviceNotFoundError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when a device could not be located, or loaded.</p>"},{"location":"api/exceptions/#egse.exceptions.Error","title":"Error","text":"<p>               Bases: <code>CGSEException</code></p> <p>The base class for all Common-EGSE Errors.</p>"},{"location":"api/exceptions/#egse.exceptions.FileIsEmptyError","title":"FileIsEmptyError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when a file is empty and that is unexpected.</p>"},{"location":"api/exceptions/#egse.exceptions.InitialisationError","title":"InitialisationError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when an initialisation failed.</p>"},{"location":"api/exceptions/#egse.exceptions.InternalError","title":"InternalError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when an internal inconsistency occurred in a function, method or class.</p>"},{"location":"api/exceptions/#egse.exceptions.InternalStateError","title":"InternalStateError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when an object encounters an internal state inconsistency.</p>"},{"location":"api/exceptions/#egse.exceptions.InvalidInputError","title":"InvalidInputError","text":"<p>               Bases: <code>Error</code></p> <p>Exception raised when the input is invalid after editing.</p>"},{"location":"api/exceptions/#egse.exceptions.InvalidOperationError","title":"InvalidOperationError","text":"<p>               Bases: <code>Error</code></p> <p>Raised when a certain operation is not valid in the given state, circumstances or environment.</p>"},{"location":"api/exceptions/#egse.exceptions.Warning","title":"Warning","text":"<p>               Bases: <code>CGSEException</code></p> <p>The base class for all Common-EGSE Warnings.</p>"},{"location":"api/heartbeat/","title":"egse.heartbeat","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/heartbeat/#egse.heartbeat","title":"egse.heartbeat","text":"<p>Classes:</p> Name Description <code>HeartbeatBroadcaster</code> <p>Sends a heartbeat signal to the endpoint using a PUB-SUB protocol.</p>"},{"location":"api/heartbeat/#egse.heartbeat.HeartbeatBroadcaster","title":"HeartbeatBroadcaster","text":"<pre><code>HeartbeatBroadcaster(period=1.0, endpoint='tcp://*:5555')\n</code></pre> <p>               Bases: <code>Thread</code></p> <p>Sends a heartbeat signal to the endpoint using a PUB-SUB protocol.</p> <p>The heartbeat message is sent by default every second, but that can be changed by the <code>period</code> argument (which is in fractional seconds).</p> <p>Since the broadcaster runs in a thread, it is not a full prove method that the parent process is still running. Therefore, the parent process can set a custom messages on the queue. That custom message will be broadcast at the same time as the next heartbeat, which is probably not the time that the custom message was set. Keep that in mind.</p>"},{"location":"api/hk/","title":"egse.hk","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/hk/#egse.hk","title":"egse.hk","text":"<p>Classes:</p> Name Description <code>HKError</code> <p>An HK-specific error.</p> <code>TmDictionaryColumns</code> <p>Enumeration of the relevant columns in the TM dictionary spreadsheet.</p> <p>Functions:</p> Name Description <code>convert_hk_names</code> <p>Converts the names of the HK parameters in the given dictionary.</p> <code>get_hk_info</code> <p>Read the HK spreadsheet and extract information for the given HK parameter.</p> <code>get_housekeeping</code> <p>Returns the timestamp(s) and housekeeping value(s) for the housekeeping parameter with the given name.</p> <code>read_conversion_dict</code> <p>Read the HK spreadsheet and compose conversion dictionary for HK names.</p>"},{"location":"api/hk/#egse.hk.HKError","title":"HKError","text":"<p>               Bases: <code>Exception</code></p> <p>An HK-specific error.</p>"},{"location":"api/hk/#egse.hk.TmDictionaryColumns","title":"TmDictionaryColumns","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of the relevant columns in the TM dictionary spreadsheet.</p> <p>The relevant columns are:</p> Name Description STORAGE_MNEMONIC Column with the storage mnemonic of the process that generated the HK CORRECT_HK_NAMES Column with the correct HK names (that can be used in <code>get_housekeeping</code>) ORIGINAL_EGSE_HK_NAMES Column with the names that were originally used in <code>get_housekeeping</code> the device protocol SYNOPTICS_ORIGIN Column with the origin of the synoptics at the current site TIMESTAMP_NAMES Column with the name of the timestamps DASHBOARD Column with the name of the dashboard that holds the HK metric"},{"location":"api/hk/#egse.hk.convert_hk_names","title":"convert_hk_names","text":"<pre><code>convert_hk_names(original_hk, conversion_dict)\n</code></pre> <p>Converts the names of the HK parameters in the given dictionary.</p> <p>The names/keys in the given dictionary of HK parameters (original_hk) are replaced by the names from the given conversion dictionary. The original dictionary is left unchanged, a new dictionary is returned.</p> <p>Parameters:</p> Name Type Description Default <code>original_hk</code> <code>dict</code> <p>Original dictionary of HK parameters.</p> required <code>conversion_dict</code> <code>dict</code> <p>Dictionary with the original HK names as keys and the new HK names as values.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A new dictionary of HK parameters with the corrected HK names.</p>"},{"location":"api/hk/#egse.hk.get_hk_info","title":"get_hk_info","text":"<pre><code>get_hk_info(hk_name, setup=None)\n</code></pre> <p>Read the HK spreadsheet and extract information for the given HK parameter.</p> The spreadsheet contains the following information <ul> <li>storage mnemonic of the component that generates the HK</li> <li>original HK name</li> <li>HK name with the correct prefix</li> <li>name of the column (in the HK file) with the corresponding timestamp</li> </ul> <p>Parameters:</p> Name Type Description Default <code>hk_name</code> <code>str</code> <p>Name of the HK parameter.</p> required <code>setup</code> <code>Optional[Setup]</code> <p>the Setup to use, if None, the setup will be loaded from the configuration manager.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple where (1) the first field contains the storage mnemonic of the component that generates the given HK parameter, and (2) the second field contains the name of the column in the HK file with the corresponding timestamp.</p> <p>Raises:</p> Type Description <code>HKError</code> <p>when <code>hk_name</code> is not known.</p>"},{"location":"api/hk/#egse.hk.get_housekeeping","title":"get_housekeeping","text":"<pre><code>get_housekeeping(\n    hk_name,\n    obsid=None,\n    od=None,\n    time_window=None,\n    data_dir=None,\n    setup=None,\n)\n</code></pre> <p>Returns the timestamp(s) and housekeeping value(s) for the housekeeping parameter with the given name.</p> <p>It is possible to indicate for which obsid or which OD the housekeeping is to be returned.  If neither of them is specified, the latest daily files are used.</p> <p>When the time window has not been specified, the last timestamp and housekeeping value will be returned for the given OD. It is possible that a component stopped writing HK for some reason, and that the last housekeeping value is older than you would want.  It is therefore important to inspect the corresponding timestamp.</p> <p>When the time window has been specified, the relevant housekeeping will be read:</p> <ul> <li>determine the sampling rate (compare the timestamps for the last 2 lines in the housekeeping file);</li> <li>determine how many samples we need to read (starting at the back);</li> <li>read the required number of line, starting at the back;</li> <li>for each of the read lines, append the timestamp and HK value to the arrays that will be returned</li> </ul> <p>Parameters:</p> Name Type Description Default <code>hk_name</code> <code>str</code> <p>Name of the housekeeping parameter.</p> required <code>obsid</code> <code>Union[ObservationIdentifier, str, int]</code> <p>Observation identifier.  This can be an ObservationIdentifier object, a string in format TEST_LAB or TEST_LAB_SETUP, or an integer representing the test ID; optional.</p> <code>None</code> <code>od</code> <code>str</code> <p>Identifier for the OD (YYYYMMDD); optional.</p> <code>None</code> <code>time_window</code> <code>int</code> <p>Length of the time window over which to retrieve the housekeeping [s].  The time window ends at the moment this method is called.  If not given, the latest housekeeping value is returned.</p> <code>None</code> <code>data_dir</code> <code>str</code> <p>Folder (with sub-folders /daily and /obs) in which the HK files are stored. If this argument is not provided, the data_dir will be determined from the environment variable <code>${PROJECT}_DATA_STORAGE_LOCATION</code>.</p> <code>None</code> <code>setup</code> <code>Optional[Setup]</code> <p>the Setup to use, if None, the setup will be loaded from the configuration manager</p> <code>None</code> <p>Raises:</p> Type Description <code>HKError</code> <p>when one of the following problems occur * no obsid nor an od argument was provided * no HK measures were found for the given parameter and obsid/od</p> <p>Returns:</p> Type Description <code>tuple | ndarray</code> <p>A tuple or an array based on the time window: - If the time window has not been specified: the most recent timestamp and housekeeping value. - If the time window has been specified: an array of timestamps and an array of housekeeping values,   belonging to the specified time window.</p>"},{"location":"api/hk/#egse.hk.get_housekeeping_names","title":"get_housekeeping_names","text":"<pre><code>get_housekeeping_names(\n    name_filter=None, device_filter=None, setup=None\n)\n</code></pre> <p>Return HK names, storage mnemonic, and description.</p> <p>The TM dictionary is read into a Pandas DataFrame.  If a device filter is given, only the rows pertaining to the given storage mnemonic are kept.  If a name filter is given, only keep the rows for which the HK parameter name contains the given name filter.</p> <p>The result is as a Pandas DataFrame with the following columns:</p> <ul> <li>\"CAM EGSE mnemonic\": Name of the HK parameter;</li> <li>\"Storage mnemonic\": Storage mnemonic of the device producing the HK;</li> <li>\"Description\": Description of the HK parameter.</li> </ul> <p>Synopsis:</p> <ul> <li><code>get_housekeeping_names(name_filter=\"RAW\", device_filter=\"N-FEE-HK\")</code></li> <li><code>get_housekeeping_names(name_filter=\"RAW\", device_filter=\"N-FEE-HK\", setup=setup)</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>name_filter</code> <code>str</code> <p>Filter the HK dataframe, based on (a part of) the name of the HK parameter(s)</p> <code>None</code> <code>device_filter</code> <code>str</code> <p>Filter the HK dataframe, based on the given storage mnemonic</p> <code>None</code> <code>setup</code> <code>Setup</code> <p>the Setup to be used, if None, the setup will be loaded from the configuration manager.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas DataFrame with the HK name, storage mnemonic, and description of the HK parameters that pass the given filter.</p>"},{"location":"api/hk/#egse.hk.get_indices","title":"get_indices","text":"<pre><code>get_indices(filename, hk_name, timestamp_name)\n</code></pre> <p>Return the column number of the timestamp and given HK parameter in the given HK file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>HK file in which to look for the given HK parameter.</p> required <code>hk_name</code> <code>str</code> <p>Name of the HK parameter.</p> required <code>timestamp_name</code> <code>str</code> <p>Name of the corresponding timestamp.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple with:</p> <ul> <li>Index of the column with the timestamps.</li> <li>Index of the column with the HK parameter with the given name.</li> </ul>"},{"location":"api/hk/#egse.hk.get_last_non_empty","title":"get_last_non_empty","text":"<pre><code>get_last_non_empty(filename, timestamp_index, hk_index)\n</code></pre> <p>Return the timestamp and HK value for last real value.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>HK file in which to look for the given HK parameter.</p> required <code>timestamp_index</code> <code>int</code> <p>Index of the column with the timestamps.</p> required <code>hk_index</code> <code>int</code> <p>Index of the column with the HK parameter with the given name.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>The timestamp and HK value with the last real value.</p>"},{"location":"api/hk/#egse.hk.get_sampling_rate","title":"get_sampling_rate","text":"<pre><code>get_sampling_rate(filename, timestamp_name)\n</code></pre> <p>Return the sampling rate for the HK file with the given name [s].</p> <p>The sampling rate is determined as the difference between the timestamps of the last two lines of the HK file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the HK file.  We do not check explicitly whether this file exists.</p> required <code>timestamp_name</code> <code>str</code> <p>the name of the column containing the timestamp</p> required <p>Returns:</p> Type Description <code>float</code> <p>Sampling rate for the HK file with the given name [s].</p>"},{"location":"api/hk/#egse.hk.get_storage_mnemonics","title":"get_storage_mnemonics","text":"<pre><code>get_storage_mnemonics(setup=None)\n</code></pre> <p>Return the list of the storage mnemonics from the TM dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>setup</code> <code>Setup</code> <p>the Setup to be used, if None, the setup will be loaded from the configuration manager.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>List of the storage mnemonics from the TM dictionary.</p>"},{"location":"api/hk/#egse.hk.read_conversion_dict","title":"read_conversion_dict","text":"<pre><code>read_conversion_dict(\n    storage_mnemonic, use_site=False, setup=None\n)\n</code></pre> <p>Read the HK spreadsheet and compose conversion dictionary for HK names.</p> <p>The spreadsheet contains the following information:</p> <pre><code>- storage mnemonic of the component that generates the HK\n- original HK name (as is comes from the device itself)\n- HK name with the correct prefix\n- name of the column (in the HK file) with the corresponding timestamp\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>storage_mnemonic</code> <code>str</code> <p>Storage mnemonic of the component for which to compose the conversion dictionary</p> required <code>use_site</code> <code>bool</code> <p>Indicate whether the prefixes of the new HK names are TH-specific</p> <code>False</code> <code>setup</code> <code>Optional[Setup]</code> <p>the Setup to be used, if None, the setup will be loaded from the configuration manager.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the original HK names as keys and the converted HK names as values.</p>"},{"location":"api/listener/","title":"egse.listener","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/listener/#egse.listener","title":"egse.listener","text":"<p>This module defines Listeners between control servers and is part of a notification system where changes in one control-server are notified to all listeners of that control-server.</p> <p>Since we have communication between control servers, a listener registers to a control server with its name/id and a Proxy class that will be used to send the notification. A listener can also contain an <code>event_id</code> to restrict events to handle. (Shall events be filtered on the server (only notify events that match the <code>event_id</code> or shall they be filtered on the client (only handle those events that match the <code>event_id</code>) ?)</p> <p>Any control server will support notification and listeners are added through the service proxy of the control server.</p> <p>A control server that wants to be notified by an event needs to implement the EventInterface in the Proxy and in the Controller.</p> <p>Classes:</p> Name Description <code>EVENT_ID</code> <p>An identifier for the type of event.</p> <code>Event</code> <p>An event that is generated by a control server.</p> <code>EventInterface</code> <p>A dynamic interface for handling events.</p> <code>Listeners</code> <p>A class for managing and notifying registered listeners.</p>"},{"location":"api/listener/#egse.listener.EVENT_ID","title":"EVENT_ID","text":"<p>               Bases: <code>IntEnum</code></p> <p>An identifier for the type of event.</p> <p>Attributes:</p> Name Type Description <code>ALL</code> <p>Match all events.</p> <code>SETUP</code> <p>An event for a new or updated Setup.</p>"},{"location":"api/listener/#egse.listener.EVENT_ID.ALL","title":"ALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ALL = 0\n</code></pre> <p>Match all events.</p>"},{"location":"api/listener/#egse.listener.EVENT_ID.SETUP","title":"SETUP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SETUP = 1\n</code></pre> <p>An event for a new or updated Setup.</p>"},{"location":"api/listener/#egse.listener.Event","title":"Event","text":"<pre><code>Event(event_id, context)\n</code></pre> <p>An event that is generated by a control server.</p>"},{"location":"api/listener/#egse.listener.EventInterface","title":"EventInterface","text":"<p>A dynamic interface for handling events.</p> <p>This interface defines a single method, 'handle_event', which is intended to be implemented by classes that want to handle specific types of events.</p> <p>Use this interface as a mixin for classes (Proxy/Controller) that implement this <code>handle_event</code> method.</p> <p>Methods:</p> Name Description <code>handle_event</code> <p>Handles the specified event.</p>"},{"location":"api/listener/#egse.listener.EventInterface.handle_event","title":"handle_event","text":"<pre><code>handle_event(event)\n</code></pre> <p>Handles the specified event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>An instance of the Event class representing the event to be handled.</p> required"},{"location":"api/listener/#egse.listener.Listeners","title":"Listeners","text":"<pre><code>Listeners()\n</code></pre> <p>A class for managing and notifying registered listeners.</p> <p>This class provides methods to add, remove, and notify listeners of events.</p> <p>Methods:</p> Name Description <code>add_listener</code> <p>Adds a new listener to the registered listeners.</p> <code>get_listener_names</code> <p>Returns a list with the names of the registered listeners.</p> <code>notify_listener</code> <p>Notifies a registered listener fro the given event.</p> <code>notify_listeners</code> <p>Notifies all registered listeners of a specific event.</p> <code>remove_listener</code> <p>Removes a listener from the registered listeners.</p>"},{"location":"api/listener/#egse.listener.Listeners.add_listener","title":"add_listener","text":"<pre><code>add_listener(listener)\n</code></pre> <p>Adds a new listener to the registered listeners.</p> <p>The listener argument dictionary is expected to have at least the following key:values pairs:</p> <ul> <li>'name': the name or identifier of the listener</li> <li>'proxy': a Proxy object that will be used for notifying the service</li> </ul> <p>Parameters:</p> Name Type Description Default <code>listener</code> <code>dict</code> <p>A dictionary with properties of the listener, including 'name' and 'proxy'.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the listener already exists.</p>"},{"location":"api/listener/#egse.listener.Listeners.get_listener_names","title":"get_listener_names","text":"<pre><code>get_listener_names()\n</code></pre> <p>Returns a list with the names of the registered listeners.</p>"},{"location":"api/listener/#egse.listener.Listeners.notify_listener","title":"notify_listener","text":"<pre><code>notify_listener(name, listener, event)\n</code></pre> <p>Notifies a registered listener fro the given event.</p>"},{"location":"api/listener/#egse.listener.Listeners.notify_listeners","title":"notify_listeners","text":"<pre><code>notify_listeners(event)\n</code></pre> <p>Notifies all registered listeners of a specific event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>An instance of the Event class representing the event to be broadcasted.</p> required Note <p>The 'handle_event' method is called on each listener's proxy object to process the event.</p>"},{"location":"api/listener/#egse.listener.Listeners.remove_listener","title":"remove_listener","text":"<pre><code>remove_listener(listener)\n</code></pre> <p>Removes a listener from the registered listeners.</p> <p>Parameters:</p> Name Type Description Default <code>listener</code> <code>dict</code> <p>A dictionary representing the listener to be  removed. It should contain a 'name' key.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the 'name' key is not present in the listener  argument or if the specified listener is not registered.</p>"},{"location":"api/metrics/","title":"egse.metrics","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/metrics/#egse.metrics","title":"egse.metrics","text":"<p>Functions:</p> Name Description <code>define_metrics</code> <p>Creates a metrics dictionary from the telemetry dictionary.</p> <code>update_metrics</code> <p>Updates the metrics parameters with the values from the updates dictionary.</p>"},{"location":"api/metrics/#egse.metrics.define_metrics","title":"define_metrics","text":"<pre><code>define_metrics(\n    origin, dashboard=None, use_site=False, setup=None\n)\n</code></pre> <p>Creates a metrics dictionary from the telemetry dictionary.</p> <p>Read the metric names and their descriptions from the telemetry dictionary, and create Prometheus gauges based on this information.</p> <p>If <code>dashboard</code> is not provided, all telemetry parameters for the given origin will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>str</code> <p>Storage mnemonics for the requested metrics</p> required <code>dashboard</code> <code>str</code> <p>Restrict the metrics selection to those that are defined for the given dashboard. You can select        all dashboards with <code>dashboard='*'</code>.</p> <code>None</code> <code>use_site</code> <code>bool</code> <p>Indicate whether the prefixes of the new HK names are TH-specific</p> <code>False</code> <code>setup</code> <code>Optional[Setup]</code> <p>Setup.</p> <code>None</code>"},{"location":"api/metrics/#egse.metrics.update_metrics","title":"update_metrics","text":"<pre><code>update_metrics(metrics, updates)\n</code></pre> <p>Updates the metrics parameters with the values from the updates dictionary.</p> <p>Only the metrics parameters for which the names are keys in the given updates dict are actually updated. Other metrics remain untouched.</p> <p>The functions log a warning when the updates dict contains a name which is not known as a metrics parameter.</p> <p>Parameters:</p> Name Type Description Default <code>metrics</code> <code>dict</code> <p>Metrics dictionary previously defined with the define_metrics function</p> required <code>updates</code> <code>dict</code> <p>Dictionary with key=metrics name and value is the to-be-updated value</p> required"},{"location":"api/mixin/","title":"egse.mixin","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/mixin/#egse.mixin","title":"egse.mixin","text":"<p>This module defines Mixin classes that can be used for adding methods and properties to classes without strict inheritance.</p> Warning <p>Be careful, some of the Mixin classes require certain attributes to be defined in the outer subclass. Read the docstrings carefully to understand what is needed.</p> <p>Classes:</p> Name Description <code>CommandType</code> <p>The type of the command, i.e. read, write, or transaction.</p> <code>DynamicCommandMixin</code> <p>This Mixin class defines the functionality to dynamically call specific instrument commands</p> <p>Functions:</p> Name Description <code>add_cr_lf</code> <p>Add a carriage return and line feed to the given command string, if not added yet.</p> <code>add_eot</code> <p>Add an end-of-transmission EOT (ASCII code 0x04) to the command string.</p> <code>add_etx</code> <p>Add an end-of-text ETX (ASCII code 0x03) to the command string.</p> <code>add_lf</code> <p>Add a line feed to the given command string, if not added yet.</p> <code>dynamic_command</code> <p>Convert an interface method into a dynamic command.</p>"},{"location":"api/mixin/#egse.mixin.CommandType","title":"CommandType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The type of the command, i.e. read, write, or transaction.</p>"},{"location":"api/mixin/#egse.mixin.DynamicClientCommandMixin","title":"DynamicClientCommandMixin","text":"<p>This mixin class contains functionality to forward a device command from a client Proxy class to its control server.</p> <p>Note</p> <p>This mixin overrides the <code>__getattribute__</code> method!</p>"},{"location":"api/mixin/#egse.mixin.DynamicCommandMixin","title":"DynamicCommandMixin","text":"<pre><code>DynamicCommandMixin()\n</code></pre> <p>This Mixin class defines the functionality to dynamically call specific instrument commands from methods that are defined in the Interface classes for device Controllers.</p> <p>The mixin uses the <code>self.transport</code> instance variables that shall be defined by the Controller subclass. The <code>self.transport</code> shall be a DeviceTransport object providing the methods to read, write, and query an instrument.</p> <p>Note</p> <p>This mixin overrides the <code>__getattribute__</code> method!</p> <p>Note</p> <p>This mixin class shall only be inherited from a Controller class that defines the <code>self.transport</code> attribute.</p> <p>Methods:</p> Name Description <code>create_command_string</code> <p>Creates a command string that is understood by the instrument. This can be an SCPI</p> <code>handle_dynamic_command</code> <p>Creates a command wrapper calling the appropriate transport methods that are associated</p>"},{"location":"api/mixin/#egse.mixin.DynamicCommandMixin.create_command_string","title":"create_command_string  <code>staticmethod</code>","text":"<pre><code>create_command_string(func, template_str, *args, **kwargs)\n</code></pre> <p>Creates a command string that is understood by the instrument. This can be an SCPI command or a specific proprietary command string. The <code>cmd_str</code> can contain placeholders similar to what is used in string formatting.</p> <p>As an example, we have a function with two positional arguments 'a', and 'b' and one keyword argument flag:</p> <pre><code>def func(a, b, flag=True):\n    pass\n</code></pre> <p>We have the following template string: <code>CREATE:FUN:${a} ${b} [${flag}]</code>.</p> <p>When we call the function as follows: <code>func(\"TEMP\", 23)</code>, we would then expect the returned string to be \"CREATE:FUN:TEMP 23 [True]\"</p> <pre><code>DynamicCommandMixin.create_command_string(func, template, \"TEMP\", 23)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>a function or method that provides the signature</p> required <code>template_str</code> <code>str</code> <p>a template for the command</p> required <code>args</code> <code>tuple</code> <p>positional arguments that will be used in the command string</p> <code>()</code> <code>kwargs</code> <code>dict</code> <p>keywords arguments that will be used in the command string</p> <code>{}</code>"},{"location":"api/mixin/#egse.mixin.DynamicCommandMixin.handle_dynamic_command","title":"handle_dynamic_command","text":"<pre><code>handle_dynamic_command(attr)\n</code></pre> <p>Creates a command wrapper calling the appropriate transport methods that are associated with the interface definition as passed into this method with the attr argument.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>Callable</code> <p>The interface method that is decorated as a dynamic_command.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Command wrapper with the read or write command, depending on the decorators used for that method in the corresponding Interface class.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the command is not listed in the YAML file and/or has not been listed.</p>"},{"location":"api/mixin/#egse.mixin.add_cr_lf","title":"add_cr_lf","text":"<pre><code>add_cr_lf(cmd_string)\n</code></pre> <p>Add a carriage return and line feed to the given command string, if not added yet.</p> <p>Parameters:</p> Name Type Description Default <code>cmd_string</code> <code>str</code> <p>Command string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Given command string with a carriage return and line feed appended (if not present yet).</p>"},{"location":"api/mixin/#egse.mixin.add_eot","title":"add_eot","text":"<pre><code>add_eot(cmd_string)\n</code></pre> <p>Add an end-of-transmission EOT (ASCII code 0x04) to the command string.</p> <p>Parameters:</p> Name Type Description Default <code>cmd_string</code> <code>str</code> <p>the unprocessed command string</p> required <p>Returns:</p> Type Description <code>str</code> <p>The command string with the EOT character appended.</p>"},{"location":"api/mixin/#egse.mixin.add_etx","title":"add_etx","text":"<pre><code>add_etx(cmd_string)\n</code></pre> <p>Add an end-of-text ETX (ASCII code 0x03) to the command string.</p> <p>Parameters:</p> Name Type Description Default <code>cmd_string</code> <code>str</code> <p>the unprocessed command string</p> required <p>Returns:</p> Type Description <code>str</code> <p>The command string with the ETX character appended.</p>"},{"location":"api/mixin/#egse.mixin.add_lf","title":"add_lf","text":"<pre><code>add_lf(cmd_string)\n</code></pre> <p>Add a line feed to the given command string, if not added yet.</p> <p>Parameters:</p> Name Type Description Default <code>cmd_string</code> <code>str</code> <p>Command string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Given command string with a line feed appended (if not present yet).</p>"},{"location":"api/mixin/#egse.mixin.dynamic_command","title":"dynamic_command","text":"<pre><code>dynamic_command(\n    *,\n    cmd_type,\n    cmd_string=None,\n    process_response=None,\n    process_cmd_string=None,\n    process_kwargs=None,\n    use_format=False,\n    pre_cmd=None,\n    post_cmd=None,\n)\n</code></pre> <p>Convert an interface method into a dynamic command.</p> <p>The arguments define the type of command and how the response shall be processed.</p> <p>The command types 'write', 'query', and 'transaction' must be accompanied by a <code>cmd_string</code> argument that defines the formatting of the eventual command string that will be passed to the transport functions. The <code>cmd_string</code> is a template string that contains <code>$</code>-based substitutions for the function arguments. When you specify the <code>use_format=True</code> keyword, the <code>cmd_string</code> will be formatted using the format() function instead of the template substitution. The format option is less secure, but provides the functionality to format the arguments.</p> <p>A template string looks like:</p> <pre><code>cmd_string=\"CREATE:SENS:TEMP ${name} ${type} default=${default}\"\n</code></pre> <p>The same <code>cmd_string</code> as a format option:</p> <pre><code>cmd_string=\"CREATE:SENS:TEMP {name} {type} default={default:0.4f}\"\nuse_format=True\n</code></pre> <p>The process_response and process_cmd_string keywords allow you to specify a pure function to process the response before it is returned, and to process the cmd_string before it is sent to the transport function.</p> <p>The <code>pre_cmd</code> and <code>post_cmd</code> keywords specify a callable/function to be executed before and/or after the actual command was executed (i.e. send to the device). These functions are called with specific keyword arguments that allow additional device interaction and response processing. The <code>pre_cmd</code> function is called with the keyword argument <code>transport=</code> which passes the device transport. This allows the function to interact with the device again through the methods defined by the DeviceTransport interface. The <code>pre_cmd</code> function must not return anything. The <code>post_cmd</code> function is called with the keyword arguments <code>transport=</code> and <code>response=</code>. The response argument contains the response from the command that was previously sent to the device. The <code>post_cmd</code> function can use this response to parse its content and act against this content, although possible, it is usually not a good idea to alter the content of the response argument. The <code>post_cmd</code> function shall return (i.e. pass through) the response.</p> <p>This decorator can add the following static attributes to the method:</p> <ul> <li><code>__dynamic_interface</code></li> <li><code>__read_command</code>, <code>__write_command</code>, <code>__query_command</code>, <code>__transaction_command</code></li> <li><code>__cmd_string</code></li> <li><code>__process_response</code></li> <li><code>__process_cmd_string</code></li> <li><code>__use_format</code></li> <li><code>__pre_cmd</code></li> <li><code>__post_cmd</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>cmd_type</code> <code>str</code> <p>one of 'read', 'write', 'query', or 'transaction' [required keyword]</p> required <code>cmd_string</code> <code>str</code> <p>format string for the generation of the instrument command</p> <code>None</code> <code>process_response</code> <code>Callable</code> <p>function to process the response</p> <code>None</code> <code>process_cmd_string</code> <code>Callable</code> <p>function to process the command string after substitution</p> <code>None</code> <code>process_kwargs</code> <code>Callable</code> <p>function to expand the kwargs after substitution</p> <code>None</code> <code>use_format</code> <code>bool</code> <p>use string formatting instead of string templates</p> <code>False</code> <code>pre_cmd</code> <code>Callable</code> <p>the function to execute before the command is executed</p> <code>None</code> <code>post_cmd</code> <code>Callable</code> <p>the function to execute after the command is executed</p> <code>None</code>"},{"location":"api/mixin/#egse.mixin.expand_kwargs","title":"expand_kwargs","text":"<pre><code>expand_kwargs(kwargs)\n</code></pre> <p>Expand keyword arguments and their values as 'key=value' separated by spaces.</p>"},{"location":"api/monitoring/","title":"egse.monitoring","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/monitoring/#egse.monitoring","title":"egse.monitoring","text":"<p>Classes:</p> Name Description <code>Monitoring</code> <p>Context manager to monitor processes.</p> <p>Functions:</p> Name Description <code>monitoring</code> <p>Monitor the status of a control server on hostname:port.</p>"},{"location":"api/monitoring/#egse.monitoring.Monitoring","title":"Monitoring","text":"<pre><code>Monitoring(\n    endpoint,\n    subscribe=None,\n    use_pickle=True,\n    callback=None,\n    timeout=None,\n)\n</code></pre> <p>Context manager to monitor processes.</p> <p>Most control servers publish status information on their <code>MONITORING_PORT</code>.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>the endpoint to which the service will connect</p> required <code>subscribe</code> <code>Tuple[str]</code> <p>subscription string, default is 'ALL'</p> <code>None</code> <code>use_pickle</code> <code>bool</code> <p>use pickle to process responses, currently always True</p> <code>True</code> <code>callback</code> <code>Callable</code> <p>function that is called to process the response</p> <code>None</code> <code>timeout</code> <code>float</code> <p>stop monitoring after timeout seconds</p> <code>None</code>"},{"location":"api/monitoring/#egse.monitoring.monitoring","title":"monitoring","text":"<pre><code>monitoring(\n    hostname,\n    port,\n    subscribe=None,\n    use_pickle=True,\n    list_names=False,\n    callback=None,\n)\n</code></pre> <p>Monitor the status of a control server on hostname:port.</p> <p>The port number shall correspond to the port number on which the control server is publishing status information.</p>"},{"location":"api/observer/","title":"egse.observer","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/observer/#egse.observer","title":"egse.observer","text":"<p>This module implements a standard Observer &lt;-&gt; Observable pattern.</p> <p>Classes:</p> Name Description <code>Observable</code> <p>The object that sends out notifications to the observers.</p> <code>Observer</code> <p>The observer that needs to take action when notified.</p>"},{"location":"api/observer/#egse.observer.Observable","title":"Observable","text":"<pre><code>Observable()\n</code></pre> <p>The object that sends out notifications to the observers.</p>"},{"location":"api/observer/#egse.observer.Observer","title":"Observer","text":"<p>               Bases: <code>ABC</code></p> <p>The observer that needs to take action when notified.</p>"},{"location":"api/obsid/","title":"egse.obsid","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/obsid/#egse.obsid","title":"egse.obsid","text":"<p>An ObservationIdentifier or OBSID is a unique identifier for an observation or test.</p> <p>Each observation or test needs a unique identification that can be used as a key in a database or in a filename for test data etc.</p> <p>Classes:</p> Name Description <code>ObservationIdentifier</code> <p>A unique identifier for each observation or test.</p> <p>Functions:</p> Name Description <code>obsid_from_storage</code> <p>Return the name of the folder for the given obsid in the 'obs' sub-folder of data_dir.</p>"},{"location":"api/obsid/#egse.obsid.ObservationIdentifier","title":"ObservationIdentifier","text":"<pre><code>ObservationIdentifier(\n    lab_id=None, setup_id=None, test_id=None\n)\n</code></pre> <p>A unique identifier for each observation or test.</p> <pre><code>setup_id: the identifier for the setup that is used for the test\ntest_id: the test identifier or test number\n</code></pre> <p>Methods:</p> Name Description <code>create_id</code> <p>Creates a string representation of the observation identifier.</p>"},{"location":"api/obsid/#egse.obsid.ObservationIdentifier.create_id","title":"create_id","text":"<pre><code>create_id(*, order=LAB_SETUP_TEST, camera_name=None)\n</code></pre> <p>Creates a string representation of the observation identifier.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>int</code> <p>the order in which the parts are concatenated</p> <code>LAB_SETUP_TEST</code> <code>camera_name</code> <code>str</code> <p>if a camera name is given, it will be appended in lower case</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the obsid with or without camera name attached.</p>"},{"location":"api/obsid/#egse.obsid.obsid_from_storage","title":"obsid_from_storage","text":"<pre><code>obsid_from_storage(\n    obsid, data_dir, site_id=None, camera_name=None\n)\n</code></pre> <p>Return the name of the folder for the given obsid in the 'obs' sub-folder of data_dir.</p> <p>For the oldest observations, the obsid used in the directory structure and filenames was of the format TEST_LAB_SETUP.  All files in this folder also have the obsid in that format in their name.  At some point, we decided to change this to TEST_LAB, but we still need to be able to re-process the old data (with the setup ID in the names of the directories and files).</p> <p>For newer observations (&gt;= 2023.6.0+CGSE), the camera name is appended to the folder name and also included in the filenames in that folder.</p> <p>Parameters:</p> Name Type Description Default <code>obsid</code> <code>Union[ObservationIdentifier, str, int]</code> <p>Observation identifier.  This can be an ObservationIdentifier object, a string in format TEST_LAB or TEST_LAB_SETUP, or an integer representing the test ID. In this last case, the site id is taken from the Settings.</p> required <code>data_dir</code> <code>str</code> <p>root folder in which the observations are stored. This folder shall have a sub-folder 'obs'.</p> required <code>site_id</code> <code>str</code> <p>a site id like 'CSL1' or 'IAS', when <code>None</code>, the <code>SITE.ID</code> from the Settings will be used</p> <code>None</code> <code>camera_name</code> <code>str</code> <p>if not None, append the camera name to the result</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The name of the folder for the given obsid in the 'obs' sub-folder of data_dir.</p>"},{"location":"api/persistence/","title":"egse.persistence","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/persistence/#egse.persistence","title":"egse.persistence","text":"<p>Classes:</p> Name Description <code>PersistenceLayer</code> <p>The Persistence Layer implements the CRUD paradigm for storing data.</p>"},{"location":"api/persistence/#egse.persistence.PersistenceLayer","title":"PersistenceLayer","text":"<p>               Bases: <code>ABC</code></p> <p>The Persistence Layer implements the CRUD paradigm for storing data.</p> <p>Methods:</p> Name Description <code>close</code> <p>Closes the resource.</p> <code>create</code> <p>Creates an entry in the persistence store.</p> <code>delete</code> <p>Deletes the entry for index <code>idx</code> from the persistence store.</p> <code>exists</code> <p>Returns True if the resource exists, False otherwise.</p> <code>get_filepath</code> <p>If this persistence class is file based, return its file path, otherwise return None.</p> <code>open</code> <p>Opens the resource.</p> <code>read</code> <p>Returns a list of all entries in the persistence store.</p> <code>update</code> <p>Updates the entry for index <code>idx</code> in the persistence store.</p> <p>Attributes:</p> Name Type Description <code>extension</code> <p>The file extension to use for this persistence type.</p>"},{"location":"api/persistence/#egse.persistence.PersistenceLayer.extension","title":"extension  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extension = 'no_ext'\n</code></pre> <p>The file extension to use for this persistence type.</p>"},{"location":"api/persistence/#egse.persistence.PersistenceLayer.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close()\n</code></pre> <p>Closes the resource.</p>"},{"location":"api/persistence/#egse.persistence.PersistenceLayer.create","title":"create  <code>abstractmethod</code>","text":"<pre><code>create(data)\n</code></pre> <p>Creates an entry in the persistence store.</p>"},{"location":"api/persistence/#egse.persistence.PersistenceLayer.delete","title":"delete  <code>abstractmethod</code>","text":"<pre><code>delete(idx)\n</code></pre> <p>Deletes the entry for index <code>idx</code> from the persistence store.</p>"},{"location":"api/persistence/#egse.persistence.PersistenceLayer.exists","title":"exists  <code>abstractmethod</code>","text":"<pre><code>exists()\n</code></pre> <p>Returns True if the resource exists, False otherwise.</p>"},{"location":"api/persistence/#egse.persistence.PersistenceLayer.get_filepath","title":"get_filepath  <code>abstractmethod</code>","text":"<pre><code>get_filepath()\n</code></pre> <p>If this persistence class is file based, return its file path, otherwise return None.</p>"},{"location":"api/persistence/#egse.persistence.PersistenceLayer.open","title":"open  <code>abstractmethod</code>","text":"<pre><code>open(mode=None)\n</code></pre> <p>Opens the resource.</p>"},{"location":"api/persistence/#egse.persistence.PersistenceLayer.read","title":"read  <code>abstractmethod</code>","text":"<pre><code>read(select=None)\n</code></pre> <p>Returns a list of all entries in the persistence store.</p> <p>The list can be filtered based on a selection from the <code>select</code> argument which should be a Callable object.</p> <p>Parameters:</p> Name Type Description Default <code>select</code> <code>Callable</code> <p>a filter function to narrow down the list of all entries.</p> <code>None</code>"},{"location":"api/persistence/#egse.persistence.PersistenceLayer.update","title":"update  <code>abstractmethod</code>","text":"<pre><code>update(idx, data)\n</code></pre> <p>Updates the entry for index <code>idx</code> in the persistence store.</p>"},{"location":"api/plugin/","title":"egse.plugin","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/plugin/#egse.plugin","title":"egse.plugin","text":"<p>This module provides function to load plugins and settings from entry-points.</p> <p>Classes:</p> Name Description <code>HierarchicalEntryPoints</code> <p>Functions:</p> Name Description <code>entry_points</code> <p>Returns a set with all entry-points for the given group name.</p> <code>get_file_infos</code> <p>Returns a dictionary with location and filename of all the entries found for</p> <code>load_plugins</code> <p>Returns a dictionary with plugins loaded. The keys are the names of the entry-points,</p>"},{"location":"api/plugin/#egse.plugin.HierarchicalEntryPoints","title":"HierarchicalEntryPoints","text":"<pre><code>HierarchicalEntryPoints(base_group)\n</code></pre> <p>Methods:</p> Name Description <code>get_all_entry_points</code> <p>Get all entry points as a flat list.</p> <code>get_all_groups</code> <p>Get all discovered group names.</p> <code>get_by_subgroup</code> <p>Get entry points from a specific subgroup.</p> <code>get_by_type</code> <p>Get entry points by type (assuming type is the subgroup name).</p>"},{"location":"api/plugin/#egse.plugin.HierarchicalEntryPoints.get_all_entry_points","title":"get_all_entry_points","text":"<pre><code>get_all_entry_points()\n</code></pre> <p>Get all entry points as a flat list.</p>"},{"location":"api/plugin/#egse.plugin.HierarchicalEntryPoints.get_all_groups","title":"get_all_groups","text":"<pre><code>get_all_groups()\n</code></pre> <p>Get all discovered group names.</p>"},{"location":"api/plugin/#egse.plugin.HierarchicalEntryPoints.get_by_subgroup","title":"get_by_subgroup","text":"<pre><code>get_by_subgroup(subgroup=None)\n</code></pre> <p>Get entry points from a specific subgroup.</p>"},{"location":"api/plugin/#egse.plugin.HierarchicalEntryPoints.get_by_type","title":"get_by_type","text":"<pre><code>get_by_type(entry_type)\n</code></pre> <p>Get entry points by type (assuming type is the subgroup name).</p>"},{"location":"api/plugin/#egse.plugin.entry_points","title":"entry_points","text":"<pre><code>entry_points(group)\n</code></pre> <p>Returns a set with all entry-points for the given group name.</p> <p>When the name is not known as an entry-point group, an empty set will be returned.</p>"},{"location":"api/plugin/#egse.plugin.get_file_infos","title":"get_file_infos","text":"<pre><code>get_file_infos(entry_point)\n</code></pre> <p>Returns a dictionary with location and filename of all the entries found for the given entry-point name.</p> <p>The entry-points are interpreted as follows: <code>&lt;name&gt; = \"&lt;module&gt;:&lt;filename&gt;\"</code> where</p> <ul> <li><code>&lt;name&gt;</code> is the name of the entry-point given in the pyproject.toml file</li> <li><code>&lt;module&gt;</code> is a valid module name that can be imported and from which the location can be determined.</li> <li><code>&lt;filename&gt;</code> is the name of the target file, e.g. a YAML file</li> </ul> <p>As an example, for the <code>cgse-common</code> settings, the following entry in the <code>pyproject.toml</code>:</p> <pre><code>[project.entry-points.\"cgse.settings\"]\ncgse-common = \"cgse_common:settings.yaml\"\n</code></pre> <p>Note that the module name for this entry point has an underscore instead of a dash.</p> Return <p>A dictionary with the entry point name as the key and a tuple (location, filename) as the value.</p>"},{"location":"api/plugin/#egse.plugin.load_plugins","title":"load_plugins","text":"<pre><code>load_plugins(entry_point)\n</code></pre> <p>Returns a dictionary with plugins loaded. The keys are the names of the entry-points, the values are the loaded modules or objects.</p> Note <p>When an entry point cannot be loaded, an error is logged and the value for that entry point in the returned dictionary will be None.</p>"},{"location":"api/process/","title":"egse.process","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/process/#egse.process","title":"egse.process","text":"<p>This module provides functions and classes to work with processes and sub-processes.</p> <p>We combine two great packages, the <code>subprocess</code> and the <code>psutils</code> packages, to provide a simplified, robust and user-friendly interface to work with sub-processes. The classes and functions are optimized to work with processes within the framework of the <code>cgse</code>, so we do not intend to be fully generic. If you need that, we recommend to use the <code>subprocess</code> and <code>psutil</code> packages directly.</p> <p>The main class provided is the <code>SubProcess</code> which by default, starts a sub-process in the background and detached from the parent process. That means there is no communication between the parent and the subprocess through pipes. Most (if not all) processes in the <code>cgse</code> framework communicate with ZeroMQ messages in different protocols like REQ-REP, PUSH-PULL and ROUTER-DEALER</p> <p>Another useful class is the <code>ProcessStatus</code>. This class provides status information like memory and CPU usage for the running process. Additionally, it will generate and update metrics that can be queried by the Prometheus timeseries database.</p> <p>Classes:</p> Name Description <code>ProcessStatus</code> <p>The ProcessStatus is basically a dataclass that contains the status information of a running</p> <code>SubProcess</code> <p>A SubProcess that is usually started by the ProcessManager.</p> <p>Functions:</p> Name Description <code>get_process_info</code> <p>Loops over all running processes and tries to match each item in 'items' to the command line</p> <code>get_processes</code> <p>Get current processes with optional filtering.</p> <code>is_process_running</code> <p>Check if there is any running process that contains the given items in its</p> <code>list_processes</code> <p>Returns and optionally prints the processes that match the given criteria in items.</p> <code>list_zombies</code> <p>Returns a list of zombie processes.</p>"},{"location":"api/process/#egse.process.ProcessStatus","title":"ProcessStatus","text":"<pre><code>ProcessStatus(*, metrics_prefix=None)\n</code></pre> <p>The ProcessStatus is basically a dataclass that contains the status information of a running process.</p> <p>The available information is the following:</p> <ul> <li>pid: the process identifier</li> <li>uptime: the process up-time as a floating point number expressed in seconds</li> <li>uuid: the UUID1 for this process</li> <li>memory info: memory information on the process</li> <li>cpu usage, percentage and count (number of physical cores)</li> </ul> <p>The status will always be updated before returning or printing.</p> <p>Parameters:</p> Name Type Description Default <code>metrics_prefix</code> <code>Optional[str]</code> <p>the prefix that identifies the process for which these metrics are gathered.</p> <code>None</code> <p>Methods:</p> Name Description <code>as_dict</code> <p>Returns all process information as a dictionary.</p> <code>update</code> <p>Updates those values that change during execution, like memory usage, number of</p> <code>update_metrics</code> <p>Updates the metrics that are taken from the psutils module.</p>"},{"location":"api/process/#egse.process.ProcessStatus.as_dict","title":"as_dict","text":"<pre><code>as_dict()\n</code></pre> <p>Returns all process information as a dictionary.</p> <p>This runs the <code>update()</code> method first to bring the numbers up-to-date.</p>"},{"location":"api/process/#egse.process.ProcessStatus.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Updates those values that change during execution, like memory usage, number of connections, ...</p> <p>This call will also update the metrics!</p> <p>Returns:</p> Type Description <code>ProcessStatus</code> <p>the ProcessStatus object, self.</p>"},{"location":"api/process/#egse.process.ProcessStatus.update_metrics","title":"update_metrics","text":"<pre><code>update_metrics()\n</code></pre> <p>Updates the metrics that are taken from the psutils module.</p> <p>The following metrics are never updated since they are not changed during a process execution:</p> <ul> <li>PSUTIL_NUMBER_OF_CPU</li> <li>PSUTIL_PID</li> </ul>"},{"location":"api/process/#egse.process.SubProcess","title":"SubProcess","text":"<pre><code>SubProcess(\n    name,\n    cmd,\n    args=None,\n    shell=False,\n    stdout=DEVNULL,\n    stderr=DEVNULL,\n)\n</code></pre> <p>A SubProcess that is usually started by the ProcessManager.</p> <p>Example:</p> <pre><code>proc = SubProcess(\"MyApp\", [sys.executable, \"-m\", \"egse.&lt;module&gt;\"])\nproc.execute()\n</code></pre> <p>Methods:</p> Name Description <code>execute</code> <p>Execute the sub-process.</p> <code>exists</code> <p>Checks if the sub-process exists by checking if its process ID exists.</p> <code>is_running</code> <p>Check if this process is still running.</p> <code>quit</code> <p>Send a request to quit to the process.</p> <code>reap_children</code> <p>Tries hard to terminate and ultimately kill all the children of this process.</p> <code>returncode</code> <p>Check if the sub-process is terminated and return its return code or None when the process</p>"},{"location":"api/process/#egse.process.SubProcess.execute","title":"execute","text":"<pre><code>execute()\n</code></pre> <p>Execute the sub-process.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the process could be started, False on error.</p>"},{"location":"api/process/#egse.process.SubProcess.exists","title":"exists","text":"<pre><code>exists()\n</code></pre> <p>Checks if the sub-process exists by checking if its process ID exists.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the sub-process exists.</p>"},{"location":"api/process/#egse.process.SubProcess.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> <p>Check if this process is still running.</p> <ul> <li>checks if process exists</li> <li>checks if process is not a zombie and is not dead</li> </ul> <p>Returns:</p> Type Description <code>bool</code> <p>True if the process is running.</p>"},{"location":"api/process/#egse.process.SubProcess.quit","title":"quit","text":"<pre><code>quit()\n</code></pre> <p>Send a request to quit to the process.</p> <p>This will first send a SIGTERM signal to the process, if that fails, a SIGKILL will be sent.</p> <p>Returns:</p> Type Description <code>int</code> <p>0 if the process and its sub-processes are all terminated. Will return &gt; 0 to indicate the number of processes that survived the SIGKILL.</p>"},{"location":"api/process/#egse.process.SubProcess.reap_children","title":"reap_children","text":"<pre><code>reap_children(timeout=3)\n</code></pre> <p>Tries hard to terminate and ultimately kill all the children of this process.</p> <p>This will first send a SIGTERM signal to the process, if that fails, a SIGKILL will be sent.</p> <p>Returns:</p> Type Description <code>int</code> <p>0 if the process and its sub-processes are all terminated. Will return &gt; 0 to indicate the number of processes that survived the SIGKILL.</p>"},{"location":"api/process/#egse.process.SubProcess.returncode","title":"returncode","text":"<pre><code>returncode()\n</code></pre> <p>Check if the sub-process is terminated and return its return code or None when the process is still running.</p>"},{"location":"api/process/#egse.process.get_process_info","title":"get_process_info","text":"<pre><code>get_process_info(\n    items, contains=True, case_sensitive=False\n)\n</code></pre> <p>Loops over all running processes and tries to match each item in 'items' to the command line of the process. Any process where all 'items' can be matched will end up in the response.</p> <p>Returns a list with the process info (PID, cmdline, create_time) for any processes where all 'items' match the process command line. An empty list is returned when not 'all the items' match for any of the processes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_process_info(items=[\"feesim\"])\n[\n    {\n        'pid': 10166,\n        'cmdline': [\n            '/Library/Frameworks/Python.framework/Versions/3.8/Resources/Python.app/Contents/MacOS/Python',\n            '/Users/rik/git/plato-common-egse/venv38/bin/feesim',\n            'start',\n            '--zeromq'\n        ],\n        'create_time': 1664898231.915995\n    }\n]\n</code></pre> <pre><code>&gt;&gt;&gt; get_process_info(items=[\"dpu_cs\", \"--zeromq\"])\n[\n    {\n        'pid': 11595,\n        'cmdline': [\n            '/Library/Frameworks/Python.framework/Versions/3.8/Resources/Python.app/Contents/MacOS/Python',\n            '/Users/rik/git/plato-common-egse/venv38/bin/dpu_cs',\n            'start',\n            '--zeromq'\n        ],\n        'create_time': 1664898973.542281\n    }\n]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[str] | str</code> <p>a string or a list of strings that should match command line items</p> required <code>contains</code> <code>bool</code> <p>if True, the match is done with 'in' otherwise '=='</p> <code>True</code> <code>case_sensitive</code> <code>bool</code> <p>if True, the match shall be case-sensitive</p> <code>False</code> <p>Returns:</p> Type Description <code>List</code> <p>A list of process info entries.</p>"},{"location":"api/process/#egse.process.get_processes","title":"get_processes","text":"<pre><code>get_processes(filter_func=None)\n</code></pre> <p>Get current processes with optional filtering.</p> <p>Parameters:</p> Name Type Description Default <code>filter_func</code> <code>Callable</code> <p>a filter function for filtering the processes</p> <code>None</code> <p>Returns:</p> Type Description <code>list[ProcessInfo]</code> <p>A list of process info dataclasses</p>"},{"location":"api/process/#egse.process.is_process_running","title":"is_process_running","text":"<pre><code>is_process_running(\n    items,\n    contains=True,\n    case_sensitive=False,\n    as_list=False,\n)\n</code></pre> <p>Check if there is any running process that contains the given items in its commandline.</p> <p>Loops over all running processes and tries to match all items in the 'items' argument to the command line of the process. If all 'items' can be matched to a process, the function returns the PID of that process.</p> <p>By default, only the first matching process PID is returned. If <code>as_list=True</code> then all mathing process PIDs are returned as a list.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[str] | str</code> <p>a string or a list of strings that should match command line parts</p> required <code>contains</code> <code>bool</code> <p>if True, the match is done with 'in' otherwise '==' [default: True]</p> <code>True</code> <code>case_sensitive</code> <code>bool</code> <p>if True, the match shall be case-sensitive [default: False]</p> <code>False</code> <code>as_list</code> <code>bool</code> <p>return the PID of all matching processes as a list [default: False]</p> <code>False</code> <p>Returns:</p> Type Description <code>int | List[int]</code> <p>The PID(s) if there exists a running process with the given items, 0 or [] otherwise.</p>"},{"location":"api/process/#egse.process.kill_process","title":"kill_process","text":"<pre><code>kill_process(pid, force=False)\n</code></pre> <p>Safely kill a process. Return True if process could be killed, False otherwise.</p> <p>If the process doesn't exist, or you have don't the right permission to kill the process, False is returned.</p>"},{"location":"api/process/#egse.process.list_processes","title":"list_processes","text":"<pre><code>list_processes(\n    items,\n    contains=True,\n    case_sensitive=False,\n    verbose=False,\n)\n</code></pre> <p>Returns and optionally prints the processes that match the given criteria in items.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[str] | str</code> <p>a string or a list of strings that should match command line parts</p> required <code>contains</code> <code>bool</code> <p>if True, the match is done with 'in' otherwise '==' [default: True]</p> <code>True</code> <code>case_sensitive</code> <code>bool</code> <p>if True, the match shall be case-sensitive [default: False]</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>if True, the processes will be printed to the console</p> <code>False</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>A list of dictionaries for the matching processes. The dict contains the 'pid', 'status' and 'cmdline' of a process.</p>"},{"location":"api/process/#egse.process.list_zombies","title":"list_zombies","text":"<pre><code>list_zombies()\n</code></pre> <p>Returns a list of zombie processes.</p> <p>A zombie process, also known as a defunct process, is a process that has completed its execution but still has an entry in the process table. This happens when a child process terminates, but the parent process hasn't yet read its exit status by using a system call like wait(). As a result, the process is \"dead\" (it has completed execution) but hasn't been \"reaped\" or removed from the system's process table.</p> <p>A zombie process can not be killed with SIGKILL because it's already dead, and it's only removed when the parent process reads their exit status or when the parent process itself terminates.</p> <p>A zombie process does not block ports, so it's mostly harmless and will disappear when the parent process terminates.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>A list of dictionaries with information on the zombie processes. The dict contains the 'pid', 'name', and 'cmdline' of the zombie process.</p>"},{"location":"api/reload/","title":"egse.reload","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/reload/#egse.reload","title":"egse.reload","text":"<p>A slightly better approach to reloading modules and function than the standard <code>importlib.reload()</code> function. The functions in this module are for interactive use in a Python REPL.</p> <ul> <li><code>reload_module(module)</code>: reloads the given module and all its parent modules</li> <li><code>reload_function(func)</code>: reloads and returns the given function</li> </ul> <p>Note</p> <p>It might be possible that after the module or function has been reloaded that an extra import is needed to import the proper module attributes in your namespace.</p> <p>Module dependency</p> <p>When you make a change in a module or function that you are not calling directly, but call through another function from another module, you need to reload the module where you made the change and, after that, reload the function that calls that module.</p> Example <ul> <li>module <code>x.a</code> contains function <code>func_a</code></li> <li>module <code>x.b</code> contains function <code>func_b</code> which calls <code>func_a</code></li> </ul> <p>when you make a change in <code>func_a</code> you have to reload the module <code>x.a</code> and then reload the function <code>func_b</code>:</p> <pre><code>from x.b import func_b\nfunc_b()\n</code></pre> <p>now make some changes in <code>func_a</code>, then to make those changes known in your session:</p> <pre><code>reload_module('x.a')\nfunc_b = reload_function(func_b)\nfunc_b()  # will show the changes done in func_a\n</code></pre> <p>Functions:</p> Name Description <code>reload_function</code> <p>Reloads and returns the given function. In order for this to work, you should catch the</p> <code>reload_module</code> <p>Reloads the given module and all its parent modules. The modules will be reloaded starting</p>"},{"location":"api/reload/#egse.reload.reload_function","title":"reload_function","text":"<pre><code>reload_function(func)\n</code></pre> <p>Reloads and returns the given function. In order for this to work, you should catch the return value to replace the given function with its reloaded counterpart.</p> <p>This will also work if you import the function again instead of catching it.</p> Note <p>that this mechanism doesn't work for functions that were defined in the <code>__main__</code> module.</p> Example <p><pre><code>func = reload_function(func)\n</code></pre> or <pre><code>reload_function(func)\nfrom egse.some_module import func\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>FunctionType</code> <p>the function that needs to be reloaded</p> required <p>Returns:</p> Type Description <code>FunctionType</code> <p>The reloaded function.</p> <p>Raises:</p> Type Description <code>Abort</code> <p>when the function is not the proper type or when the function is defined in the <code>__main__</code> module.</p>"},{"location":"api/reload/#egse.reload.reload_module","title":"reload_module","text":"<pre><code>reload_module(module, walk=True)\n</code></pre> <p>Reloads the given module and all its parent modules. The modules will be reloaded starting from their top-level module. Reloading the 'egse.hexapod.symetry.puna' module will reload 'egse', 'egse.hexapod', 'egse.hexapod.symetry', and 'egse.hexapod.symetry.puna' in that order.</p> Note <p>If you pass the module argument as a module, make sure the top level module is imported in your session, or you will get a NameError. To prevent this (if you don't want to import the top-level module, pass the module as a string.</p> Example <p><pre><code>import egse\nreload_module(egse.system)\n</code></pre> or <pre><code>reload_module('egse.system')\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>Union[ModuleType, str]</code> <p>The module that needs to be reloaded</p> required <code>walk</code> <code>bool</code> <p>walk up the module hierarchy and import all modules [default=True]</p> <code>True</code>"},{"location":"api/settings/","title":"egse.settings","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/settings/#egse.settings","title":"egse.settings","text":"<p>The Settings class handles user and configuration settings that are provided in a <code>YAML</code> file.</p> <p>The idea is that settings are grouped by components or any arbitrary grouping that makes sense for the application or for the user. Settings are also modular and provided by each package by means of entry-points. The Settings class can read from different YAML files.</p> <p>By default, settings are loaded from a file called <code>settings.yaml</code>, but this can be changed in the entry-point definition.</p> <p>The yaml configuration files are provided as entry points by the packages that specified an entry-point group 'cgse.settings' in the <code>pyproject.toml</code>. The Settings dictionary (attrdict) is constructed from the configuration YAML files from each of the packages. Settings can be overwritten by the next package configuration file. So, make sure the group names in each package configuration file are unique.</p> <p>The YAML file is read and the configuration parameters for the given group are available as instance variables of the returned class.</p> <p>The intended use is as follows:</p> <pre><code>from egse.settings import Settings\n\ndsi_settings = Settings.load(\"DSI\")\n\nif 0x000C &lt;= dsi_settings.RMAP_BASE_ADDRESS &lt;= 0x00FF:\n    ...  # do something here\nelse:\n    raise RMAPError(\"Attempt to access outside the RMAP memory map.\")\n</code></pre> <p>The above code reads the settings from the default YAML file for a group called <code>DSI</code>. The settings will then be available as variables of the returned class, in this case <code>dsi_settings</code>. The returned class is and behaves also like a dictionary, so you can check if a configuration parameter is defined like this:</p> <p><pre><code>if \"DSI_FEE_IP_ADDRESS\" not in dsi_settings:\n    # define the IP address of the DSI\n</code></pre> The YAML section for the above code looks like this:</p> <pre><code>DSI:\n\n    # DSI Specific Settings\n\n    DSI_FEE_IP_ADDRESS  10.33.178.144   # IP address of the DSI EtherSpaceLink interface\n    LINK_SPEED:                   100   # SpW link speed used for both up- and downlink\n\n    # RMAP Specific Settings\n\n    RMAP_BASE_ADDRESS:     0x00000000   # The start of the RMAP memory map managed by the FEE\n    RMAP_MEMORY_SIZE:            4096   # The size of the RMAP memory map managed by the FEE\n</code></pre> <p>When you want to read settings from another YAML file, specify the <code>filename=</code> keyword. If that file is located at a specific location, also use the <code>location=</code> keyword.</p> <pre><code>my_settings = Settings.load(filename=\"user.yaml\", location=\"/Users/JohnDoe\")\n</code></pre> <p>The above code will read the YAML file from the given location and not from the entry-points.</p> <p>Classes:</p> Name Description <code>Settings</code> <p>The Settings class provides a load() method that loads configuration settings for a group</p> <code>SettingsError</code> <p>A settings-specific error.</p> <p>Functions:</p> Name Description <code>load_global_settings</code> <p>Loads the settings that are defined by the given entry_point. The entry-points are defined in the</p> <code>load_local_settings</code> <p>Loads the local settings file that is defined from the environment variable PROJECT_LOCAL_SETTINGS (where</p> <code>load_settings_file</code> <p>Loads the YAML configuration file that is located at <code>path / filename</code>.</p> <code>read_configuration_file</code> <p>Read the YAML input configuration file. The configuration file is only read</p>"},{"location":"api/settings/#egse.settings.Settings","title":"Settings","text":"<p>The Settings class provides a load() method that loads configuration settings for a group into a dynamically created class as instance variables.</p> <p>Methods:</p> Name Description <code>load</code> <p>Load the settings for the given group. When no group is provided, the</p> <code>to_string</code> <p>Returns a simple string representation of the cached configuration of this Settings class.</p>"},{"location":"api/settings/#egse.settings.Settings.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(\n    group_name=None,\n    filename=\"settings.yaml\",\n    location=None,\n    *,\n    add_local_settings=True,\n    force=False,\n)\n</code></pre> <p>Load the settings for the given group. When no group is provided, the complete configuration is returned.</p> <p>The Settings are loaded from entry-points that are defined in each of the packages that provide a Settings file.</p> <p>If a location is explicitly provided, the Settings will be loaded from that location, using the given filename or the default (which is settings.yaml).</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>the name of one of the main groups from the YAML file</p> <code>None</code> <code>filename</code> <code>str</code> <p>the name of the YAML file to read [default=settings.yaml]</p> <code>'settings.yaml'</code> <code>location</code> <code>(str, Path)</code> <p>the path to the location of the YAML file</p> <code>None</code> <code>force</code> <code>bool</code> <p>force reloading the file</p> <code>False</code> <code>add_local_settings</code> <code>bool</code> <p>update the Settings with site specific local settings</p> <code>True</code> <p>Returns:</p> Type Description <code>attrdict</code> <p>a dynamically created class with the configuration parameters as instance variables.</p> <p>Raises:</p> Type Description <code>SettingsError</code> <p>when the group is not defined in the YAML file.</p>"},{"location":"api/settings/#egse.settings.Settings.to_string","title":"to_string  <code>classmethod</code>","text":"<pre><code>to_string()\n</code></pre> <p>Returns a simple string representation of the cached configuration of this Settings class.</p>"},{"location":"api/settings/#egse.settings.SettingsError","title":"SettingsError","text":"<p>               Bases: <code>Exception</code></p> <p>A settings-specific error.</p>"},{"location":"api/settings/#egse.settings.load_global_settings","title":"load_global_settings","text":"<pre><code>load_global_settings(\n    entry_point=\"cgse.settings\", force=False\n)\n</code></pre> <p>Loads the settings that are defined by the given entry_point. The entry-points are defined in the <code>pyproject.toml</code> files of the packages that export their global settings.</p> <p>Parameters:</p> Name Type Description Default <code>entry_point</code> <code>str</code> <p>the name of the entry-point group [default: 'cgse.settings']</p> <code>'cgse.settings'</code> <code>force</code> <code>bool</code> <p>force reloading the settings, i.e. ignore the cache</p> <code>False</code> <p>Returns:</p> Type Description <code>attrdict</code> <p>A dictionary (attrdict) containing a collection of all the settings exported by the packages         through the given entry-point.</p>"},{"location":"api/settings/#egse.settings.load_local_settings","title":"load_local_settings","text":"<pre><code>load_local_settings(force=False)\n</code></pre> <p>Loads the local settings file that is defined from the environment variable PROJECT_LOCAL_SETTINGS (where PROJECT is the name of your project, defined in the environment variable of the same name).</p> <p>This function might return an empty dictionary when</p> <ul> <li>the local settings YAML file is empty</li> <li>the local settings environment variable is not defined.</li> </ul> <p>in both cases a warning message is logged.</p> <p>Raises:</p> Type Description <code>SettingsError</code> <p>when the local settings YAML file is not found. Check the PROJECT_LOCAL_SETTINGS         environment variable.</p> <p>Returns:</p> Type Description <code>attrdict</code> <p>A dictionary (attrdict) with all local settings.</p>"},{"location":"api/settings/#egse.settings.load_settings_file","title":"load_settings_file","text":"<pre><code>load_settings_file(path, filename, force=False)\n</code></pre> <p>Loads the YAML configuration file that is located at <code>path / filename</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PATH</code> <p>the folder where the YAML file is located</p> required <code>filename</code> <code>str</code> <p>the name of the YAML configuration file</p> required <code>force</code> <code>bool</code> <p>force reloading, i.e. don't use the cached information</p> <code>False</code> <p>Raises:</p> Type Description <code>SettingsError</code> <p>when the configuration file doesn't exist or cannot be found or         when there was an error reading the configuration file.</p> <p>Returns:</p> Type Description <code>attrdict</code> <p>A dictionary (attrdict) with all the settings from the given file.</p> Note <p>in case of an empty configuration file, and empty dictionary         is returned and a warning message is issued.</p>"},{"location":"api/settings/#egse.settings.read_configuration_file","title":"read_configuration_file","text":"<pre><code>read_configuration_file(filename, *, force=False)\n</code></pre> <p>Read the YAML input configuration file. The configuration file is only read once and memoized as load optimization.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>the fully qualified filename of the YAML file</p> required <code>force</code> <code>bool</code> <p>force reloading the file, even when it was memoized</p> <code>False</code> <p>Raises:</p> Type Description <code>SettingsError</code> <p>when there was an error reading the YAML file.</p> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary containing all the configuration settings from the YAML file.</p>"},{"location":"api/setup/","title":"egse.setup","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/setup/#egse.setup","title":"egse.setup","text":""},{"location":"api/setup/#egse.setup--setup","title":"Setup","text":"<p>This module defines the Setup, which contains the complete configuration information for a test.</p> <p>The Setup class contains all configuration items that are specific for a test or observation and is normally (during nominal operation/testing) loaded automatically from the configuration manager. The Setup includes type and identification of hardware that is used, calibration files, software versions, reference frames and coordinate systems that link positions of alignment equipment, conversion functions for temperature sensors, etc.</p> <p>The configuration information that is in the Setup can be navigated in two different ways. First, the Setup is a dictionary, so all information can be accessed by keys as in the following example.</p> <pre><code>&gt;&gt;&gt; setup = Setup({\"gse\": {\"hexapod\": {\"ID\": 42, \"calibration\": [0,1,2,3,4,5]}}})\n&gt;&gt;&gt; setup[\"gse\"][\"hexapod\"][\"ID\"]\n42\n</code></pre> <p>Second, each of the keys is also available as an attribute of the Setup and that make it possible to navigate the Setup with dot-notation:</p> <pre><code>&gt;&gt;&gt; id = setup.gse.hexapod.ID\n</code></pre> <p>In the above example you can see how to navigate from the setup to a device like the PUNA Hexapod. The Hexapod device is connected to the control server and accepts commands as usual. If you want to know which keys you can use to navigate the Setup, use the <code>keys()</code> method.</p> <pre><code>&gt;&gt;&gt; setup.gse.hexapod.keys()\ndict_keys(['ID', 'calibration'])\n&gt;&gt;&gt; setup.gse.hexapod.calibration\n[0, 1, 2, 3, 4, 5]\n</code></pre> <p>To get a full printout of the Setup, you can use the <code>pretty_str()</code> method. Be careful, because this can print out a lot of information when a full Setup is loaded.</p> <pre><code>&gt;&gt;&gt; print(setup)\nSetup\n\u2514\u2500\u2500 gse\n    \u2514\u2500\u2500 hexapod\n        \u251c\u2500\u2500 ID: 42\n        \u2514\u2500\u2500 calibration: [0, 1, 2, 3, 4, 5]\n</code></pre>"},{"location":"api/setup/#egse.setup--special-values","title":"Special Values","text":"<p>Some of the information in the Setup is interpreted in a special way, i.e. some values are processed before returning. Examples are the device classes and calibration/data files. The following values are treated special if they start with:</p> <ul> <li><code>class//</code>: instantiate the class and return the object</li> <li><code>factory//</code>: instantiates a factory and executes its <code>create()</code> method</li> <li><code>csv//</code>: load the CSV file and return a numpy array</li> <li><code>yaml//</code>: load the YAML file and return a dictionary</li> <li><code>pandas//</code>: load a CSV file into a pandas Dataframe</li> <li><code>int-enum//</code>: dynamically create the enumeration and return the Enum object</li> </ul>"},{"location":"api/setup/#egse.setup--device-classes","title":"Device Classes","text":"<p>Most of the hardware components in the Setup will have a <code>device</code> key that defines the class for the device controller. The <code>device</code> keys have a value that starts with <code>class//</code> and it will return the device object. As an example, the following defines the Hexapod device:</p> <pre><code>&gt;&gt;&gt; setup = Setup(\n...   {\n...     \"gse\": {\n...       \"hexapod\": {\"ID\": 42, \"device\": \"class//egse.hexapod.symetrie.puna.PunaSimulator\"}\n...     }\n...   }\n... )\n&gt;&gt;&gt; setup.gse.hexapod.device.is_homing_done()\nFalse\n&gt;&gt;&gt; setup.gse.hexapod.device.info()\n'Info about the PunaSimulator...'\n</code></pre> <p>In the above example you see that we can call the <code>is_homing_done()</code> and <code>info()</code> methodes directly on the device by navigating the Setup. It would however be better (more performant) to put the device object in a variable and work with that variable:</p> <pre><code>&gt;&gt;&gt; hexapod = setup.gse.hexapod.device\n&gt;&gt;&gt; hexapod.homing()\n&gt;&gt;&gt; hexapod.is_homing_done()\nTrue\n&gt;&gt;&gt; hexapod.get_user_positions()\n</code></pre> <p>If you need, for some reason, to have access to the actual raw value of the hexapod device key, use the <code>get_raw_value()</code> method:</p> <pre><code>&gt;&gt;&gt; setup.gse.hexapod.get_raw_value(\"device\")\n&lt;egse.hexapod.symetrie.puna.PunaSimulator object at ...\n</code></pre>"},{"location":"api/setup/#egse.setup--data-files","title":"Data Files","text":"<p>Some information is too large to add to the Setup as such and should be loaded from a data file. Examples are calibration files, flat-fields, temperature conversion curves, etc.</p> <p>The Setup will automatically load the file when you access a key that contains a value that starts with <code>csv//</code> or <code>yaml//</code>.</p> <pre><code>&gt;&gt;&gt; setup = Setup({\n...     \"instrument\": {\"coeff\": \"csv//cal_coeff_1234.csv\"}\n... })\n&gt;&gt;&gt; setup.instrument.coeff[0, 4]\n5.0\n</code></pre> <p>Note: the resource location is always relative to the path defined by the PROJECT_CONF_DATA_LOCATION environment variable.</p> <p>The Setup inherits from a NavigableDict (aka navdict) which is also defined in this module.</p> <p>Classes:</p> Name Description <code>Setup</code> <p>The Setup class represents a version of the configuration of the test facility, the</p> <code>SetupError</code> <p>A setup-specific error.</p> <p>Functions:</p> Name Description <code>get_setup</code> <p>Retrieve the currently active Setup from the configuration manager.</p> <code>list_setups</code> <p>This is a function to be used for interactive use, it will print to the terminal (stdout) a</p> <code>load_last_setup_id</code> <p>Returns the ID of the last Setup that was used by the configuration manager.</p> <code>load_setup</code> <p>This function loads the Setup corresponding with the given <code>setup_id</code>.</p> <code>save_last_setup_id</code> <p>Makes the given Setup ID persistent, so it can be restored upon the next startup.</p> <code>submit_setup</code> <p>Submit the given Setup to the Configuration Manager.</p> <p>Attributes:</p> Name Type Description <code>navdict</code> <p>Shortcut for NavigableDict and more Pythonic.</p>"},{"location":"api/setup/#egse.setup.navdict","title":"navdict  <code>module-attribute</code>","text":"<pre><code>navdict = NavigableDict\n</code></pre> <p>Shortcut for NavigableDict and more Pythonic.</p>"},{"location":"api/setup/#egse.setup.NavigableDict","title":"NavigableDict","text":"<pre><code>NavigableDict(head=None, label=None)\n</code></pre> <p>               Bases: <code>dict</code></p> <p>A NavigableDict is a dictionary where all keys in the original dictionary are also accessible as attributes to the class instance. So, if the original dictionary (setup) has a key \"site_id\" which is accessible as <code>setup['site_id']</code>, it will also be accessible as <code>setup.site_id</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; setup = NavigableDict({'site_id': 'KU Leuven', 'version': \"0.1.0\"})\n&gt;&gt;&gt; assert setup['site_id'] == setup.site_id\n&gt;&gt;&gt; assert setup['version'] == setup.version\n</code></pre> Note <p>We always want all keys to be accessible as attributes, or none. That means all keys of the original dictionary shall be of type <code>str</code>.</p> <pre><code>label (str): a label or name that is used when printing the navdict\n</code></pre> <p>Methods:</p> Name Description <code>add</code> <p>Set a value for the given key.</p> <code>get_private_attribute</code> <p>Returns the value of the given private attribute.</p> <code>get_raw_value</code> <p>Returns the raw value of the given key.</p> <code>has_private_attribute</code> <p>Check if the given key is defined as a private attribute.</p> <code>pretty_str</code> <p>Returns a pretty string representation of the dictionary.</p> <code>set_private_attribute</code> <p>Sets a private attribute for this object.</p>"},{"location":"api/setup/#egse.setup.NavigableDict.add","title":"add","text":"<pre><code>add(key, value)\n</code></pre> <p>Set a value for the given key.</p> <p>If the value is a dictionary, it will be converted into a NavigableDict and the keys will become available as attributes provided that all the keys are strings.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the name of the key / attribute to access the value</p> required <code>value</code> <code>Any</code> <p>the value to assign to the key</p> required"},{"location":"api/setup/#egse.setup.NavigableDict.get_private_attribute","title":"get_private_attribute","text":"<pre><code>get_private_attribute(key)\n</code></pre> <p>Returns the value of the given private attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the name of the private attribute (must start with an underscore character).</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the value of the private attribute given in <code>key</code>.</p> Note <p>Because of the implementation, this private attribute can also be accessed as a 'normal' attribute of the object. This use is however discouraged as it will make your code less understandable. Use the methods to access these 'private' attributes.</p>"},{"location":"api/setup/#egse.setup.NavigableDict.get_raw_value","title":"get_raw_value","text":"<pre><code>get_raw_value(key)\n</code></pre> <p>Returns the raw value of the given key.</p> <p>Some keys have special values that are interpreted by the AtributeDict class. An example is a value that starts with 'class//'. When you access these values, they are first converted from their raw value into their expected value, e.g. the instantiated object in the above example. This method allows you to access the raw value before conversion.</p>"},{"location":"api/setup/#egse.setup.NavigableDict.has_private_attribute","title":"has_private_attribute","text":"<pre><code>has_private_attribute(key)\n</code></pre> <p>Check if the given key is defined as a private attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the name of a private attribute (must start with an underscore)</p> required"},{"location":"api/setup/#egse.setup.NavigableDict.pretty_str","title":"pretty_str","text":"<pre><code>pretty_str(indent=0)\n</code></pre> <p>Returns a pretty string representation of the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>number of indentations (of four spaces)</p> <code>0</code> Note <p>The indent argument is intended for the recursive call of this function.</p>"},{"location":"api/setup/#egse.setup.NavigableDict.set_private_attribute","title":"set_private_attribute","text":"<pre><code>set_private_attribute(key, value)\n</code></pre> <p>Sets a private attribute for this object.</p> <p>The name in key will be accessible as an attribute for this object, but the key will not be added to the dictionary and not be returned by methods like keys().</p> <p>The idea behind this private attribute is to have the possibility to add status information or identifiers to this classes object that can be used by save() or load() methods.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the name of the private attribute (must start with an underscore character).</p> required <code>value</code> <code>Any</code> <p>the value for this private attribute</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; setup = NavigableDict({'a': 1, 'b': 2, 'c': 3})\n&gt;&gt;&gt; setup.set_private_attribute(\"_loaded_from_dict\", True)\n&gt;&gt;&gt; assert \"c\" in setup\n&gt;&gt;&gt; assert \"_loaded_from_dict\" not in setup\n&gt;&gt;&gt; assert setup.get_private_attribute(\"_loaded_from_dict\") == True\n</code></pre>"},{"location":"api/setup/#egse.setup.Setup","title":"Setup","text":"<pre><code>Setup(nav_dict=None, label=None)\n</code></pre> <p>               Bases: <code>NavigableDict</code></p> <p>The Setup class represents a version of the configuration of the test facility, the test setup and the Camera Under Test (CUT).</p> <p>Methods:</p> Name Description <code>add</code> <p>Set a value for the given key.</p> <code>find_device_ids</code> <p>Returns a list of identifiers of the devices that are included in the setup.</p> <code>find_devices</code> <p>Returns a dictionary with the devices that are included in the setup.</p> <code>from_dict</code> <p>Create a Setup from a given dictionary.</p> <code>from_yaml_file</code> <p>Loads a Setup from the given YAML file.</p> <code>from_yaml_string</code> <p>Loads a Setup from the given YAML string.</p> <code>get_filename</code> <p>Returns the filename for this Setup or None when no filename could be determined.</p> <code>get_id</code> <p>Returns the Setup ID (as a string) or None when no setup id could be identified.</p> <code>get_private_attribute</code> <p>Returns the value of the given private attribute.</p> <code>get_raw_value</code> <p>Returns the raw value of the given key.</p> <code>has_private_attribute</code> <p>Check if the given key is defined as a private attribute.</p> <code>pretty_str</code> <p>Returns a pretty string representation of the dictionary.</p> <code>set_private_attribute</code> <p>Sets a private attribute for this object.</p> <code>to_yaml_file</code> <p>Saves a NavigableDict to a YAML file.</p> <code>walk</code> <p>Walk through the given dictionary, in a recursive way, appending the leaf with</p>"},{"location":"api/setup/#egse.setup.Setup.add","title":"add","text":"<pre><code>add(key, value)\n</code></pre> <p>Set a value for the given key.</p> <p>If the value is a dictionary, it will be converted into a NavigableDict and the keys will become available as attributes provided that all the keys are strings.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the name of the key / attribute to access the value</p> required <code>value</code> <code>Any</code> <p>the value to assign to the key</p> required"},{"location":"api/setup/#egse.setup.Setup.find_device_ids","title":"find_device_ids  <code>staticmethod</code>","text":"<pre><code>find_device_ids(node, device_ids=None)\n</code></pre> <p>Returns a list of identifiers of the devices that are included in the setup.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>NavigableDict</code> <p>Dictionary in which to look for the device identifiers.</p> required <code>device_ids</code> <code>dict</code> <p>List in which to include the devices in the setup.</p> <code>None</code>"},{"location":"api/setup/#egse.setup.Setup.find_devices","title":"find_devices  <code>staticmethod</code>","text":"<pre><code>find_devices(node, devices=None)\n</code></pre> <p>Returns a dictionary with the devices that are included in the setup.</p> <p>The keys in the dictionary are taken from the \"device_name\" entries in the setup file. The corresponding values in the dictionary are taken from the \"device\" entries in the setup file.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>NavigableDict</code> <p>Dictionary in which to look for the devices (and their names).</p> required <code>devices</code> <code>dict</code> <p>Dictionary in which to include the devices in the setup.</p> <code>None</code> <p>Dictionary with the devices that are included in the setup. The keys are the device name, the values</p> Type Description <code>dict[str, tuple[str, str, tuple]]</code> <p>are tuples with the 'device' raw value and the device arguments as a tuple.</p>"},{"location":"api/setup/#egse.setup.Setup.from_dict","title":"from_dict  <code>staticmethod</code>","text":"<pre><code>from_dict(my_dict)\n</code></pre> <p>Create a Setup from a given dictionary.</p> <p>Remember that all keys in the given dictionary shall be of type 'str' in order to be accessible as attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; setup = Setup.from_dict({\"ID\": \"my-setup-001\", \"version\": \"0.1.0\"})\n&gt;&gt;&gt; assert setup[\"ID\"] == setup.ID == \"my-setup-001\"\n</code></pre>"},{"location":"api/setup/#egse.setup.Setup.from_yaml_file","title":"from_yaml_file  <code>cached</code> <code>staticmethod</code>","text":"<pre><code>from_yaml_file(filename=None, add_local_settings=True)\n</code></pre> <p>Loads a Setup from the given YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the path of the YAML file to be loaded</p> <code>None</code> <code>add_local_settings</code> <code>bool</code> <p>if local settings shall be loaded and override the settings from the YAML file.</p> <code>True</code> <p>Returns:</p> Type Description <code>Setup</code> <p>a Setup that was loaded from the given location.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when no filename is given.</p>"},{"location":"api/setup/#egse.setup.Setup.from_yaml_string","title":"from_yaml_string  <code>staticmethod</code>","text":"<pre><code>from_yaml_string(yaml_content=None)\n</code></pre> <p>Loads a Setup from the given YAML string.</p> <p>This method is mainly used for easy creation of Setups from strings during unit tests.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_content</code> <code>str</code> <p>a string containing YAML</p> <code>None</code> <p>Returns:</p> Type Description <code>Setup</code> <p>a Setup that was loaded from the content of the given string.</p>"},{"location":"api/setup/#egse.setup.Setup.get_filename","title":"get_filename","text":"<pre><code>get_filename()\n</code></pre> <p>Returns the filename for this Setup or None when no filename could be determined.</p>"},{"location":"api/setup/#egse.setup.Setup.get_id","title":"get_id","text":"<pre><code>get_id()\n</code></pre> <p>Returns the Setup ID (as a string) or None when no setup id could be identified.</p>"},{"location":"api/setup/#egse.setup.Setup.get_private_attribute","title":"get_private_attribute","text":"<pre><code>get_private_attribute(key)\n</code></pre> <p>Returns the value of the given private attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the name of the private attribute (must start with an underscore character).</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the value of the private attribute given in <code>key</code>.</p> Note <p>Because of the implementation, this private attribute can also be accessed as a 'normal' attribute of the object. This use is however discouraged as it will make your code less understandable. Use the methods to access these 'private' attributes.</p>"},{"location":"api/setup/#egse.setup.Setup.get_raw_value","title":"get_raw_value","text":"<pre><code>get_raw_value(key)\n</code></pre> <p>Returns the raw value of the given key.</p> <p>Some keys have special values that are interpreted by the AtributeDict class. An example is a value that starts with 'class//'. When you access these values, they are first converted from their raw value into their expected value, e.g. the instantiated object in the above example. This method allows you to access the raw value before conversion.</p>"},{"location":"api/setup/#egse.setup.Setup.has_private_attribute","title":"has_private_attribute","text":"<pre><code>has_private_attribute(key)\n</code></pre> <p>Check if the given key is defined as a private attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the name of a private attribute (must start with an underscore)</p> required"},{"location":"api/setup/#egse.setup.Setup.pretty_str","title":"pretty_str","text":"<pre><code>pretty_str(indent=0)\n</code></pre> <p>Returns a pretty string representation of the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>number of indentations (of four spaces)</p> <code>0</code> Note <p>The indent argument is intended for the recursive call of this function.</p>"},{"location":"api/setup/#egse.setup.Setup.set_private_attribute","title":"set_private_attribute","text":"<pre><code>set_private_attribute(key, value)\n</code></pre> <p>Sets a private attribute for this object.</p> <p>The name in key will be accessible as an attribute for this object, but the key will not be added to the dictionary and not be returned by methods like keys().</p> <p>The idea behind this private attribute is to have the possibility to add status information or identifiers to this classes object that can be used by save() or load() methods.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the name of the private attribute (must start with an underscore character).</p> required <code>value</code> <code>Any</code> <p>the value for this private attribute</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; setup = NavigableDict({'a': 1, 'b': 2, 'c': 3})\n&gt;&gt;&gt; setup.set_private_attribute(\"_loaded_from_dict\", True)\n&gt;&gt;&gt; assert \"c\" in setup\n&gt;&gt;&gt; assert \"_loaded_from_dict\" not in setup\n&gt;&gt;&gt; assert setup.get_private_attribute(\"_loaded_from_dict\") == True\n</code></pre>"},{"location":"api/setup/#egse.setup.Setup.to_yaml_file","title":"to_yaml_file","text":"<pre><code>to_yaml_file(filename=None)\n</code></pre> <p>Saves a NavigableDict to a YAML file.</p> <p>When no filename is provided, this method will look for a 'private' attribute <code>_filename</code> and use that to save the data.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | Path</code> <p>the path of the YAML file where to save the data</p> <code>None</code> Note <p>This method will overwrite the original or given YAML file and therefore you might lose proper formatting and/or comments.</p>"},{"location":"api/setup/#egse.setup.Setup.walk","title":"walk  <code>staticmethod</code>","text":"<pre><code>walk(node, key_of_interest, leaf_list)\n</code></pre> <p>Walk through the given dictionary, in a recursive way, appending the leaf with the given keyword to the given list.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>dict</code> <p>Dictionary in which to look for leaves with the given keyword.</p> required <code>key_of_interest</code> <code>str</code> <p>Key to look for in the leaves of the given dictionary.</p> required <code>leaf_list</code> <code>list</code> <p>List to which to add the leaves with the given keyword.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Given list with the leaves (with the given keyword) in the given dictionary             appended to it.</p>"},{"location":"api/setup/#egse.setup.SetupError","title":"SetupError","text":"<p>               Bases: <code>Exception</code></p> <p>A setup-specific error.</p>"},{"location":"api/setup/#egse.setup.disentangle_filename","title":"disentangle_filename","text":"<pre><code>disentangle_filename(filename)\n</code></pre> <p>Returns the site_id and setup_id (as a tuple) that is extracted from the Setups filename.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the filename or fully qualified file path as a string.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple (site_id, setup_id).</p>"},{"location":"api/setup/#egse.setup.get_last_setup_id_file_path","title":"get_last_setup_id_file_path","text":"<pre><code>get_last_setup_id_file_path(site_id=None)\n</code></pre> <p>Return the fully expanded file path of the file containing the last loaded Setup in the configuration manager. The default location for this file is the data storage location.</p> <p>Parameters:</p> Name Type Description Default <code>site_id</code> <code>str</code> <p>The SITE identifier (overrides the SITE_ID environment variable)</p> <code>None</code>"},{"location":"api/setup/#egse.setup.get_path_of_setup_file","title":"get_path_of_setup_file","text":"<pre><code>get_path_of_setup_file(setup_id, site_id)\n</code></pre> <p>Returns the Path to the last Setup file for the given site_id. The last Setup file is the file with the largest setup_id number.</p> <p>This function needs the environment variable _CONF_REPO_LOCATION to be defined as the location of the repository with configuration data on your disk. If the repo is not defined, the configuration data location will be used instead. <p>Parameters:</p> Name Type Description Default <code>setup_id</code> <code>int</code> <p>the identifier for the requested Setup</p> required <code>site_id</code> <code>str</code> <p>the test house name, one of CSL, SRON, IAS, INTA</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The full path to the requested Setup file.</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>when the environment variable is not set.</p> <code>NotADirectoryError</code> <p>when either the repository folder or the Setups folder doesn't exist.</p> <code>FileNotFoundError</code> <p>when no Setup file can be found for the given arguments.</p>"},{"location":"api/setup/#egse.setup.get_setup","title":"get_setup","text":"<pre><code>get_setup(setup_id=None)\n</code></pre> <p>Retrieve the currently active Setup from the configuration manager.</p> <p>When a setup_id is provided, that setup will be returned, but not loaded in the configuration manager. This function does NOT change the configuration manager.</p> <p>This function is for interactive use and consults the configuration manager server. Don't use this within the test script, but use the <code>GlobalState.setup</code> property instead.</p>"},{"location":"api/setup/#egse.setup.list_setups","title":"list_setups","text":"<pre><code>list_setups(**attr)\n</code></pre> <p>This is a function to be used for interactive use, it will print to the terminal (stdout) a list of Setups known at the Configuration Manager. This list is sorted with the most recent ( highest) value last.</p> <p>The list can be restricted with key:value pairs (keyword arguments). This search mechanism allows us to find all Setups that adhere to the key:value pairs, e.g. to find all Setups for CSL at position 2, use:</p> <pre><code>&gt;&gt;&gt; list_setups(site_id=\"CSL\", position=2)\n</code></pre> <p>To have a nested keyword search (i.e. search by <code>gse.hexapod.ID</code>) then pass in <code>gse__hexapod__ID</code> as the keyword argument. Replace the '.' notation with double underscores '__'.</p> <pre><code>&gt;&gt;&gt; list_setups(gse__hexapod__ID=4)\n</code></pre>"},{"location":"api/setup/#egse.setup.load_last_setup_id","title":"load_last_setup_id","text":"<pre><code>load_last_setup_id(site_id=None)\n</code></pre> <p>Returns the ID of the last Setup that was used by the configuration manager. The file shall only contain the Setup ID which must be an integer on the first line of the file. If no such ID can be found, the Setup ID = 0 will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>site_id</code> <code>str</code> <p>The SITE identifier</p> <code>None</code>"},{"location":"api/setup/#egse.setup.load_setup","title":"load_setup","text":"<pre><code>load_setup(setup_id=None, site_id=None, from_disk=False)\n</code></pre> <p>This function loads the Setup corresponding with the given <code>setup_id</code>.</p> <p>Loading a Setup means:</p> <ul> <li>that this Setup will also be loaded and activated in the configuration manager,</li> <li>that this Setup will be available from the <code>GlobalState.setup</code></li> </ul> <p>When no setup_id is provided, the current Setup is loaded from the configuration manager.</p> <p>Parameters:</p> Name Type Description Default <code>setup_id</code> <code>int</code> <p>the identifier for the Setup</p> <code>None</code> <code>site_id</code> <code>str</code> <p>the name of the test house</p> <code>None</code> <code>from_disk</code> <code>bool</code> <p>True if the Setup needs to be loaded from disk</p> <code>False</code> <p>Returns:</p> Type Description <code>Setup</code> <p>The requested Setup or None when the Setup could not be loaded from the         configuration manager.</p>"},{"location":"api/setup/#egse.setup.save_last_setup_id","title":"save_last_setup_id","text":"<pre><code>save_last_setup_id(setup_id, site_id=None)\n</code></pre> <p>Makes the given Setup ID persistent, so it can be restored upon the next startup.</p> <p>Parameters:</p> Name Type Description Default <code>setup_id</code> <code>int | str</code> <p>The Setup identifier to be saved</p> required <code>site_id</code> <code>str</code> <p>The SITE identifier</p> <code>None</code>"},{"location":"api/setup/#egse.setup.submit_setup","title":"submit_setup","text":"<pre><code>submit_setup(setup, description)\n</code></pre> <p>Submit the given Setup to the Configuration Manager.</p> <p>When you submit a Setup, the Configuration Manager will save this Setup with the next (new) setup id and make this Setup the current Setup in the Configuration manager unless you have explicitly set <code>replace=False</code> in which case the current Setup will not be replaced with the new Setup.</p> <p>Parameters:</p> Name Type Description Default <code>setup</code> <code>Setup</code> <p>a (new) Setup to submit to the configuration manager</p> required <code>description</code> <code>str</code> <p>one-liner to help identifying the Setup afterwards</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The Setup ID of the newly created Setup or None.</p>"},{"location":"api/system/","title":"egse.system","text":"<p>cgse-common</p> <p>This code is part of the <code>cgse-common</code> package.</p>"},{"location":"api/system/#egse.system","title":"egse.system","text":"<p>The system module defines convenience functions that provide information on system specific functionality like, file system interactions, timing, operating system interactions, etc.</p> <p>The module has external dependencies to:</p> <ul> <li>distro: for determining the Linux distribution</li> <li>psutil: for system statistics</li> <li>rich: for console output</li> </ul> <p>Classes:</p> Name Description <code>AttributeDict</code> <p>This class is and acts like a dictionary but has the additional functionality</p> <code>NotSpecified</code> <p>Class for NOT_SPECIFIED constant.</p> <code>Periodic</code> <p>A timer that periodically invokes a function in the background.</p> <code>Sentinel</code> <p>This Sentinel can be used as an alternative to None or other meaningful values in e.g. a function argument.</p> <code>SignalCatcher</code> <p>This class registers handler to signals. When a signal is caught, the handler is</p> <code>Timer</code> <p>Context manager to benchmark some lines of code.</p> <code>TyperAsyncCommand</code> <p>Runs an asyncio Typer command.</p> <p>Functions:</p> Name Description <code>all_logging_disabled</code> <p>Context manager to temporarily disable logging messages during its execution.</p> <code>await_me_maybe</code> <p>Invoke a callback with an arbitrary number of parameters.</p> <code>camel_to_kebab</code> <p>Convert a string in CamelCase to kebab-case.</p> <code>camel_to_snake</code> <p>Convert a string in CamelCase to snake_case.</p> <code>capture_rich_output</code> <p>Capture the output of a Rich console print of the given object. If the object is a known Rich renderable or if</p> <code>chdir</code> <p>Context manager to temporarily change directory.</p> <code>check_argument_type</code> <p>Check that the given object is of a specific (sub)type of the given target_class.</p> <code>check_is_a_string</code> <p>Checks if the given variable is a string and raises a TypeError if the check fails.</p> <code>check_str_for_slash</code> <p>Check if there is a slash in the given string, and raise a ValueError if so.</p> <code>clear_average_execution_times</code> <p>Clear out all function timing for this process.</p> <code>do_every</code> <p>This method executes a function periodically, taking into account</p> <code>duration</code> <p>Returns a <code>timedelta</code> object with the duration, i.e. time difference between dt_start and dt_end.</p> <code>env_var</code> <p>Context manager to run some code that need alternate settings for environment variables.</p> <code>execution_time</code> <p>A decorator to save the execution time of the function. Use this decorator</p> <code>filter_by_attr</code> <p>A helper that returns the elements from the iterable that meet all the traits passed in <code>attrs</code>.</p> <code>find_class</code> <p>Find and returns a class based on the fully qualified name.</p> <code>flatten_dict</code> <p>Flatten the given dictionary concatenating the keys with a colon '<code>:</code>'.</p> <code>format_datetime</code> <p>Format a datetime as YYYY-mm-ddTHH:MM:SS.\u03bcs+0000.</p> <code>get_active_loggers</code> <p>Retrieves information about active loggers and their respective log levels.</p> <code>get_average_execution_time</code> <p>Returns the average execution time of the given function. The function 'func' shall be previously executed using</p> <code>get_average_execution_times</code> <p>Returns a dictionary with <code>key = &lt;function name&gt;</code> and  <code>value = &lt;average execution time&gt;</code>, for all function that</p> <code>get_caller_breadcrumbs</code> <p>Returns a string representing the calling sequence of this function. The string contains the calling sequence from</p> <code>get_caller_info</code> <p>Returns the filename, function name and lineno of the caller.</p> <code>get_current_location</code> <p>Returns the location where this function is called, i.e. the filename, line number, and function name.</p> <code>get_full_classname</code> <p>Returns the fully qualified class name for the given object.</p> <code>get_host_ip</code> <p>Returns the IP address. If no IP address can be found, None will be returned and the caller can try</p> <code>get_logging_level</code> <p>Convert a logging level to its integer representation.</p> <code>get_module_location</code> <p>Returns the location of the module as a Path object.</p> <code>get_os_name</code> <p>Returns the name of the OS in lower case.</p> <code>get_os_version</code> <p>Return the version of the OS.</p> <code>get_package_description</code> <p>Returns the description of the package as specified in the projects metadata Summary.</p> <code>get_package_location</code> <p>Retrieves the file system locations associated with a Python package.</p> <code>get_referenced_var_name</code> <p>Returns a list of variable names that reference the given object.</p> <code>get_system_architecture</code> <p>Returns the machine type. This is a string describing the processor architecture,</p> <code>get_system_name</code> <p>Returns the name of the system in lower case.</p> <code>get_system_stats</code> <p>Gather system information about the CPUs and memory usage and return a dictionary with the</p> <code>has_internet</code> <p>Returns True if we have internet connection.</p> <code>humanize_seconds</code> <p>The number of seconds is represented as <code>[#D]d [#H]h[#M]m[#S]s.MS</code> where:</p> <code>ignore_m_warning</code> <p>Ignore RuntimeWarning by <code>runpy</code> that occurs when executing a module with <code>python -m package.module</code>,</p> <code>is_in</code> <p>Returns result of <code>a in b</code>.</p> <code>is_in_ipython</code> <p>Returns True if the code is running in IPython.</p> <code>is_module</code> <p>Returns True if the argument is a module or represents a module, False otherwise.</p> <code>is_namespace</code> <p>Checks if a module represents a namespace package.</p> <code>is_not_in</code> <p>Returns result of <code>a not in b</code>.</p> <code>is_package_installed</code> <p>Check if a package is installed.</p> <code>kebab_to_title</code> <p>Convert kebab-case to Title Case (each word capitalized)</p> <code>now</code> <p>Returns a datetime object for the current time in UTC or local time.</p> <code>ping</code> <p>Sends a ping request to the given host.</p> <code>read_last_line</code> <p>Returns the last line of a (text) file.</p> <code>read_last_lines</code> <p>Return the last lines of a text file.</p> <code>recursive_dict_update</code> <p>Recursively update a dictionary <code>this</code> with the content of another dictionary <code>other</code>.</p> <code>replace_environment_variable</code> <p>Returns the <code>input_string</code> with all occurrences of ENV['var'].</p> <code>round_up</code> <p>Round a number up to a specified number of decimal places.</p> <code>sanity_check</code> <p>Checks a boolean flag and raises an AssertionError with the provided message if the check fails.</p> <code>save_average_execution_time</code> <p>Executes the function 'func' with the given arguments and saves the execution time. All positional</p> <code>snake_to_title</code> <p>Convert snake_case to Title Case (each word capitalized)</p> <code>str_to_datetime</code> <p>Convert the given string to a datetime object.</p> <code>time_in_ms</code> <p>Returns the current time in milliseconds since the Epoch.</p> <code>time_since_epoch_1958</code> <p>Calculate the time since epoch 1958 for the given string representation of a datetime.</p> <code>touch</code> <p>Unix-like 'touch', i.e. create a file if it doesn't exist and set the modification time to the current time.</p> <code>type_name</code> <p>Returns the name of the type of var.</p> <code>wait_until</code> <p>Sleep until the given condition is fulfilled. The arguments are passed into the condition</p> <code>waiting_for</code> <p>Sleep until the given condition is fulfilled. The arguments are passed into the condition</p> <p>Attributes:</p> Name Type Description <code>NOT_SPECIFIED</code> <p>The constant that defines a not-specified value. Intended use is as a sentinel object.</p> <code>SIGNAL_NAME</code> <p>The signals that can be caught with the SignalCatcher.</p> <code>attrdict</code> <p>Shortcut for the AttributeDict class.</p>"},{"location":"api/system/#egse.system.NOT_SPECIFIED","title":"NOT_SPECIFIED  <code>module-attribute</code>","text":"<pre><code>NOT_SPECIFIED = NotSpecified()\n</code></pre> <p>The constant that defines a not-specified value. Intended use is as a sentinel object.</p>"},{"location":"api/system/#egse.system.SIGNAL_NAME","title":"SIGNAL_NAME  <code>module-attribute</code>","text":"<pre><code>SIGNAL_NAME = {\n    1: \"SIGHUP\",\n    2: \"SIGINT\",\n    3: \"SIGQUIT\",\n    6: \"SIGABRT\",\n    15: \"SIGTERM\",\n    30: \"SIGUSR1\",\n    31: \"SIGUSR2\",\n}\n</code></pre> <p>The signals that can be caught with the SignalCatcher.</p>"},{"location":"api/system/#egse.system.attrdict","title":"attrdict  <code>module-attribute</code>","text":"<pre><code>attrdict = AttributeDict\n</code></pre> <p>Shortcut for the AttributeDict class.</p>"},{"location":"api/system/#egse.system.AttributeDict","title":"AttributeDict","text":"<pre><code>AttributeDict(*args, label=None, **kwargs)\n</code></pre> <p>               Bases: <code>dict</code></p> <p>This class is and acts like a dictionary but has the additional functionality that all keys in the dictionary are also accessible as instance attributes.</p> <pre><code>&gt;&gt;&gt; ad = AttributeDict({'a': 1, 'b': 2, 'c': 3})\n\n&gt;&gt;&gt; assert ad.a == ad['a']\n&gt;&gt;&gt; assert ad.b == ad['b']\n&gt;&gt;&gt; assert ad.c == ad['c']\n</code></pre> <p>Similarly, adding or defining attributes will make them also keys in the dict.</p> <pre><code>&gt;&gt;&gt; ad.d = 4  # creates a new attribute\n&gt;&gt;&gt; print(ad['d'])\n4\n</code></pre>"},{"location":"api/system/#egse.system.NotSpecified","title":"NotSpecified","text":"<p>Class for NOT_SPECIFIED constant. Is used so that a parameter can have a default value other than None.</p> <p>Evaluate to False when converted to boolean.</p>"},{"location":"api/system/#egse.system.Periodic","title":"Periodic","text":"<pre><code>Periodic(\n    interval,\n    *,\n    name=None,\n    callback=None,\n    repeat=None,\n    skip=True,\n    pause=False,\n)\n</code></pre> <p>A timer that periodically invokes a function in the background.</p> <p>If no callback is provided, a warning message will be logged. In a future, we might send out an event to the application (will need an event handler).</p> <p>When the function execution takes longer then the interval there re several options:</p> <ul> <li>if skip is True (default) the interval will take precedence and the Args:     interval: The time between timer events, in seconds.     name: A name to assign the event (for debugging), defaults to <code>Periodic#</code>.     callback: A optional callback to invoke when the event is handled.     repeat: The number of times to repeat the timer, or None to repeat forever.     skip: Enable skipping of scheduled function calls that couldn't be sent in time.     pause: Start the timer paused. Use <code>resume()</code> to activate the timer.</li> </ul> <p>Methods:</p> Name Description <code>pause</code> <p>Pause the timer.</p> <code>reset</code> <p>Reset the timer, so it starts from the beginning.</p> <code>resume</code> <p>Resume a paused timer.</p> <code>start</code> <p>Start the timer.</p> <code>stop</code> <p>Stop the timer.</p>"},{"location":"api/system/#egse.system.Periodic.pause","title":"pause","text":"<pre><code>pause()\n</code></pre> <p>Pause the timer.</p> <p>A paused timer will not send events until it is resumed.</p>"},{"location":"api/system/#egse.system.Periodic.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the timer, so it starts from the beginning.</p>"},{"location":"api/system/#egse.system.Periodic.resume","title":"resume","text":"<pre><code>resume()\n</code></pre> <p>Resume a paused timer.</p>"},{"location":"api/system/#egse.system.Periodic.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start the timer.</p>"},{"location":"api/system/#egse.system.Periodic.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop the timer.</p>"},{"location":"api/system/#egse.system.Sentinel","title":"Sentinel","text":"<p>This Sentinel can be used as an alternative to None or other meaningful values in e.g. a function argument.</p> <p>Usually, a sensible default would be to use None, but if None is a valid input parameter, you can use a Sentinel object and check in the function if the argument value is a Sentinel object.</p> Example <pre><code>def get_info(server_socket, timeout: int = Sentinel()):\n    if isinstance(timeout, Sentinel):\n       raise ValueError(\"You should enter a valid timeout or None\")\n</code></pre>"},{"location":"api/system/#egse.system.SignalCatcher","title":"SignalCatcher","text":"<pre><code>SignalCatcher()\n</code></pre> <p>This class registers handler to signals. When a signal is caught, the handler is executed and a flag for termination or user action is set to True. Check for this flag in your application loop.</p> <ul> <li>Termination signals: 1=HUP, 2=INT, 3=QUIT, 6=ABORT, 15=TERM</li> <li>User signals: 30=USR1, 31=USR2</li> </ul> <p>Methods:</p> Name Description <code>clear</code> <p>Call this method to clear the user signal after handling.</p> <code>handler</code> <p>Handle the known signals by setting the appropriate flag.</p> <p>Attributes:</p> Name Type Description <code>signal_name</code> <p>The name of the signal that was caught.</p> <code>signal_number</code> <p>The value of the signal that was caught.</p>"},{"location":"api/system/#egse.system.SignalCatcher.signal_name","title":"signal_name  <code>property</code>","text":"<pre><code>signal_name\n</code></pre> <p>The name of the signal that was caught.</p>"},{"location":"api/system/#egse.system.SignalCatcher.signal_number","title":"signal_number  <code>property</code>","text":"<pre><code>signal_number\n</code></pre> <p>The value of the signal that was caught.</p>"},{"location":"api/system/#egse.system.SignalCatcher.clear","title":"clear","text":"<pre><code>clear(term=False)\n</code></pre> <p>Call this method to clear the user signal after handling. Termination signals are not cleared by default since the application is supposed to terminate. Pass in a <code>term=True</code> to also clear the TERM signals, e.g. when you want to ignore some TERM signals.</p>"},{"location":"api/system/#egse.system.SignalCatcher.handler","title":"handler","text":"<pre><code>handler(signal_number, frame)\n</code></pre> <p>Handle the known signals by setting the appropriate flag.</p>"},{"location":"api/system/#egse.system.Timer","title":"Timer","text":"<pre><code>Timer(name='Timer', precision=3, log_level=INFO)\n</code></pre> <p>Context manager to benchmark some lines of code.</p> <p>When the context exits, the elapsed time is sent to the default logger (level=INFO).</p> <p>Elapsed time can be logged with the <code>log_elapsed()</code> method and requested in fractional seconds by calling the class instance. When the contexts goes out of scope, the elapsed time will not increase anymore.</p> <p>Log messages are sent to the logger (including egse_logger for egse.system) and the logging level can be passed in as an optional argument. Default logging level is INFO.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>a name for the Timer, will be printed in the logging message</p> <code>'Timer'</code> <code>precision</code> <code>int</code> <p>the precision for the presentation of the elapsed time (number of digits behind the comma)</p> <code>3</code> <code>log_level</code> <code>int</code> <p>the log level to report the timing [default=INFO]</p> <code>INFO</code> Example <pre><code>with Timer(\"Some calculation\") as timer:\n    # do some calculations\n    timer.log_elapsed()\n    # do some more calculations\n    print(f\"Elapsed seconds: {timer()}\")\nElapsed seconds: ...\n</code></pre> <p>Methods:</p> Name Description <code>get_elapsed</code> <p>Returns the elapsed time for this timer as a float in seconds.</p> <code>log_elapsed</code> <p>Sends the elapsed time info to the default logger.</p>"},{"location":"api/system/#egse.system.Timer.get_elapsed","title":"get_elapsed","text":"<pre><code>get_elapsed()\n</code></pre> <p>Returns the elapsed time for this timer as a float in seconds.</p>"},{"location":"api/system/#egse.system.Timer.log_elapsed","title":"log_elapsed","text":"<pre><code>log_elapsed()\n</code></pre> <p>Sends the elapsed time info to the default logger.</p>"},{"location":"api/system/#egse.system.TyperAsyncCommand","title":"TyperAsyncCommand","text":"<pre><code>TyperAsyncCommand(*args, **kwargs)\n</code></pre> <p>               Bases: <code>TyperCommand</code></p> <p>Runs an asyncio Typer command.</p> <p>Example:</p> <pre><code>@add.command(cls=TyperAsyncCommand)\nasync def start():\n    ...\n</code></pre>"},{"location":"api/system/#egse.system.all_logging_disabled","title":"all_logging_disabled","text":"<pre><code>all_logging_disabled(highest_level=CRITICAL, flag=True)\n</code></pre> <p>Context manager to temporarily disable logging messages during its execution.</p> <p>Parameters:</p> Name Type Description Default <code>highest_level</code> <code>int</code> <p>The maximum logging level to be disabled. Defaults to logging.CRITICAL. Note: Adjust this only if a custom level greater than CRITICAL is defined.</p> <code>CRITICAL</code> <code>flag</code> <code>bool</code> <p>If True, disables all logging; if False, no changes are made. Defaults to True.</p> <code>True</code> Example <pre><code>with all_logging_disabled():\n    ...  # Your code with logging messages disabled\n</code></pre> Note <p>This context manager is designed to prevent any logging messages triggered during its body from being processed. It temporarily disables logging and restores the previous state afterward.</p>"},{"location":"api/system/#egse.system.await_me_maybe","title":"await_me_maybe  <code>async</code>","text":"<pre><code>await_me_maybe(callback, *params)\n</code></pre> <p>Invoke a callback with an arbitrary number of parameters.</p> <p>The callback can be a coroutine (async def) or a plain old function. The <code>await_me_maybe</code> awaits the result of the callback if it's an awaitable, or simply returns the result if not.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>The callable to be invoked.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The return value of the invoked callable.</p>"},{"location":"api/system/#egse.system.camel_to_kebab","title":"camel_to_kebab","text":"<pre><code>camel_to_kebab(camel_str)\n</code></pre> <p>Convert a string in CamelCase to kebab-case.</p>"},{"location":"api/system/#egse.system.camel_to_snake","title":"camel_to_snake","text":"<pre><code>camel_to_snake(camel_str)\n</code></pre> <p>Convert a string in CamelCase to snake_case.</p>"},{"location":"api/system/#egse.system.capture_rich_output","title":"capture_rich_output","text":"<pre><code>capture_rich_output(obj, width=120)\n</code></pre> <p>Capture the output of a Rich console print of the given object. If the object is a known Rich renderable or if the object implements the <code>__rich__()</code> method, the output string will contain escape sequences to format the output when printed to a terminal.</p> <p>This method is usually used to represent Rich output in a log file, e.g. to print a table in the log file.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>any object</p> required <code>width</code> <code>int</code> <p>the console width to use, None for full width</p> <code>120</code> <p>Returns:</p> Type Description <code>str</code> <p>The output of the capture, a string that possibly contains escape sequences as a result of rendering rich text.</p>"},{"location":"api/system/#egse.system.chdir","title":"chdir","text":"<pre><code>chdir(dirname=None)\n</code></pre> <p>Context manager to temporarily change directory.</p> <p>Parameters:</p> Name Type Description Default <code>dirname</code> <code>str or Path</code> <p>temporary folder name to switch to within the context</p> <code>None</code> Example <pre><code>with chdir('/tmp'):\n    ...  # do stuff in this writable /tmp folder\n</code></pre>"},{"location":"api/system/#egse.system.check_argument_type","title":"check_argument_type","text":"<pre><code>check_argument_type(\n    obj, name, target_class, allow_none=False\n)\n</code></pre> <p>Check that the given object is of a specific (sub)type of the given target_class. The <code>target_class</code> can be a tuple of types.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>any object</p> required <code>name</code> <code>str</code> <p>the name of the object</p> required <code>target_class</code> <code>Union[type, Tuple[type]]</code> <p>the required type of the object (can be a tuple of types)</p> required <code>allow_none</code> <code>bool</code> <p>True if the object can be None</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>when not of the required type or None when not allowed.</p>"},{"location":"api/system/#egse.system.check_is_a_string","title":"check_is_a_string","text":"<pre><code>check_is_a_string(var, allow_none=False)\n</code></pre> <p>Checks if the given variable is a string and raises a TypeError if the check fails.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Any</code> <p>The variable to be checked.</p> required <code>allow_none</code> <code>bool</code> <p>If True, allows the variable to be None without raising an error. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the variable is not a string or is None (when allow_none is False).</p> Example <pre><code>check_is_a_string(\"example\")\n</code></pre> Note <p>This function is designed to validate that the input variable is a string. If <code>allow_none</code> is set to True, it allows the variable to be None without raising an error.</p>"},{"location":"api/system/#egse.system.check_str_for_slash","title":"check_str_for_slash","text":"<pre><code>check_str_for_slash(arg)\n</code></pre> <p>Check if there is a slash in the given string, and raise a ValueError if so.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the string contains a slash '<code>/</code>'.</p>"},{"location":"api/system/#egse.system.clear_average_execution_times","title":"clear_average_execution_times","text":"<pre><code>clear_average_execution_times()\n</code></pre> <p>Clear out all function timing for this process.</p>"},{"location":"api/system/#egse.system.do_every","title":"do_every","text":"<pre><code>do_every(\n    period,\n    func,\n    *args,\n    count=None,\n    setup_func=None,\n    teardown_func=None,\n    stop_event=None,\n)\n</code></pre> <p>This method executes a function periodically, taking into account that the function that is executed will take time also and using a simple <code>sleep()</code> will cause a drift. This method will not drift.</p> <p>You can use this function in combination with the threading module to execute the function in the background, but be careful as the function <code>func</code> might not be thread safe.</p> <pre><code>timer_thread = threading.Thread(target=do_every, args=(10, func))\ntimer_thread.daemon = True\ntimer_thread.start()\n</code></pre> <p>The <code>setup_func</code> and <code>teardown</code> functions will be called before and after the loop that repeats the <code>func</code> function. This can be used e.g. for setting up and closing sockets.</p> <p>Apart from the <code>count</code>, the loop can also be stopped by passing a threading event and setting the <code>stop_event</code> when you want to terminate the thread.</p> <pre><code>self._stop_event = threading.Event()\n\ntimer_thread = threading.Thread(\n    target=do_every,\n    args=(interval, send_heartbeat),\n    kwargs={\n        'stop_event': self._stop_event,\n        'setup_func': self._connect_hb_socket,\n        'teardown_func': self._disconnect_hb_socket\n    }\n)\ntimer_thread.daemon = True\ntimer_thread.start()\n\n...\n\nself._stop_event.set()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>float</code> <p>a time interval between successive executions [seconds]</p> required <code>func</code> <code>Callable</code> <p>the function to be executed</p> required <code>*args</code> <code>tuple[int, ...]</code> <p>optional arguments to be passed to the function</p> <code>()</code> <code>count</code> <code>int</code> <p>if you do not need an endless loop, provide the number of iterations, if count=0 the function will not be executed.</p> <code>None</code> <code>setup_func</code> <code>Callable</code> <p>a function that will be called before going into the loop</p> <code>None</code> <code>teardown_func</code> <code>Callable</code> <p>a function that will be called when the loop ended</p> <code>None</code> <code>stop_event</code> <code>Event</code> <p>use a threading event to stop the loop</p> <code>None</code>"},{"location":"api/system/#egse.system.duration","title":"duration","text":"<pre><code>duration(dt_start, dt_end)\n</code></pre> <p>Returns a <code>timedelta</code> object with the duration, i.e. time difference between dt_start and dt_end.</p> Notes <p>If you need the number of seconds of your measurement, use the <code>total_seconds()</code> method of the timedelta object.</p> <p>Even if you \u2014by accident\u2014 switch the start and end time arguments, the duration will be calculated as expected.</p> <p>Parameters:</p> Name Type Description Default <code>dt_start</code> <code>str | datetime</code> <p>start time of the measurement</p> required <code>dt_end</code> <code>str | datetime</code> <p>end time of the measurement</p> required <p>Returns:</p> Type Description <code>timedelta</code> <p>The time difference (duration) between dt_start and dt_end.</p>"},{"location":"api/system/#egse.system.env_var","title":"env_var","text":"<pre><code>env_var(**kwargs)\n</code></pre> <p>Context manager to run some code that need alternate settings for environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict[str, str]</code> <p>dictionary with environment variables that are needed</p> <code>{}</code> Example <pre><code>with env_var(PLATO_DATA_STORAGE_LOCATION=\"/Users/rik/data\"):\n   # do stuff that needs these alternate setting\n   ...\n</code></pre>"},{"location":"api/system/#egse.system.execution_time","title":"execution_time","text":"<pre><code>execution_time(func)\n</code></pre> <p>A decorator to save the execution time of the function. Use this decorator if you want \u2014by default and always\u2014 have an idea of the average execution time of the given function.</p> <p>Use this in conjunction with the get_average_execution_time() function to retrieve the average execution time for the given function.</p>"},{"location":"api/system/#egse.system.filter_by_attr","title":"filter_by_attr","text":"<pre><code>filter_by_attr(elements, **attrs)\n</code></pre> <p>A helper that returns the elements from the iterable that meet all the traits passed in <code>attrs</code>.</p> <p>The attributes are compared to their value with the <code>operator.eq</code> function. However, when the given value for an attribute is a tuple, the first element in the tuple is considered a comparison function and the second value the actual value. The attribute is then compared to the value using this function.</p> <p><pre><code>result = filter_by_attr(setups, camera__model=\"EM\", site_id=(is_in, (\"CSL\", \"INTA\")))\n</code></pre> The function <code>is_in</code> is defined as follows: <pre><code>def is_in(a, b):\n    return a in b\n</code></pre> but you can of course also use a lambda function: <code>lambda a, b: a in b</code>.</p> <p>One function is treated special, it is the built-in function <code>hasattr</code>. Using this function, the value can be <code>True</code> or <code>False</code>. Use this to return all elements in the iterable that have the attribute, or not. The following example returns all Setups where the <code>gse.ogse.fwc_factor</code> is not defined: <pre><code>result = filter_by_attr(setups, camera__model=\"EM\", gse__ogse__fwc_factor=(hasattr, False)))\n</code></pre></p> <p>When multiple attributes are specified, they are checked using logical AND, not logical OR. Meaning they have to meet every attribute passed in and not one of them.</p> <p>To have a nested attribute search (i.e. search by <code>gse.hexapod.ID</code>) then pass in <code>gse__hexapod__ID</code> as the keyword argument.</p> <p>If nothing is found that matches the attributes passed, then an empty list is returned.</p> <p>When an attribute is not part of the iterated object, that attribute is silently ignored.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>Iterable</code> <p>An iterable to search through.</p> required <code>attrs</code> <code>dict[str, Any]</code> <p>Keyword arguments that denote attributes to search with.</p> <code>{}</code>"},{"location":"api/system/#egse.system.find_class","title":"find_class","text":"<pre><code>find_class(class_name)\n</code></pre> <p>Find and returns a class based on the fully qualified name.</p> <p>A class name can be preceded with the string <code>class//</code>. This is used in YAML files where the class is then instantiated on load by the Setup.</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>a fully qualified name for the class</p> required <p>Returns:</p> Type Description <code>Type</code> <p>The class object corresponding to the fully qualified class name.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>when the class is not found in the module.</p> <code>ValueError</code> <p>when the class_name can not be parsed.</p> <code>ModuleNotFoundError</code> <p>if the module could not be found.</p>"},{"location":"api/system/#egse.system.flatten_dict","title":"flatten_dict","text":"<pre><code>flatten_dict(source_dict)\n</code></pre> <p>Flatten the given dictionary concatenating the keys with a colon '<code>:</code>'.</p> <p>Parameters:</p> Name Type Description Default <code>source_dict</code> <code>dict</code> <p>the original dictionary that will be flattened</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A new flattened dictionary.</p> Example <pre><code>&gt;&gt;&gt; d = {\"A\": 1, \"B\": {\"E\": {\"F\": 2}}, \"C\": {\"D\": 3}}\n&gt;&gt;&gt; flatten_dict(d)\n{'A': 1, 'B:E:F': 2, 'C:D': 3}\n\n&gt;&gt;&gt; d = {\"A\": 'a', \"B\": {\"C\": {\"D\": 'd', \"E\": 'e'}, \"F\": 'f'}}\n&gt;&gt;&gt; flatten_dict(d)\n{'A': 'a', 'B:C:D': 'd', 'B:C:E': 'e', 'B:F': 'f'}\n</code></pre>"},{"location":"api/system/#egse.system.format_datetime","title":"format_datetime","text":"<pre><code>format_datetime(dt=None, fmt=None, width=6, precision=3)\n</code></pre> <p>Format a datetime as YYYY-mm-ddTHH:MM:SS.\u03bcs+0000.</p> <p>If the given argument is not timezone aware, the last part, i.e. <code>+0000</code> will not be there.</p> <p>If no argument is given, the timestamp is generated as <code>datetime.datetime.now(tz=datetime.timezone.utc)</code>.</p> <p>The <code>dt</code> argument can also be a string with the following values: today, yesterday, tomorrow, and 'day before yesterday'. The format will then be '%Y%m%d' unless specified.</p> <p>Optionally, a format string can be passed in to customize the formatting of the timestamp. This format string will be used with the <code>strftime()</code> method and should obey those conventions.</p> Example <pre><code>&gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 45, 696138))\n'2020-06-13T14:45:45.696'\n&gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 45, 696138), precision=6)\n'2020-06-13T14:45:45.696138'\n&gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 59, 999501), precision=3)\n'2020-06-13T14:45:59.999'\n&gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 59, 999501), precision=6)\n'2020-06-13T14:45:59.999501'\n&gt;&gt;&gt; _ = format_datetime()\n...\n&gt;&gt;&gt; format_datetime(\"yesterday\")\n'20220214'\n&gt;&gt;&gt; format_datetime(\"yesterday\", fmt=\"%d/%m/%Y\")\n'14/02/2022'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>a datetime object or an agreed string like yesterday, tomorrow, ...</p> <code>None</code> <code>fmt</code> <code>str</code> <p>a format string that is accepted by <code>strftime()</code></p> <code>None</code> <code>width</code> <code>int</code> <p>the width to use for formatting the microseconds</p> <code>6</code> <code>precision</code> <code>int</code> <p>the precision for the microseconds</p> <code>3</code> <p>Returns:</p> Type Description <code>str</code> <p>a string representation of the current time in UTC, e.g. <code>2020-04-29T12:30:04.862+0000</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>will be raised when the given dt argument string is not understood.</p>"},{"location":"api/system/#egse.system.get_active_loggers","title":"get_active_loggers","text":"<pre><code>get_active_loggers()\n</code></pre> <p>Retrieves information about active loggers and their respective log levels.</p> <p>Returns a dictionary where keys are the names of active loggers, and values are the corresponding log levels in string format.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary mapping logger names to their log levels.</p> Note <p>This function provides a snapshot of the currently active loggers and their log levels at the time of the function call.</p>"},{"location":"api/system/#egse.system.get_average_execution_time","title":"get_average_execution_time","text":"<pre><code>get_average_execution_time(func)\n</code></pre> <p>Returns the average execution time of the given function. The function 'func' shall be previously executed using the save_average_execution_time() function which remembers the last 100 execution times of the function. You can also decorate your function with @execution_time to permanently monitor it. The average time is a moving average over the last 100 times. If the function was never called before, 0.0 is returned.</p> <p>This function can be used when setting a frequency to execute a certain function. When the average execution time of the function is longer than the execution interval, the frequency shall be decreased or the process will get stalled.</p>"},{"location":"api/system/#egse.system.get_average_execution_times","title":"get_average_execution_times","text":"<pre><code>get_average_execution_times()\n</code></pre> <p>Returns a dictionary with <code>key = &lt;function name&gt;</code> and  <code>value = &lt;average execution time&gt;</code>, for all function that have been monitored in this process.</p>"},{"location":"api/system/#egse.system.get_caller_breadcrumbs","title":"get_caller_breadcrumbs","text":"<pre><code>get_caller_breadcrumbs(\n    prefix=\"call stack: \", limit=5, with_filename=False\n)\n</code></pre> <p>Returns a string representing the calling sequence of this function. The string contains the calling sequence from left to right. Each entry has the function name and the line number of the line being executed. When the <code>with_filename</code> is <code>True</code>, also the filename is printed before the function name. If the file is <code>__init__.py</code>, also the parent folder name is printed.</p> <pre><code>&lt;filename&gt;:&lt;function name&gt;[&lt;lineno&gt;] &lt;\u2014 &lt;filename&gt;:&lt;caller function name&gt;[&lt;lineno&gt;]\n</code></pre> <p>Use this function for example if you need to find out when and where a function is called in your process.</p> Example <pre><code>state.py:load_setup[126] &lt;- state.py:setup[103] &lt;- spw.py:__str__[167] &lt;- nfeesim.py:run[575]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>a prefix for the calling sequence [default='call stack: '].</p> <code>'call stack: '</code> <code>limit</code> <code>int</code> <p>the maximum number of caller to go back up the calling stack [default=5].</p> <code>5</code> <code>with_filename</code> <code>bool</code> <p>filename is included in the returned string when True [default=False].</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A string containing the calling sequence.</p>"},{"location":"api/system/#egse.system.get_caller_info","title":"get_caller_info","text":"<pre><code>get_caller_info(level=1)\n</code></pre> <p>Returns the filename, function name and lineno of the caller.</p> <p>The level indicates how many levels to go back in the stack. When level is 0 information about this function will be returned. That is usually not what you want so the default level is 1 which returns information about the function where the call to <code>get_caller_info</code> was made.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>the number of levels to go back in the stack</p> <code>1</code> <p>Returns:</p> Type Description <code>CallerInfo</code> <p>a namedtuple: <code>CallerInfo['filename', 'function', 'lineno']</code>.</p>"},{"location":"api/system/#egse.system.get_current_location","title":"get_current_location","text":"<pre><code>get_current_location()\n</code></pre> <p>Returns the location where this function is called, i.e. the filename, line number, and function name.</p>"},{"location":"api/system/#egse.system.get_full_classname","title":"get_full_classname","text":"<pre><code>get_full_classname(obj)\n</code></pre> <p>Returns the fully qualified class name for the given object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object for which to retrieve the fully qualified class name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully qualified class name, including the module.</p> Example <pre><code>&gt;&gt;&gt; get_full_classname(\"example\")\n'builtins.str'\n\n&gt;&gt;&gt; get_full_classname(42)\n'builtins.int'\n</code></pre> Note <p>The function considers various scenarios, such as objects being classes, built-ins, or literals like int, float, or complex numbers.</p>"},{"location":"api/system/#egse.system.get_host_ip","title":"get_host_ip","text":"<pre><code>get_host_ip()\n</code></pre> <p>Returns the IP address. If no IP address can be found, None will be returned and the caller can try to use localhost.</p>"},{"location":"api/system/#egse.system.get_logging_level","title":"get_logging_level","text":"<pre><code>get_logging_level(level)\n</code></pre> <p>Convert a logging level to its integer representation.</p> <p>This function normalizes various logging level inputs (string names, integer values, or custom level strings) into their corresponding integer logging levels.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str | int</code> <p>The logging level to convert. Can be: - Standard logging level name (e.g., 'DEBUG', 'INFO', 'WARNING') - Integer logging level (e.g., 10, 20, 30) - Custom level string (e.g., 'Level 25')</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The integer representation of the logging level. - Standard levels: DEBUG=10, INFO=20, WARNING=30, ERROR=40, CRITICAL=50 - Custom levels: Extracted integer value or dynamically resolved value</p>"},{"location":"api/system/#egse.system.get_module_location","title":"get_module_location","text":"<pre><code>get_module_location(arg)\n</code></pre> <p>Returns the location of the module as a Path object.</p> <p>The function can be given a string, which should then be a module name, or a function or module. For the latter two, the module name will be determined.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <code>Any</code> <p>can be one of the following: function, module, string</p> required <p>Returns:</p> Type Description <code>Path | None</code> <p>The location of the module as a Path object or None when the location can not be determined or an invalid argument was provided.</p> Example <pre><code>&gt;&gt;&gt; get_module_location('egse')\nPath('/path/to/egse')\n\n&gt;&gt;&gt; get_module_location(egse.system)\nPath('/path/to/egse/system')\n</code></pre> Note <p>If the module is not found or is not a valid module, None is returned.</p> Warning <p>If the module is a namespace, None will be returned. Use the function     is_namespace() to determine if the 'module'     is a namespace.</p>"},{"location":"api/system/#egse.system.get_os_name","title":"get_os_name","text":"<pre><code>get_os_name()\n</code></pre> <p>Returns the name of the OS in lower case.</p> <p>If no name could be determined, 'unknown' is returned.</p> <p>Returns:</p> Name Type Description <code>os</code> <code>str</code> <p>'macos', 'centos'</p>"},{"location":"api/system/#egse.system.get_os_version","title":"get_os_version","text":"<pre><code>get_os_version()\n</code></pre> <p>Return the version of the OS.</p> <p>If no version could be determined, 'unknown' is returned.</p> <p>Returns:</p> Name Type Description <code>version</code> <code>str</code> <p>as '10.15' or '8.0' or 'unknown'</p>"},{"location":"api/system/#egse.system.get_package_description","title":"get_package_description","text":"<pre><code>get_package_description(package_name)\n</code></pre> <p>Returns the description of the package as specified in the projects metadata Summary.</p> Example <pre><code>&gt;&gt;&gt; get_package_description('cgse-common')\n'Software framework to support hardware testing'\n</code></pre>"},{"location":"api/system/#egse.system.get_package_location","title":"get_package_location","text":"<pre><code>get_package_location(module)\n</code></pre> <p>Retrieves the file system locations associated with a Python package.</p> <p>This function takes a module, module name, or fully qualified module path, and returns a list of Path objects representing the file system locations associated with the package. If the module is a namespace package, it returns the paths of all namespaces; otherwise, it returns the location of the module.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>Union[FunctionType, ModuleType, str]</code> <p>The module or module name to retrieve locations for.</p> required <p>Returns:</p> Type Description <code>List[Path]</code> <p>List[Path]: A list of Path objects representing the file system locations.</p> Note <p>If the module is not found or is not a valid module, an empty list is returned.</p>"},{"location":"api/system/#egse.system.get_referenced_var_name","title":"get_referenced_var_name","text":"<pre><code>get_referenced_var_name(obj)\n</code></pre> <p>Returns a list of variable names that reference the given object. The names can be both in the local and global namespace of the object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>object for which the variable names are returned</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>a list of variable names.</p>"},{"location":"api/system/#egse.system.get_system_architecture","title":"get_system_architecture","text":"<pre><code>get_system_architecture()\n</code></pre> <p>Returns the machine type. This is a string describing the processor architecture, like 'i386' or 'arm64', but the exact string is not defined. An empty string can be returned when the type cannot be determined.</p>"},{"location":"api/system/#egse.system.get_system_name","title":"get_system_name","text":"<pre><code>get_system_name()\n</code></pre> <p>Returns the name of the system in lower case.</p> <p>Returns:</p> Name Type Description <code>name</code> <code>str</code> <p>'linux', 'darwin', 'windows', ...</p>"},{"location":"api/system/#egse.system.get_system_stats","title":"get_system_stats","text":"<pre><code>get_system_stats()\n</code></pre> <p>Gather system information about the CPUs and memory usage and return a dictionary with the following information:</p> <ul> <li>cpu_load: load average over a period of 1, 5,and 15 minutes given in in percentage   (i.e. related to the number of CPU cores that are installed on your system) [percentage]</li> <li>cpu_count: physical and logical CPU count, i.e. the number of CPU cores (incl. hyper-threads)</li> <li>total_ram: total physical ram available [bytes]</li> <li>avail_ram:  the memory that can be given instantly to processes without the system going   into swap. This is calculated by summing different memory values depending on the platform   [bytes]</li> <li>boot_time: the system boot time expressed in seconds since the epoch [s]</li> <li>since: boot time of the system, aka Up time [str]</li> </ul> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary with CPU and memory statistics.</p>"},{"location":"api/system/#egse.system.has_internet","title":"has_internet","text":"<pre><code>has_internet(host='8.8.8.8', port=53, timeout=3.0)\n</code></pre> <p>Returns True if we have internet connection.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>hostname or IP address [default: 8.8.8.8 (google-public-dns-a.google.com)]</p> <code>'8.8.8.8'</code> <code>port</code> <code>int</code> <p>53 [service: tcp]</p> <code>53</code> <code>timeout</code> <code>float</code> <p>the time to block before failing on a connection</p> <code>3.0</code> Note <p>This might give the following error codes:</p> <ul> <li>[Errno 51] Network is unreachable</li> <li>[Errno 61] Connection refused (because the port is blocked?)</li> <li>timed out</li> </ul>"},{"location":"api/system/#egse.system.humanize_seconds","title":"humanize_seconds","text":"<pre><code>humanize_seconds(seconds, include_micro_seconds=True)\n</code></pre> <p>The number of seconds is represented as <code>[#D]d [#H]h[#M]m[#S]s.MS</code> where:</p> <ul> <li><code>#D</code> is the number of days if days &gt; 0</li> <li><code>#H</code> is the number of hours if hours &gt; 0</li> <li><code>#M</code> is the number of minutes if minutes &gt; 0 or hours &gt; 0</li> <li><code>#S</code> is the number of seconds</li> <li><code>MS</code> is the number of microseconds</li> </ul> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>the number of seconds</p> required <code>include_micro_seconds</code> <code>bool</code> <p>True if microseconds shall be included</p> <code>True</code> Example <pre><code>&gt;&gt;&gt; humanize_seconds(20)\n'20s.000'\n&gt;&gt;&gt; humanize_seconds(10*24*60*60)\n'10d 00s.000'\n&gt;&gt;&gt; humanize_seconds(10*86400 + 3*3600 + 42.023)\n'10d 03h00m42s.023'\n&gt;&gt;&gt; humanize_seconds(10*86400 + 3*3600 + 42.023, include_micro_seconds=False)\n'10d 03h00m42s'\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>a string representation for the number of seconds.</p>"},{"location":"api/system/#egse.system.ignore_m_warning","title":"ignore_m_warning","text":"<pre><code>ignore_m_warning(modules=None)\n</code></pre> <p>Ignore RuntimeWarning by <code>runpy</code> that occurs when executing a module with <code>python -m package.module</code>, while that module is also imported.</p> <p>The original warning message is:</p> <pre><code>'&lt;package.module&gt;' found in sys.modules after import of package '&lt;package'&gt;,\nbut prior to execution of '&lt;package.module&gt;'\n</code></pre>"},{"location":"api/system/#egse.system.is_in","title":"is_in","text":"<pre><code>is_in(a, b)\n</code></pre> <p>Returns result of <code>a in b</code>.</p>"},{"location":"api/system/#egse.system.is_in_ipython","title":"is_in_ipython","text":"<pre><code>is_in_ipython()\n</code></pre> <p>Returns True if the code is running in IPython.</p>"},{"location":"api/system/#egse.system.is_module","title":"is_module","text":"<pre><code>is_module(module)\n</code></pre> <p>Returns True if the argument is a module or represents a module, False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>str | ModuleType</code> <p>a module or module name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the argument is a module, False otherwise.</p>"},{"location":"api/system/#egse.system.is_namespace","title":"is_namespace","text":"<pre><code>is_namespace(module)\n</code></pre> <p>Checks if a module represents a namespace package.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>str | ModuleType</code> <p>The module to be checked.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the argument is a namespace package, False otherwise.</p> Note <p>A namespace package is a special kind of package that spans multiple directories or locations, but doesn't contain an <code>__init__.py</code> file in any of its directories.</p> <p>Technically, a namespace package is defined as a module that has a <code>__path__</code> attribute and no <code>__file__</code> attribute.</p> <p>A namespace package allows for package portions to be distributed independently.</p>"},{"location":"api/system/#egse.system.is_not_in","title":"is_not_in","text":"<pre><code>is_not_in(a, b)\n</code></pre> <p>Returns result of <code>a not in b</code>.</p>"},{"location":"api/system/#egse.system.is_package_installed","title":"is_package_installed","text":"<pre><code>is_package_installed(package_name)\n</code></pre> <p>Check if a package is installed.</p>"},{"location":"api/system/#egse.system.kebab_to_title","title":"kebab_to_title","text":"<pre><code>kebab_to_title(kebab_str)\n</code></pre> <p>Convert kebab-case to Title Case (each word capitalized)</p>"},{"location":"api/system/#egse.system.now","title":"now","text":"<pre><code>now(utc=True)\n</code></pre> <p>Returns a datetime object for the current time in UTC or local time.</p>"},{"location":"api/system/#egse.system.ping","title":"ping","text":"<pre><code>ping(host, timeout=3.0)\n</code></pre> <p>Sends a ping request to the given host.</p> <p>Remember that a host may not respond to a ping (ICMP) request even if the host name is valid.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>hostname or IP address (as a string)</p> required <code>timeout</code> <code>float</code> <p>timeout in seconds</p> <code>3.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True when host responds to a ping request.</p> Reference <p>SO \u2013 Pinging servers in Python</p>"},{"location":"api/system/#egse.system.read_last_line","title":"read_last_line","text":"<pre><code>read_last_line(filename, max_line_length=5000)\n</code></pre> <p>Returns the last line of a (text) file.</p> <p>The argument <code>max_line_length</code> should be at least the length of the last line in the file, because this value is used to backtrack from the end of the file as an optimization.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path | str</code> <p>the filename as a string or Path</p> required <code>max_line_length</code> <code>int</code> <p>the maximum length of the lines in the file</p> <code>5000</code>"},{"location":"api/system/#egse.system.read_last_lines","title":"read_last_lines","text":"<pre><code>read_last_lines(filename, num_lines)\n</code></pre> <p>Return the last lines of a text file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | Path</code> <p>Filename.</p> required <code>num_lines</code> <code>int</code> <p>Number of lines at the back of the file that should be read and returned.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>Last lines of a text file as a list of strings. An empty list is returned when the file doesn't exist.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>when the requested num_lines is zero (0) or a negative number.</p>"},{"location":"api/system/#egse.system.recursive_dict_update","title":"recursive_dict_update","text":"<pre><code>recursive_dict_update(this, other)\n</code></pre> <p>Recursively update a dictionary <code>this</code> with the content of another dictionary <code>other</code>.</p> <p>Any key in <code>this</code> dictionary will be recursively updated with the value of the same key in the <code>other</code> dictionary.</p> <p>Please note that the update will be in-place, i.e. the <code>this</code> dictionaory will be changed/updated. <pre><code>&gt;&gt;&gt; global_settings = {\"A\": \"GA\", \"B\": \"GB\", \"C\": \"GC\"}\n&gt;&gt;&gt; local_settings = {\"B\": \"LB\", \"D\": \"LD\"}\n&gt;&gt;&gt; {**global_settings, **local_settings}\n{'A': 'GA', 'B': 'LB', 'C': 'GC', 'D': 'LD'}\n\n&gt;&gt;&gt; global_settings = {\"A\": \"GA\", \"B\": \"GB\", \"C\": \"GC\", \"R\": {\"X\": \"GX\", \"Y\": \"GY\"}}\n&gt;&gt;&gt; local_settings = {\"B\": \"LB\", \"D\": \"LD\", \"R\": {\"Y\": \"LY\"}}\n&gt;&gt;&gt; recursive_dict_update(global_settings, local_settings)\n{'A': 'GA', 'B': 'LB', 'C': 'GC', 'R': {'X': 'GX', 'Y': 'LY'}, 'D': 'LD'}\n\n&gt;&gt;&gt; global_settings = {\"A\": {\"B\": {\"C\": {\"D\": 42}}}}\n&gt;&gt;&gt; local_settings = {\"A\": {\"B\": {\"C\": 13, \"D\": 73}}}\n&gt;&gt;&gt; recursive_dict_update(global_settings, local_settings)\n{'A': {'B': {'C': 13, 'D': 73}}}\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>this</code> <code>dict</code> <p>The origin dictionary</p> required <code>other</code> <code>dict</code> <p>Changes that shall be applied to <code>this</code></p> required <p>Returns:</p> Type Description <code>dict</code> <p>The original <code>this</code> dictionary with the recursive updates.</p>"},{"location":"api/system/#egse.system.replace_environment_variable","title":"replace_environment_variable","text":"<pre><code>replace_environment_variable(input_string)\n</code></pre> <p>Returns the <code>input_string</code> with all occurrences of ENV['var'].</p> <pre><code>&gt;&gt;&gt; replace_environment_variable(\"ENV['HOME']/data/CSL\")\n'/Users/rik/data/CSL'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>input_string</code> <code>str</code> <p>the string to replace</p> required"},{"location":"api/system/#egse.system.round_up","title":"round_up","text":"<pre><code>round_up(n, decimals=0)\n</code></pre> <p>Round a number up to a specified number of decimal places.</p> <p>This function rounds the input number upward (toward positive infinity) regardless of the value of the digits being rounded. It uses math.ceil() after multiplying by a power of 10 to achieve the specified precision.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float or int</code> <p>The number to round up.</p> required <code>decimals</code> <code>int</code> <p>The number of decimal places to round to. Must be non-negative. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>float</code> <p>The rounded number with the specified precision.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; round_up(3.14159, 3)\n3.142\n&gt;&gt;&gt; round_up(3.1409, 3)\n3.141\n&gt;&gt;&gt; round_up(-3.14159, 3)\n-3.141\n&gt;&gt;&gt; round_up(5, 2)\n5.0\n</code></pre> Note <p>For negative numbers, \"rounding up\" means rounding toward zero, so -3.14159 rounded up to 3 decimals is -3.141.</p>"},{"location":"api/system/#egse.system.sanity_check","title":"sanity_check","text":"<pre><code>sanity_check(flag, msg)\n</code></pre> <p>Checks a boolean flag and raises an AssertionError with the provided message if the check fails.</p> <p>This function serves as a replacement for the 'assert' statement in production code. Using this ensures that your checks are not removed during optimizations.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>The boolean flag to be checked.</p> required <code>msg</code> <code>str</code> <p>The message to be included in the AssertionError if the check fails.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the flag is False.</p> Example <pre><code>&gt;&gt;&gt; sanity_check(x &gt; 0, \"x must be greater than 0\")\n</code></pre> Note <p>This function is designed for production code to perform runtime checks that won't be removed during optimizations.</p>"},{"location":"api/system/#egse.system.save_average_execution_time","title":"save_average_execution_time","text":"<pre><code>save_average_execution_time(func, *args, **kwargs)\n</code></pre> <p>Executes the function 'func' with the given arguments and saves the execution time. All positional arguments (in args) and keyword arguments (in kwargs) are passed into the function. The execution time is saved in a deque of maximum 100 elements. When more times are added, the oldest times are discarded. This function is used in conjunction with the get_average_execution_time() function.</p>"},{"location":"api/system/#egse.system.snake_to_title","title":"snake_to_title","text":"<pre><code>snake_to_title(snake_str)\n</code></pre> <p>Convert snake_case to Title Case (each word capitalized)</p>"},{"location":"api/system/#egse.system.str_to_datetime","title":"str_to_datetime","text":"<pre><code>str_to_datetime(datetime_string)\n</code></pre> <p>Convert the given string to a datetime object.</p> <p>Parameters:</p> Name Type Description Default <code>datetime_string</code> <code>str</code> <p>String representing a datetime, in the format <code>%Y-%m-%dT%H:%M:%S.%f%z</code>.</p> required <p>Returns:</p> Type Description <code>datetime</code> <p>a datetime object.</p>"},{"location":"api/system/#egse.system.time_in_ms","title":"time_in_ms","text":"<pre><code>time_in_ms()\n</code></pre> <p>Returns the current time in milliseconds since the Epoch.</p> Note <p>if you are looking for a high performance timer, you should really be using <code>perf_counter()</code>   instead of this function.</p>"},{"location":"api/system/#egse.system.time_since_epoch_1958","title":"time_since_epoch_1958","text":"<pre><code>time_since_epoch_1958(datetime_string)\n</code></pre> <p>Calculate the time since epoch 1958 for the given string representation of a datetime.</p> <p>Parameters:</p> Name Type Description Default <code>datetime_string</code> <code>str</code> <p>String representing a datetime, in the format <code>%Y-%m-%dT%H:%M:%S.%f%z</code>.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Time since the 1958 epoch [s].</p>"},{"location":"api/system/#egse.system.touch","title":"touch","text":"<pre><code>touch(path)\n</code></pre> <p>Unix-like 'touch', i.e. create a file if it doesn't exist and set the modification time to the current time.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>full path to the file, can start with <code>~</code> which is automatically expanded.</p> required"},{"location":"api/system/#egse.system.type_name","title":"type_name","text":"<pre><code>type_name(var)\n</code></pre> <p>Returns the name of the type of var.</p>"},{"location":"api/system/#egse.system.wait_until","title":"wait_until","text":"<pre><code>wait_until(\n    condition,\n    *args,\n    interval=0.1,\n    timeout=1.0,\n    verbose=False,\n    **kwargs,\n)\n</code></pre> <p>Sleep until the given condition is fulfilled. The arguments are passed into the condition callable which is called in a while loop until the condition is met or the timeout is reached.</p> <p>Note that the condition can be a function, method or callable class object. An example of the latter is:</p> <pre><code>class SleepUntilCount:\n    def __init__(self, end):\n        self._end = end\n        self._count = 0\n\n    def __call__(self, *args, **kwargs):\n        self._count += 1\n        if self._count &gt;= self._end:\n            return True\n        else:\n            return False\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Callable</code> <p>a callable that returns True when the condition is met, False otherwise</p> required <code>interval</code> <code>float</code> <p>the sleep interval between condition checks [s, default=0.1]</p> <code>0.1</code> <code>timeout</code> <code>float</code> <p>the period after which the function returns, even when the condition is not met [s, default=1]</p> <code>1.0</code> <code>verbose</code> <code>bool</code> <p>log debugging messages if True</p> <code>False</code> <code>*args</code> <code>list</code> <p>any arguments that will be passed into the condition function</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>any keyword arguments that will be passed into the condition function</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True when function timed out, False otherwise.</p>"},{"location":"api/system/#egse.system.waiting_for","title":"waiting_for","text":"<pre><code>waiting_for(\n    condition,\n    *args,\n    interval=0.1,\n    timeout=1.0,\n    verbose=False,\n    **kwargs,\n)\n</code></pre> <p>Sleep until the given condition is fulfilled. The arguments are passed into the condition callable which is called in a while loop until the condition is met or the timeout is reached.</p> <p>Note that the condition can be a function, method or callable class object. An example of the latter is:</p> <pre><code>class SleepUntilCount:\n    def __init__(self, end):\n        self._end = end\n        self._count = 0\n\n    def __call__(self, *args, **kwargs):\n        self._count += 1\n        if self._count &gt;= self._end:\n            return True\n        else:\n            return False\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Callable</code> <p>a callable that returns True when the condition is met, False otherwise</p> required <code>interval</code> <code>float</code> <p>the sleep interval between condition checks [s, default=0.1]</p> <code>0.1</code> <code>timeout</code> <code>float</code> <p>the period after which the function returns, even when the condition is not met [s, default=1]</p> <code>1.0</code> <code>verbose</code> <code>bool</code> <p>log debugging messages if True</p> <code>False</code> <code>*args</code> <code>list</code> <p>any arguments that will be passed into the condition function</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>any keyword arguments that will be passed into the condition function</p> <code>{}</code> <p>Returns:</p> Type Description <code>float</code> <p>The duration until the condition was met.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>when the condition was not fulfilled within the timeout period.</p>"},{"location":"dev_guide/","title":"Developer Guide","text":"<p>Welcome to the CGSE developer guide! An in-depth reference on how to contribute to the CGSE.</p> <p>First thing to know is that this repository is actually a monorepo, meaning it contains a bunch of related but self-standing packages with a minimum of interdependencies. A monorepo can grow quite big and can contain a lot of packages that even different groups are working on. What they have in common is that they use the same guidelines and have the same or a very similar development  workflow.</p> <p>Don't confuse a monorepo with a monolith or a monolithic architecture. While a monorepo holds multiple related but more-or-less independent projects, a monolith is a traditional software application or architecture which is an often huge, self-contained and independent unit of code that is highly coupled and difficult to maintain.</p> <p>Don't confuse a monorepo with microservices either. A microservice architecture contains units that run independently and are developed, scaled and deployed without affecting the other units or services. You can set up a monorepo containing all of your microservices with ease, one does not need the other, but they can perfectly go together.</p>"},{"location":"dev_guide/coding_style/","title":"Style Guide","text":"<p>This part of the developer guide contains instructions for coding styles that are adopted for this project.</p> <p>The style guide that we use for this project is PEP8. This is the standard for Python code and all IDEs, parsers and code formatters understand and work with this standard. PEP8 leaves room for project specific styles. A good style guide that we can follow is the Google Style Guide.</p> <p>The following sections will give the most used conventions with a few examples of good and bad.</p>"},{"location":"dev_guide/coding_style/#tldr","title":"TL;DR","text":"Type Style Example Classes CapWords ProcessManager, ImageViewer, CommandList, Observation, MetaData Methods &amp; Functions lowercase with underscores get_value, set_mask, create_image Variables lowercase with underscores key, last_value, model, index, user_info Constants UPPERCASE with underscores MAX_LINES, BLACK, COMMANDING_PORT Modules &amp; packages lowercase no underscores dataset, commanding, multiprocessing"},{"location":"dev_guide/coding_style/#general","title":"General","text":"<ul> <li> <p>Name the class or variable or function with what it is, what it does or what it contains. A variable named <code>user_list</code> might look good at first, but what if at some point you want to change the list to a set so it can not contain duplicates. Are you going to rename everything into <code>user_set</code> or would <code>user_info</code> be a better name?</p> </li> <li> <p>Never use dashes in any name that will be interpreted by Python, they will raise a <code>SyntaxError:    invalid syntax</code>.</p> </li> <li> <p>We introduce a number of relaxations to not break backward compatibility for the sake of a naming convention. As described in A Foolish Consistency is the Hobgoblin of Little Minds: Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important. [...] do not break backwards compatibility just to comply with this PEP!</p> </li> </ul> <p>Note</p> <p>You will sometimes see that we use one or two words between <code>&lt; &gt;</code> angle brakcets. That means  you will have to replace that text AND the brackets with your own text. As an example, if you see <code>--prompt &lt;venv name&gt;</code>, replace this with something like <code>--prompt cgse-venv</code>.  </p>"},{"location":"dev_guide/coding_style/#classes","title":"Classes","text":"<p>Always use CamelCase (Python uses CapWords) for class names. When using acronyms, keep them all UPPER case.</p> <ul> <li>Class names should be nouns, like Observation</li> <li>Make sure to name classes distinctively</li> <li>Stick to one word for a concept when naming classes, i.e. words like <code>Manager</code> or <code>Controller</code> or <code>Organizer</code> all mean similar things. Choose one word for the concept and stick to it.</li> <li>If a word is already part of a package or module, don't use the same word in the class name again.</li> </ul> <p>Good names are: <code>Observation</code>, <code>CalibrationFile</code>, <code>MetaData</code>, <code>Message</code>, <code>ReferenceFrame</code>, <code>URLParser</code>.</p>"},{"location":"dev_guide/coding_style/#methods-and-functions","title":"Methods and Functions","text":"<p>A function or a method does something (and should only do one thing, SRP=Single Responsibility Principle), it is an action, so the name should reflect that action.</p> <p>Always use lowercase words separated with underscores.</p> <p>Good names are: <code>get_time_in_ms()</code>, <code>get_commanding_port()</code>, <code>is_connected()</code>, <code>parse_time()</code>, <code>setup_mask()</code>.</p> <p>When working with legacy code or code from another project, names may be in camelCase (with the first letter a lower case letter). So we can in this case use also <code>getCommandPort()</code> or <code>isConnected()</code> as method and function names.</p>"},{"location":"dev_guide/coding_style/#variables","title":"Variables","text":"<p>Use the same naming convention as functions and methods, i.e. lowercase with underscores.</p> <p>Good names are: <code>key</code>, <code>value</code>, <code>user_info</code>, <code>model</code>, <code>last_value</code></p> <p>Bad names: <code>NSegments</code>, <code>outNoise</code></p> <p>Take care not to use builtins: <code>list</code>, <code>type</code>, <code>filter</code>, <code>lambda</code>, <code>map</code>, <code>dict</code>, ...</p> <p>Private variables (for classes) start with an underscore: <code>_name</code> or <code>_total_n_args</code>.</p> <p>In the same spirit as method and function names, the variables can also be in camelCase for specific cases.</p>"},{"location":"dev_guide/coding_style/#constants","title":"CONSTANTS","text":"<p>Use ALL_UPPER_CASE with underscores for constants. Use constants always within a name space, not globally.</p> <p>Good names: <code>MAX_LINES</code>, <code>BLACK</code>, <code>YELLOW</code>, <code>ESL_LINK_MODE_DISABLED</code></p>"},{"location":"dev_guide/coding_style/#modules-and-packages","title":"Modules and Packages","text":"<p>Use simple words for modules, preferably just one word like <code>datasets</code> or <code>commanding</code> or <code>storage</code> or <code>extensions</code>. If two words are unavoidable, just concatenate them, like <code>multiprocessing</code> or <code>sampledata</code> or <code>testdata</code>. If needed for readability, use an underscore to separate the words, e.g. <code>image_analysis</code>.</p>"},{"location":"dev_guide/coding_style/#import-statements","title":"Import Statements","text":"<ul> <li>Group and sort import statements</li> <li>Never use the form <code>from &lt;module&gt; import *</code></li> <li>Always use absolute imports in scripts</li> </ul> <p>Be careful that you do not name any modules the same as a module in the Python standard library. This can result in strange effects and may result in an <code>AttributeError</code>. Suppose you have named a module <code>math</code> in the <code>egse</code> directory and it is imported and used further in the code as follows:</p> <pre><code>from egse import math\n\n# in some expression further down the code you might use\n\nmath.exp(a)\n</code></pre> <p>This will result in the following runtime error:</p> <pre><code>File \"some_module.py\", line 8, in &lt;module&gt;\n  print(math.exp(a))\nAttributeError: module 'egse.math' has no attribute 'exp'\n</code></pre> <p>Of course this is an obvious example, but it might be more obscure like e.g. in this GitHub issue: 'module'  object has no attribute 'Cmd'.</p>"},{"location":"dev_guide/docs/","title":"Building the documentation","text":"<ul> <li>Make sure you are in a virtual environment with Python 3.9+ or use the <code>uv</code> commands as   demonstrated below.</li> <li>Run the <code>mkdocs serve</code> from the project root older</li> <li>Create new pages by adding folder and Markdown files inside <code>docs/*</code></li> </ul>"},{"location":"dev_guide/docs/#set-up-your-environment","title":"Set up your environment","text":"<p>The <code>pyproject.toml</code> file of the <code>cgse</code> root contains additional dependencies for running the <code>mkdocs</code> commands. When working on the documentation, make sure you have installed the 'docs' dependency group. Currently, only <code>mkdocs</code> and <code>mkdocs-material</code> are needed. You can use the  following command to add the documentation dependencies to your development environment.</p> <pre><code>$ cd ~/github/cgse\n$ uv sync --all-packages --all-groups\n</code></pre> <p>Now you can start the live-reload server of <code>mkdocs</code>. This will recreate the documentation  whenever you make a change in the files below the <code>docs</code> folder. After starting this command,  navigate to the <code>http://127.0.0.1:8000/cgse/</code> site in your favorite browser.</p> <pre><code>$ uv run mkdocs serve\n</code></pre> <p>Now you can update files, create new folders in <code>docs/*</code>, create new Markdown files and all changes will be reloaded live in the browser.</p> <p>When you are ready with updating, you will need to build the site and publish it on GitHub pages:</p> <pre><code>$ uv run mkdocs build\n$ uv run mkdocs gh-deploy -r upstream -m \"documentation update on ..\"\n</code></pre>"},{"location":"dev_guide/docs/#commands","title":"Commands","text":"<ul> <li><code>mkdocs serve</code> \u2014 start the live-reloading docs server</li> <li><code>mkdocs build</code> \u2014 build the documentation site</li> <li><code>mkdocs deploy</code> \u2014 publish your documentation on GitHub pages</li> <li><code>mkdocs -h</code> \u2014 print a help message for more options</li> </ul>"},{"location":"dev_guide/docs/#project-layout","title":"Project layout","text":"<p>The documentation pages follow more or less the structure of the code in terms of libs and  projects. Below I have laid out this structure leaving out less important files and folders. </p> <pre><code>mkdocs.yml         # the mkdocs configuration file\ndocs\n\u251c\u2500\u2500 index.md       # the documentation homepage\n\u251c\u2500\u2500 initialize.md\n\u251c\u2500\u2500 getting_started.md\n\u251c\u2500\u2500 package_list.md\n\u251c\u2500\u2500 dev_guide/\n\u251c\u2500\u2500 user_guide/\n\u251c\u2500\u2500 libs\n\u2502   \u251c\u2500\u2500 cgse-common/\n\u2502   \u251c\u2500\u2500 cgse-coordinates/\n\u2502   \u251c\u2500\u2500 cgse-core/\n\u2502   \u251c\u2500\u2500 cgse-gui/\n\u2502   \u2514\u2500\u2500 index.md\n\u251c\u2500\u2500 projects/\n\u2502   \u251c\u2500\u2500 cgse-tools.md\n\u2502   \u251c\u2500\u2500 symetrie-hexapod.md\n\u2502   \u2514\u2500\u2500 index.md\n\u251c\u2500\u2500 images/\n\u2514\u2500\u2500 roadmap.md\n</code></pre>"},{"location":"dev_guide/installation/","title":"Installation Guide for Developers","text":""},{"location":"dev_guide/installation/#python","title":"Python","text":"<p>You will notice that I use the <code>py</code> command often in examples. This is not just a shortcut, but  the command that is installed by the <code>python-launcer</code> and determines which Python executable  shall be started. You can install the <code>python-launcher</code> with:</p> <pre><code>$ cargo install python-launcher\n</code></pre> <p>Then add the following line to your <code>.bash_profile</code> if not already there:</p> <pre><code>export PATH=~/.local/bin:~/.cargo/bin:$PATH`\n</code></pre> <p>If you do not want to install the <code>python-launcher</code>, just replace <code>py</code> with <code>python</code> or  <code>python3</code> in the examples.</p>"},{"location":"dev_guide/installation/#github","title":"GitHub","text":"<p>Before starting, make sure you have a fork of the <code>cgse</code> repository. Through this fork (which  resides on the GitHub  server) you will create pull requests. Install a clone of your fork on  your local machine or laptop.</p> <p> </p> <p>So, when you have created a fork in your GitHub account, clone the repository on your local  machine.  For the purpose of this guide we will clone the repo in the <code>~/github/cgse</code> folder.  The following commands will create the required folders and clone the repo.</p> <pre><code>$ mkdir -p ~/github\n$ cd ~/github\n$ git clone git@github.com:IvS-KULeuven/cgse.git\n$ cd ~/github/cgse\n</code></pre> <p>Now you will have to create a virtual environment and populated it with all the dependencies. </p> <p>Note</p> <p>The following three commands will get you going quickly: <pre><code>$ uv venv --python 3.9.20\n$ uv sync --all-packages\n$ uv run cgse\n\nUsage: cgse [OPTIONS] COMMAND [ARGS]...\n\nThe main cgse command to inspect, configure, monitor the core services and device control \nservers.\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --install-completion          Install completion for the current shell.                                        \u2502\n\u2502 --show-completion             Show completion for the current shell, to copy it or customize the installation. \u2502\n\u2502 --help                        Show this message and exit.                                                      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 version   Prints the version of the cgse-core and other registered packages.                                   \u2502\n\u2502 top       A top-like interface for core services and device control servers.                                   \u2502\n\u2502 clock     Showcase for running an in-line Textual App.                                                         \u2502\n\u2502 init      Initialize your project.                                                                             \u2502\n\u2502 show      Show information about settings, environment, setup, ...                                             \u2502\n\u2502 check     Check installation, settings, required files, etc.                                                   \u2502\n\u2502 dev-x     device-x is an imaginary device that serves as an example                                            \u2502\n\u2502 core      handle core services: start, stop, status                                                            \u2502\n\u2502 puna      PUNA Positioning Hexapod, Sym\u00e9trie                                                                   \u2502\n\u2502 daq6510   DAQ6510 Data Acquisition Unit, Keithley, temperature monitoring                                      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre></p>"},{"location":"dev_guide/monitoring/","title":"Monitoring with InfluxDB and Grafana","text":"<p>The CGSE provides mechanisms to monitor metrics from different processes and devices.  These are  collected by InfluxDB and are visualised by means of Grafana dashboards.</p> <p>In this section, we explain how to install both InfluxDB and Grafana on the Server, how to set up and populate a database  in InfluxDB, and how to visualise the metrics in Grafana dashboards.</p>"},{"location":"dev_guide/monitoring/#installation","title":"Installation","text":""},{"location":"dev_guide/monitoring/#influxdb3-core","title":"InfluxDB3 Core","text":"<p>To install InfluxDB3 Core, execute this in a Terminal on the Server:</p> <pre><code>curl -s https://repos.influxdata.com/influxdata-archive_compat.key &gt; influxdata-archive_compat.key\n\necho '393e8779c89ac8d958f81f942f9ad7fb82a25e133faddaf92e15b16e6ac9ce4c influxdata-archive_compat.key' | sha256sum -c &amp;&amp; cat influxdata-archive_compat.key | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/influxdata-archive_compat.gpg &gt; /dev/null\necho 'deb [signed-by=/etc/apt/trusted.gpg.d/influxdata-archive_compat.gpg] https://repos.influxdata.com/debian stable main' | sudo tee /etc/apt/sources.list.d/influxdata.list\n\nsudo apt-get update\n\nsudo apt-get install influxdb3-core\n</code></pre> <p>For database management, you will need a token to interact with InfluxDB.  This can be generated as follows (in a  Terminal on the Server):</p> <pre><code>influxdb3 create token --admin\n</code></pre> <p>This will print out a token, starting with <code>apiv3_</code>.  Export this value as environment variable <code>INFLUXDB3_AUTH_TOKEN</code>.</p>"},{"location":"dev_guide/monitoring/#grafana","title":"Grafana","text":"<p>To install Grafana, execute this in a Terminal on the Server:</p> <pre><code>sudo apt-get install -y apt-transport-https software-properties-common wget\n\nsudo mkdir -p /etc/apt/keyrings/\nwget -q -O - https://apt.grafana.com/gpg.key | gpg --dearmor | sudo tee /etc/apt/keyrings/grafana.gpg &gt; /dev/null\n\necho \"deb [signed-by=/etc/apt/keyrings/grafana.gpg] https://apt.grafana.com stable main\" | sudo tee -a /etc/apt/sources.list.d/grafana.list\nsudo apt-get update\n\nsudo apt-get install grafana\n\nsudo /bin/systemctl daemon-reload\nsudo /bin/systemctl enable grafana-server\n</code></pre>"},{"location":"dev_guide/monitoring/#database-structure","title":"Database Structure","text":""},{"location":"dev_guide/monitoring/#database-name","title":"Database Name","text":"<p>In the current implementation, the name of the database in which all CGSE metrics are stored, is taken  from the <code>PROJECT</code> environment variable.  At a later stage, we could change this by means of a dedicated  environment variable or by specifying it in the local settings file.</p> <p>To inspect the names of the available databases, execute this in a Terminal on the Server:</p> <pre><code>influxdb3 show databases\n</code></pre> <p>The command to create a database manually (from a Terminal on the Server) is:</p> <pre><code>influxdb3 create database &lt;database name&gt;\n</code></pre>"},{"location":"dev_guide/monitoring/#table-names","title":"Table Names","text":"<p>For each of the processes, we have a dedicated table in the database, the name of which is the same as  the storage mnemonic of the process.</p> <p>To get an overview of the available tables, execute this in a Terminal on the Server:</p> <pre><code>influxdb3 query --database &lt;database name&gt; \"SHOW TABLES\"\n</code></pre>"},{"location":"dev_guide/monitoring/#content-of-the-tables","title":"Content of the Tables","text":"<p>For each table, the column names are the names of the corresponding housekeeping/metrics parameters.  The name of the column with the timestamp is <code>TIME</code>. </p> <p>To get an overview of the columns for a given table in a given database, execute this in a Terminal on the Server:</p> <pre><code>influxdb3 query --database &lt;database name&gt; \"SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = '&lt;table name&gt;'\"\n</code></pre> <p>To get an overview of the data stored in a given table (sorted by ascending order of timestamp), execute this in a  Terminal on the Server:</p> <pre><code>influxdb3 query --database &lt;database name&gt; \"SELECT * FROM &lt;table name&gt; ORDER BY TIME\"\n</code></pre>"},{"location":"dev_guide/monitoring/#propagating-metrics-to-influxdb-via-python","title":"Propagating Metrics to InfluxDB via Python","text":"<p>To populate the metrics in InfluxDB, we use the Python package <code>influxdb3-python</code>. This has been added to the <code>pyproject.toml</code>  file of the <code>cgse-common</code> module.</p> <p>When implementing a new device, nothing has to be done specifically to propagate the metrics to InfluxDB.  This is  automatically being taken care of in the <code>serve</code> method of the <code>ControlServer</code> class.  In the section where the  housekeeping information is written to a dedicated CSV file, the <code>propagate_metrics</code> method of the <code>ControlServer</code>  class is called and this takes care of everything.</p>"},{"location":"dev_guide/monitoring/#visualisation-of-the-metrics","title":"Visualisation of the Metrics","text":"<p>The Metrics are visualised in Grafana dashboards, but before we can start building those, we have to instruct Grafana to  interpret InfluxDB as its data source.</p>"},{"location":"dev_guide/monitoring/#adding-influxdb-as-data-source","title":"Adding InfluxDB as Data Source","text":"<p>After the InfluxDB and Grafana processes have been started, you can access Grafana in your browser via http://localhost:3000. </p> <p>On the left-hand side, select (under \"Connections\") \"Add new connection\" and search for \"Influx DB\".  After clicking on  the search result, a Settings tab will open, in which you have to enter the following information:</p> <ul> <li><code>Name</code>: Arbitrary name for the data source (it's a good idea to make this reflect the database you are settings up, e.g. <code>influxdb3-ariel</code>);</li> <li><code>Query language</code>: Select \"SQL\";</li> <li><code>HTTP</code> &gt; <code>URL</code>: <code>http://127.0.0.1:8181</code>;</li> <li><code>Auth</code>: Only enable \"Basic auth\";</li> <li><code>InfluxDB Details</code> &gt; <code>Database</code>: Name of the database for which you want to create Grafana dashboards;</li> <li><code>InfluxDB Details</code> &gt; <code>Token</code>: InfluxDB token you have created earlier (see above; starting with <code>apiv3_</code>);</li> <li><code>InfluxDB Details</code>: Enable \"Insecure Connection\".</li> </ul> <p>After having configured all of this, press \"Save &amp; test\".</p>"},{"location":"dev_guide/monitoring/#creating-grafana-dashboards","title":"Creating Grafana Dashboards","text":"<p>Creating a Grafana dashboard can be done by clicking \"Dashboards\" on the left-hand side.  In the \"Queries\" tab of such a  dashboard panel, you have to specify the following information:</p> <ul> <li><code>Data source</code>: Name of the data source you have just created (selectable via a drop-down menu);</li> <li><code>Table</code>: Name of the table for which you want to visualise metrics.  Remember that this is the same as the storage            mnemonic of the process generating the metrics (selectable via a drop-down menu);</li> <li><code>Data operations</code>: Besides the name of the metric (selectable via a drop-down menu), you also have to add <code>time</code> under                       <code>Data Operations</code>, to make sure Grafana recognises and is able to show the timestamp in its panels.                      Have a look at the screenshot below for an example.   </li> </ul>"},{"location":"dev_guide/monitoring/#open-questions","title":"Open Questions","text":"<ul> <li>How can we specify the data retention period?</li> <li>Is it ok to use the <code>PROJECT</code> environment variable as name of the database or should this be configurable (e.g. via    the local settings, an extra environment variable)?</li> <li>Is ms the desired write precision of the timestamp?  Should this be configurable (via the local settings)?</li> </ul>"},{"location":"dev_guide/monorepo/","title":"The structure of this monorepo","text":"<p>Currently, the structure starts with two main folders in the root, i.e. <code>libs</code> and <code>projects</code>. Where libs contains library type packages like common modules, small generic gui and tui functions, reference frames, ... and projects contain packages that build upon these libraries and can be device drivers or stand-alone applications.</p> <p>There is one package that I think doesn't fit into this picture, that is <code>cgse-core</code>. This is not a library, but a \u2013 collection of \u2013 service(s). So, we might want to add a third top-level folder <code>services</code> but I also fear that this again more complicates the monorepo.</p> <p>Anyway, the overall structure of the monorepo is depicted below:</p> <pre><code>cgse/\n\u2502\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 libs/\n\u2502   \u251c\u2500\u2500 cgse-common/\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u2514\u2500\u2500 pyproject.toml\n\u2502   \u251c\u2500\u2500 cgse-core/\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u2514\u2500\u2500 pyproject.toml\n\u2502   \u251c\u2500\u2500 cgse-coordinates/\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u2514\u2500\u2500 pyproject.toml\n\u2502   \u2514\u2500\u2500 cgse-gui/\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u2514\u2500\u2500 pyproject.toml\n\u2502\n\u2514\u2500\u2500 projects/\n    \u251c\u2500\u2500 generic/\n    \u2502   \u251c\u2500\u2500 cgse-tools/\n    \u2502   \u251c\u2500\u2500 keithley-tempcontrol/\n    \u2502   \u2514\u2500\u2500 symetrie-hexapod/\n    \u2514\u2500\u2500 plato/\n        \u251c\u2500\u2500 plato-spw/\n        \u251c\u2500\u2500 plato-fits/\n        \u2514\u2500\u2500 plato-hdf5/\n</code></pre> <p>We will discuss the structure of individual packages in a later section, for now let's look at the root of the monorepo. The root also contains a <code>pyproject.toml</code> file although this is not a package that will be build and published. The purpose of this root <code>pyproject.toml</code> file is to define properties that are used to build the full repo or any individual package in it. In the root folder we will also put some maintenance/management scripts to help you maintain and bump versions of the projects, build and publish all projects, create and maintain a changelog etc.</p>"},{"location":"dev_guide/monorepo/#package-structure","title":"Package Structure","text":"<p>We try to keep the package structure as standard as possible and consistent over the whole monorepo. The structure currently is as follows (example from cgse-common):</p> <pre><code>\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 egse/  # namespace, i.e. there shall not be a __init__.py in this folder\n\u2502       \u251c\u2500\u2500 modules (*.py)\n\u2502       \u2514\u2500\u2500 &lt;sub-packages&gt;/  # these do contain a __init__.py\n\u2514\u2500\u2500 tests/\n    \u251c\u2500\u2500 data\n    \u2514\u2500\u2500 pytest modules (test_*.py)\n</code></pre> <p>Note that each library or project is a standalone Python package with its own <code>pyproject.toml</code> file, source code and unit tests.</p>"},{"location":"dev_guide/monorepo/#package-versions","title":"Package versions","text":"<p>All packages within the monorepo maintain synchronized versioning, ensuring consistency across the entire codebase. This unified versioning approach is managed through the <code>bump.py</code> utility script. When executed, this script first reads the current version from the root <code>pyproject.toml</code> file, which serves as the canonical version source. Based on semantic versioning principles, it then increments the specified component (major, minor, or patch) according to the development team's requirements:</p> <ul> <li>Major version increments (x.0.0) for backward-incompatible API changes</li> <li>Minor version increments (0.x.0) for backward-compatible feature additions</li> <li>Patch version increments (0.0.x) for backward-compatible bug fixes</li> </ul> <p>After determining the new version number, <code>bump.py</code> automatically propagates this updated version to all library and project configuration files throughout the monorepo structure, i.e. updating their respective <code>pyproject.toml</code>. This ensures that all components reference the same version number when built or published, simplifying dependency management and maintaining a clear release history across the entire project ecosystem.</p>"},{"location":"dev_guide/monorepo/#the-egse-namespace","title":"The egse namespace","text":"<p>You may have noticed that all packages in this monorepo follow a standardized structure with source code organized under <code>src/egse</code> directories, typically within subject-specific sub-packages. It's crucial to understand that the <code>egse</code> folder is not a conventional Python package but rather a PEP 420 namespace package. This distinction carries two critical implications:</p> <ol> <li> <p>No <code>__init__.py</code> files in namespace directories: A namespace package must    never contain an <code>__init__.py</code> module at the namespace level. This    applies universally across all repositories using this namespace. Adding    an <code>__init__.py</code> file to any <code>egse</code> directory would compromise the namespace    mechanism, breaking compatibility with external plugins, extensions, and    contributions. The absence of this file is what enables Python to recognize    and properly resolve the distributed nature of the namespace.</p> </li> <li> <p>Distributed implementation across multiple locations: Unlike traditional    packages that exist in a single location, namespace packages can span    multiple directories distributed across different installed packages. This    powerful feature allows the <code>egse</code> namespace to be extended by various    packages (both within this monorepo and from external sources like PyPI),    with Python correctly assembling the complete namespace at runtime by    discovering and including all relevant directories from the Python path.</p> </li> </ol> <p>This namespace approach enables modular architecture, allowing separate teams to independently develop components that seamlessly integrate under the unified <code>egse</code> namespace without requiring centralized coordination for package imports.</p>"},{"location":"dev_guide/monorepo/#understanding-egse-vs-cgse-terminology","title":"Understanding EGSE vs. CGSE Terminology","text":"<p>You may notice two related acronyms used throughout our documentation, folder structures, and codebase: EGSE and CGSE. This deliberate distinction serves an important purpose:</p> <ul> <li> <p>EGSE (Electrical Ground Support Equipment) refers to the broader domain   that our software addresses\u2014the physical and software systems used for   testing, calibration, and validation of instrumentation. This term represents   the underlying technical concept, which is why we've chosen it as our Python   namespace (<code>egse</code>). Using this domain-specific namespace provides clear   context for all code functionality while avoiding potential conflicts with   repository names.</p> </li> <li> <p>CGSE (Common-EGSE) represents our specific implementation framework   designed to provide standardized, reusable solutions for EGSE requirements.   The \"Common\" prefix emphasizes our framework's core philosophy: creating a   unified ecosystem of interoperable components that can be shared across   multiple projects, teams, and institutions. We use CGSE for project naming,   repository identification, and when referring to the overall framework   ecosystem.</p> </li> </ul> <p>This naming convention enables clear differentiation between the technical domain (EGSE) and our specific framework implementation (CGSE). External packages and device drivers that are designed to integrate with our framework are labeled as CGSE-compatible to indicate their adherence to our interoperability standards while still residing within the <code>egse</code> namespace for technical consistency.</p>"},{"location":"dev_guide/nox/","title":"Testing with <code>nox</code>","text":"<p>Ultimately, we want our software to work on as many Python environments as possible. So, we  adopted <code>nox</code> to run the unit tests under different Python  versions.</p> <p>If you don't have <code>nox</code> installed on your system, you can install it globally as a uv tool:</p> <pre><code>$ uv tool install nox\n</code></pre> <p>After this you can run <code>nox</code> from the package root. We have provided a <code>noxfile.py</code> for the  <code>cgse-common</code>package. The <code>cgse-common</code> package currently runs all unit tests without errors for  Python 3.9, 3.10, 3.11, 3.12, and 3.13.</p> <p>The following command will run the default sessions (<code>uv_tests</code>). You can  optionally save the output of stdout and stderr (whiich can be substantial) </p> <p><pre><code>$ nox\n</code></pre> or <pre><code>$ nox &gt; nox.out.txt 2&gt;&amp;1\n</code></pre> You can restrict your tests with commandline parameters. The following  example will only execute the default sessions in a Pytho 3.11 environment  and will only run the test that matches <code>test_async_control</code>.</p> <pre><code>$ nox --python 3.11 -- -k test_async_control\n</code></pre>"},{"location":"dev_guide/plugins/","title":"Plugins","text":"<p>The CGSE is designed to be extensible and uses a few plugin mechanisms to extend its functionally with external contributions. Also within the <code>cgse</code> monorepo we use the plugin mechanism at several places. The following entry-points are currently defined:</p> <ul> <li><code>cgse.version</code>: Each package that provides functionality within the CGSE or adds a device driver   registers itself to provide version information.</li> <li><code>cgse.command</code>: Packages can add commands or sub-commands to the <code>cgse</code> app to manage   their functionality from within the <code>cgse</code> app, e.g. to start or stop the service or to report on   its status.</li> <li><code>cgse.service</code>: Package provides a device driver or another service.</li> <li><code>cgse.settings</code>: Package can add their own settings.</li> <li><code>cgse.explore</code>: Package provides a set of functions to explore, e.g. if any of the processes    it provides are running.</li> <li><code>cgse.resource</code>: Packages can register resources.</li> </ul> <p>Each of the entry-points knows how to load a module or object and each entry-point group is connected to a specific action or plugin hook like, e.g. add a command or command group to the <code>cgse</code> app, add package specific settings to the global settings.</p>"},{"location":"dev_guide/plugins/#version-discovery","title":"Version discovery","text":"<p>When you write a package that you want to integrate with the CGSE, provide a <code>cgse.version</code> entry-point. The name of the entry-point shall match the package name and is used to read the version from the importlib metadata. The entry-point value is currently not used. The entry-point value can optionally provide additional information about the package, but that is currently not specified.</p> <p>Add the following to your <code>pyproject.toml</code> file in your project's root folder, replacing package-name with the name of your project. The entry-point value is currently not used, but you want to use a valid format, the value below is always valid.</p> <pre><code>[project.entry-points.\"cgse.version\"]\npackage-name = 'egse.version:get_version_installed'\n</code></pre>"},{"location":"dev_guide/plugins/#extending-the-cgse-app","title":"Extending the <code>cgse</code> app","text":""},{"location":"dev_guide/plugins/#add-a-command","title":"Add a Command","text":"<p>If your package provides specific functionality that can be added as a command or a command group to the <code>cgse</code> app, use the <code>cgse.command</code> entry-point group. Since the <code>cgse</code> app uses the Typer package to build its commandline interface, adding a command is as simple as writing a function. The function will be added to the <code>cgse</code> app using the <code>app.command()</code> function of <code>Typer</code>, making the function a top-level command of the <code>cgse</code> app. The function can be defined as a plain function or with Typer's <code>@app.command</code> decorator.</p> <p>In the <code>pyproject.toml</code> file of your project, add the following lines to add the CGSE command:</p> <pre><code>[project.entry-points.\"cgse.command\"]\nname = 'module:object'\n</code></pre> <p>Where:</p> <ul> <li><code>name</code> is the name of the command</li> <li><code>module</code> is a fully qualified module name for your package, a module that can be imported</li> <li><code>object</code> is the name of the function that you want to add as a command</li> </ul> <p>As an example, for the <code>cgse-tools</code> package, the <code>init</code> command of the <code>cgse</code> app is listed in the <code>pyproject.toml</code> file as follows:</p> <pre><code>[project.entry-points.\"cgse.command\"]\ninit = 'cgse_tools.cgse_commands:init'\n</code></pre> <p>The <code>init</code> function is defined in the <code>cgse_commands.py</code> module which is located in the <code>cgse_tools</code> module in the <code>src</code> folder of the package:</p> <pre><code>src\n\u251c\u2500\u2500 cgse_tools\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 cgse_commands.py\n...\n</code></pre>"},{"location":"dev_guide/plugins/#add-a-command-group","title":"Add a Command group","text":"<p>Some commands are more complicated and define a number of sub-commands. An example is the <code>show</code> command where you currently have the sub-commands <code>env</code> and <code>settings</code></p> <pre><code>$ cgse show --help\n\n Usage: cgse show [OPTIONS] COMMAND [ARGS]...\n\n Show information about settings, environment, setup, ...\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                           \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 settings   Show the settings that are defined by the installed packages.              \u2502\n\u2502 env        Show the environment variables that are defined for the project.           \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>The <code>show</code> command is defined as a <code>typer.Typer()</code> object where <code>env</code> and <code>settings</code> are added using the decorator <code>@&lt;app&gt;.command()</code>.</p> <pre><code>import typer\n\nshow = typer.Typer(help=\"Show information about settings, environment, setup, ...\")\n\n\n@show.command(name=\"settings\")\ndef show_settings():\n    ...\n\n\n@show.command(name=\"env\")\ndef show_env():\n    ...\n</code></pre> <p>To add this command group to the <code>cgse</code> app, the following entry was used in the <code>pyproject. toml</code> file of the <code>cgse-tools</code> project. Notice the <code>[group]</code> at the end of the entry which indicates this is a command group instead of a single command.</p> <pre><code>[project.entry-points.\"cgse.command\"]\nshow = 'cgse_tools.cgse_commands:show[group]'\n</code></pre>"},{"location":"dev_guide/plugins/#add-a-service","title":"Add a Service","text":"<p>If your package provides a device driver or a specific service, use the <code>cgse.service</code> entry-point group. Service entry-points follow the same scheme as command groups, i.e. they are added to the <code>cgse</code> app as a <code>Typer()</code> object. Use the following entry in your <code>pyproject.toml</code> file:</p> <pre><code>[project.entry-points.\"cgse.service\"]\nname = 'module:object'\n</code></pre> <p>where:</p> <ul> <li><code>name</code> is the name of the service or device driver</li> <li><code>module</code> is a fully qualified module name for your package, a module that can be imported</li> <li><code>object</code> is the name of the <code>Typer()</code> object that you want to add as a service</li> </ul>"},{"location":"dev_guide/plugins/#explore","title":"Explore","text":"<p>The entry-point <code>cgse.explore</code> can be used to extend functionality without adding a new command  or sub-command to the <code>cgse</code> app. The idea is that commands that work on different packages can  use this entry-point to perform certain tasks on the package. This is currently used for the  <code>show procs</code> command (see below).</p> <p>The entry-point has the following format:</p> <pre><code>[project.entry-points.\"cgse.explore\"]\nexplore = \"&lt;package&gt;.cgse_explore\"\n</code></pre> <p>So, what happens is that a command that wants to apply a functionality on an external package  loads the <code>cgse_explore.py</code> module for that package and checks if a function with a specific  name exists in that module. It then executes that function. For the <code>show procs</code> command, the  function <code>show_processes</code> is expected and it shall return a list of strings which currently are  printed to the terminal. This entry-point is currently implemented for <code>cgse-core</code> and  <code>cgse-dummy</code> (an external demo package) and when you run the <code>cgse show procs</code> command it looks  something like below (the format is from the unix <code>ps -ef</code> command). </p> <pre><code>\u279c  cgse show procs\n459800007 76849     1   0 11:07PM ttys003    0:03.53 /Users/rik/tmp/test_dummy/venv/bin/python3.9 -m egse.logger.log_cs start\n459800007 76850     1   0 11:07PM ttys003    2:18.60 /Users/rik/tmp/test_dummy/venv/bin/python3.9 -m egse.storage.storage_cs start\n459800007 76851     1   0 11:07PM ttys003    2:20.10 /Users/rik/tmp/test_dummy/venv/bin/python3.9 -m egse.confman.confman_cs start\n459800007 13825     1   0  4:31PM ttys003    0:02.97 /Users/rik/tmp/test_dummy/venv/bin/python3.9 -m cgse_dummy.dummy_sim start\n</code></pre>"},{"location":"dev_guide/plugins/#register-resources","title":"Register resources","text":"<p>TODO: what if two packages provide a resource <code>icons</code> ?</p> <ul> <li>known resources: icons, styles</li> </ul>"},{"location":"dev_guide/project-configuration/","title":"Project Configuration","text":"<p>In this section we will explain the <code>pyproject.toml</code> contents and why we have taken certain decisions.</p>"},{"location":"dev_guide/project-configuration/#python-version-dependency","title":"Python version dependency","text":"<p>Since we have adopted <code>nox</code> as our platform to run the unit tests for different Python environments/versions, the <code>pyproject.toml</code> file contains dependency specifiers for Python versions. The main packages that have different dependencies based on the Python version are: <code>numpy</code>, <code>pandas</code>, and <code>pyzmq</code>. The dependencies are specified in the <code>project.dependencies</code> table in the <code>pyproject.toml</code> file of the <code>cgse-common</code> project.</p> <p>Then, there is the case where the <code>importlib.metadata</code> entry_points used to return a dict-like  object until Python 3.9, and a collection of entry points as of 3.10. The deprecated interface  was completely removed as of Python 3.12. We have now implemented a check in <code>egse.plugin</code> that  imports the <code>import_metadata</code> backport for Python &lt; 3.10. This backport package is only  installed when using Python 3.9 as is specified in the <code>pyproject.toml</code> file of the <code>cgse-common</code>.</p>"},{"location":"dev_guide/project-configuration/#dependency-groups","title":"Dependency Groups","text":"<p>Dependency groups are a way to organize optional dependencies that aren't required for basic package functionality. Dependency groups are not installed by default. They are only installed when explicitly requested.</p> <p>Warning</p> <p>The <code>[dependency-groups]</code> section is part of uv's own configuration system rather than a  standard Python packaging concept. It is different from the <code>[project.optional-dependencies]</code> section that follows Python's packaging standards.</p> <p>By default, uv includes the <code>dev</code> dependency group in the environment, e.g. during <code>uv run</code> or <code>uv sync</code>. You can define a group to be a default group by adding it to <code>tool.uv.default-groups</code>. For example, when the <code>docs</code> dependency group should also be a default group, add</p> <pre><code>[tool.uv]\ndefault-groups = [\"dev\", \"docs\"]\n</code></pre>"},{"location":"dev_guide/unit_testing/","title":"Testing the Software","text":"<p>We use the <code>pytest</code> package to unit test our modules and packages. The <code>pyproject.toml</code> files are configured for  each package to perform the testing. This section will guide you through the steps to run the tests and also explain  how we configured the tests and some guidelines we used.</p>"},{"location":"dev_guide/unit_testing/#running-the-unit-test-for-each-package-separately","title":"Running the unit test for each package separately","text":"<p>If you are working on a particular package and want to run its unit test, make sure you are in the root folder of  that package, e.g. for the <code>cgse-common</code> package, do the following:</p> <pre><code>$ cd ~/github/cgse/libs/cgse-common/\n$ uv sync\n$ uv run pytest -v\n================================================================ test session starts =================================================================\nplatform darwin -- Python 3.9.20, pytest-8.3.4, pluggy-1.5.0 -- /Users/rik/github/cgse/.venv/bin/python3\ncachedir: .pytest_cache\nrootdir: /Users/rik/github/cgse/libs/cgse-common\nconfigfile: pyproject.toml\nplugins: cov-6.0.0, mock-3.14.0\ncollected 161 items\n\ntest_bits.py::test_clear_bit PASSED                                                                                                            [  0%]\ntest_bits.py::test_set_bit PASSED                                                                                                              [  1%]\ntest_bits.py::test_toggle_bit PASSED                                                                                                           [  1%]\ntest_bits.py::test_beautify_binary PASSED                                                                                                      [  2%]\ntest_bits.py::test_set_bits PASSED                                                                                                             [  3%]\ntest_bits.py::test_alternative_set_bits PASSED                                                                                                 [  3%]\ntest_bits.py::test_clear_bits PASSED                                                                                                           [  4%]\ntest_bits.py::test_crc_calc PASSED                                                                                                             [  4%]\ntest_bits.py::test_humanize_bytes PASSED                                                                                                       [  5%]\ntest_bits.py::test_s16 PASSED                                                                                                                  [  6%]\ntest_bits.py::test_s32 PASSED                                                                                                                  [  6%]\ntest_command.py::test_dry_run PASSED                                                                                                           [  7%]\ntest_command.py::test_command_class PASSED                                                                                                     [  8%]\ntest_command.py::test_return_code_of_execute PASSED                                                                                            [  8%]\n...\n</code></pre>"},{"location":"dev_guide/unit_testing/#running-the-unit-tests-of-all-packages","title":"Running the unit tests of all packages","text":"<p>Before releasing the software, we should run all the unit tests of all the packages in the monorepo and have green  light \ud83d\udfe2. Running these unit tests is as simple as for the individual packages. You will need to be in the root folder  of the monorepo and sync your virtual environment for all the packages in the workspace.</p> <pre><code>$ cd ~/gitbug/cgse\n$ uv sync --all-packages\n$ uv run pytest -v\n</code></pre>"},{"location":"dev_guide/uv/","title":"Working with <code>uv</code>","text":"<p><code>uv</code> is an extremely fast Python package and project manager, written in Rust. We will use <code>uv</code> as the single tool that replaces <code>pip</code>, <code>virtualenv</code>, <code>pyenv</code>, and more. The main tasks for which we will use <code>uv</code> are:</p> <ul> <li>run and install Python versions</li> <li>installing and managing a virtual environment</li> <li>build all the packages in the workspace or monorepo</li> <li>publish all the packages to PyPI</li> <li>run scripts and apps</li> </ul>"},{"location":"dev_guide/uv/#installing-uv","title":"Installing <code>uv</code>","text":"<p>On macOS and Linux you can install <code>uv</code> using <code>curl</code>:</p> <pre><code>$ curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>If you need more specific information on installing and upgrading <code>uv</code>, please refer to the official documentation.</p>"},{"location":"dev_guide/uv/#installing-a-python-version","title":"Installing a Python version","text":"<p>The CGSE is guaranteed to work with Python 3.9.x. We will gradually include higher versions of Python, but currently these have not been tested. So, we will for the moment stick with Python 3.9.20. Install this version as follows:</p> <pre><code>$ uv python install 3.9.20\n</code></pre> <p><code>pyenv</code></p> <p>When you are using <code>pyenv</code> to manage your Python versions, make sure you also have the same  Python version installed with <code>pyenv</code> and <code>uv</code>. Otherwise you will run into the following  error. This is a known issue with <code>uv</code>.</p> <pre><code>pyenv: version `3.9.20' is not installed (set by /Users/rik/github/cgse/libs/cgse-common/.python-version)\n</code></pre> <p>You can check which Python versions are installed already on your system:</p> CommandOutput <pre><code>$ uv python list --only-installed\n</code></pre> <pre><code>cpython-3.12.8-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.12.8-macos-aarch64-none/bin/python3.12\ncpython-3.10.16-macos-aarch64-none    /Users/rik/Library/Application Support/uv/python/cpython-3.10.16-macos-aarch64-none/bin/python3.10\ncpython-3.9.21-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.9.21-macos-aarch64-none/bin/python3.9\ncpython-3.9.20-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.9.20-macos-aarch64-none/bin/python3.9\ncpython-3.9.6-macos-aarch64-none      /Library/Developer/CommandLineTools/usr/bin/python3 -&gt; ../../Library/Frameworks/Python3.framework/Versions/3.9/bin/python3\ncpython-3.8.17-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.8.17-macos-aarch64-none/bin/python3.8\n</code></pre>"},{"location":"dev_guide/uv/#create-a-virtual-environment","title":"Create a virtual environment","text":"<p>Pin a Python version</p> <p>You can pin a python version with the command:</p> <pre><code>$ uv python pin 3.9.20\n</code></pre> <p><code>uv</code> will search for a pinned version in the parent folders up to the root folder or your home directory.</p> <p>You can create a virtual environment with <code>uv</code> for the specific Python version as follows. The '<code>--python</code>' is optional and <code>uv</code> will use the default (pinned) Python version when creating a <code>venv</code> without this option. We are working in a monorepo or what <code>uv</code> calls a workspace. There will be only one virtual environment at the root of the monorepo, despite the fact that we have several individual packages in our workspace. Don't worry, <code>uv</code> will always use the virtual environment at the root and keep it up-to-date with the project your are currently working in.</p> <p>When creating a virtual environment make sure you are in the root folder, e.g. <code>~/github/cgse</code>.</p> <pre><code>$ cd ~/github/cgse\n$ uv venv --python 3.9.20\n</code></pre> <p>If you want to name your virtual environment, use the optional argument <code>--prompt &lt;venv name&gt;</code> in the above command, otherwise the virtual environment will get the same name as the project, i.e. <code>cgse</code>.</p> <p>Now, navigate to the package you will be working in and update the projects' environment, assuming you are going to work in <code>cgse-core</code>, this will be:</p> <pre><code>$ cd ~/github/cgse/libs/cgse-core\n$ uv sync\n</code></pre> <p>Your package(s) from the workspace should be installed as an editable install. You can check this with the command:</p> <pre><code>$ uv pip list -v\nUsing Python 3.9.20 environment at: /Users/rik/github/cgse/.venv\nPackage           Version     Editable project location\n----------------- ----------- ---------------------------------------\napscheduler       3.11.0\ncgse-common       0.4.0       /Users/rik/github/cgse/libs/cgse-common\ncgse-core         0.4.0       /Users/rik/github/cgse/libs/cgse-core\n...\n</code></pre> <p>To install any other project as an editable package:</p> <pre><code>$ uv pip install -e &lt;project location&gt;\n</code></pre> <p>Note</p> <p>If you don't want to use the <code>uv</code> commands, you can activate the virtual environment and use the original <code>pip</code>  and <code>python</code> commands as you are used to, but I would recommend you try to get used to <code>uv</code>  for a while to experience its benefits.</p> <pre><code>$ source ~/github/cgse/.venv/bin/activate\n</code></pre> <p>Info</p> <p>In a workspace, maintaining a virtual environment per package might be a hassle and most of the time that is not  needed. A good approach is to always use the virtual environment at the workspace root. This <code>venv</code> which will be  automatically created if you run a command or if you use <code>uv sync</code> in the package folder. With <code>uv sync</code> you can  make sure the virtual environment is up-to-date and contains only those dependencies that are required for the  package you are in. So, each time you switch to another package and want to run a comand or a test for that  package, use </p> <pre><code>$ uv sync\n</code></pre>"},{"location":"dev_guide/uv/#adding-and-removing-dependencies","title":"Adding and removing dependencies","text":"<p>If we need another Python package that we want to use and add this as a dependency to our project, we don't just want to install it with the <code>pip</code> command, nor add it to the <code>pyproject. toml</code> file ourselves. Instead, we use the <code>uv add &lt;package name&gt;</code> command, e.g. to install flask, we do:</p> <pre><code>$ uv add flask\n</code></pre> <p>Like wise, removing a dependency, we do that with the <code>uv remove &lt;package name&gt;</code> command, because that will also remove the packages on which flask depended.</p> <pre><code>$ uv remove flask\n</code></pre> <p>Note</p> <p>The commands above to add and remove dependencies will work on the <code>pyproject.toml</code> file of  the package you are currently working in. For example, if you're working in  <code>cgse/libs/cgse-common</code>, that <code>pyproject.toml</code> file will get the extra 'flask' dependency.</p>"},{"location":"dev_guide/uv/#syncing-your-environment","title":"Syncing your environment","text":"<p>You can synchronise your environment explicitly with the <code>uv sync</code> command.  This is usually not needed since <code>uv</code> automatically synchronises your  environment when executing <code>uv run</code>. Using the command below will remove  any packages that are installed in your environment but are not specified in  your <code>pyproject.toml</code> or the <code>uv.lock</code> file. Use this command to clean your  environment.</p> <pre><code>$ uv sync\n</code></pre> <p>When syncing, <code>uv</code> prefers to keep the versions from the <code>uv.lock</code> file. You  can upgrade packages by name or upgrade all packages with the following  commands:</p> <pre><code>$ uv lock --upgrade-package &lt;package name&gt;\n\n$ uv lock --upgrade\n</code></pre>"},{"location":"dev_guide/uv/#building-and-publishing-all-packages","title":"Building and publishing all packages","text":"<p>We have chosen for one and the same version number for all packages in the <code>cgse</code> monorepo. That means that whenever we make a change to one of the packages and want to release that change, all packages shall be rebuilt and published.</p> <p>Warning</p> <p>When working in a workspace, keep in mind that the commands <code>uv run</code> and <code>uv sync</code> by default work on the  workspace root. That means that when you run the <code>uv run pip install &lt;package&gt;</code> command, the <code>.venv</code> at the  workspace root will be updated or created if it didn't exist. Similar for the <code>uv sync</code> command, there is only  one <code>uv.lock</code> file at the root of the workspace.  </p> <p>Fortunately, with <code>uv</code>, that is done in a few commands.</p> <p>When you are in the monorepo root folder, you can build all packages at once. They will be placed in the <code>dist</code> folder of the root package. The <code>bump</code> script will automatically increase the version number based on your input, i.e. 'patch', 'minor', or 'major'. Before building, clean up the <code>dist</code> folder, then you can do a default <code>uv publish</code> afterwards.</p> <pre><code>$ cd &lt;monorepo root&gt;\n$ uv run bump.py &lt;part&gt;\n$ rm -r dist\n$ uv build --all-packages\n</code></pre> <p>where <code>&lt;monorepo root&gt;</code> is the root folder of your local clone, e.g. <code>~/github/cgse</code>, and <code>&lt;part&gt;</code> stands for the part of the version number that shall be bumped, i.e. 'patch', 'minor', or 'major'.</p> <p>Publish all packages in the root dist folder to PyPI. The UV_PUBLISH_TOKEN can be defined in a (read protected) ~/. setenv.bash file:</p> <pre><code>$ uv publish --token $UV_PUBLISH_TOKEN\n</code></pre> <p>The above command will publish all package to PyPI. If you don't want the token to be in a shell variable, you can omit the <code>--token</code> in the command above. You will then be asked for a username, use <code>__token__</code> as the username and then provide the token as a password.</p>"},{"location":"dev_guide/versioning/","title":"Semantic Versioning","text":"<p>We use semantic versioning, aka semver, for our releases and patches. Please follow the rules that are described on their site.</p> <p>TL;DR</p> <p>The version number has the format <code>MAJOR.MINOR.PATH</code>, we increment the</p> <ul> <li>MAJOR version when we make incompatible changes</li> <li>MINOR version when we add or change functionality in a backward compatible manner</li> <li>PATCH version when we make backward compatible bug fixes</li> </ul> <p>The rules above apply when MAJOR &gt;= 1, which are considered stable releases.</p> <p>As long as MAJOR == 0, we are in initial development and anything may change. The MINOR number will be increased for adding or removing functionality and the PATCH number will be increased for all kinds of fixes.</p> <p>You might occasionally see pre-release and build metadata added to the version number. We will use the following metadata:</p> <ul> <li><code>-dev.X</code> \u2014 a development release where X &gt;= 1. This will be used for releases where we need to   test PyPI installations and/or GitHub actions. A development release can be added to any PATCH    number. An example development release: <code>2.3.1-dev.1</code>.</li> <li><code>-rc.X</code> \u2014 a release candidate where X &gt;= 1. This is a pre-release and contains all the intended   features. The release is believed to be stable enough for public testing, but isn't yet considered   the final production version. There might be more than one release candidate. Release    candidates are usually used for releases where PATCH == 0. For example, when we   have a third release candidate <code>1.2.0-rc.3</code> the actual released version will then be <code>1.2.0</code>.</li> </ul>"},{"location":"dev_guide/versioning/#why-not-calver","title":"Why not CalVer?","text":"<p>We do not use Calendar Versioning for the following reason:</p> <ul> <li>Calendar versioning is preferred for projects that have a release schedule that is based on dates,   like every week or every three months.</li> <li>Semantic versioning is preferred when no date related release schedule is foreseen, also major   version 0 means that API is not yet fixed and everything can change. Our project is in that state   right now.</li> </ul>"},{"location":"libs/","title":"Libraries","text":"<p>The libraries are those packages that make up the CGSE framework.</p> <p>The libraries are located under the <code>libs</code> folder, and we currently find the following packages there:</p> <ul> <li><code>cgse-common</code></li> <li><code>cgse-core</code></li> <li><code>cgse-coordinates</code></li> <li><code>cgse-gui</code></li> </ul>"},{"location":"libs/cgse-common/","title":"Common Code","text":"<p>This package <code>cgse-common</code> contains modules that are used by all other packages. </p> Module Name Description <code>egse.bits</code> convenience functions to work with bits, bytes and integers <code>egse.calibration</code> functions to handle conversions and apply correction <code>egse.command</code> classes and functions to work with commands that operate hardware devices <code>egse.config</code> convenience functions to configure the system and find folders and files <code>egse.control</code> defines abstract classes and convenience functions for any control server <code>egse.decorators</code> a collection of useful decorator functions <code>egse.device</code> defines the generic interfaces to connect devices <code>egse.env</code> functionality to work with and check your environment variables <code>egse.exceptions</code> common Exceptions and Errors <code>egse.hk</code> functions to retrieve and convert housekeping parameter values <code>egse.metrics</code> functions to define and update metrics <code>egse.mixin</code> defines the mixin classes for dynamic commanding <code>egse.monitoring</code> the monitoring application / function <code>egse.observer</code> the classic observer and observable <code>egse.obsid</code> functions to define and work with the OBSID <code>egse.persistence</code> the persistence layer interface <code>egse.plugin</code> functions to load plugins and settings from entry-points <code>egse.process</code> functions and classes to work with processes and sub-processes <code>egse.protocol</code> base class for communicating commands with the hardware or the control server <code>egse.proxy</code> base class for the Proxy objects for each device controller <code>egse.reload</code> a slightly better approach to reloading modules and function <code>egse.resource</code> convenience functions to use resources in your code <code>egse.response</code> defines the classes to handle responses from the control servers <code>egse.services</code> provides the services to the control servers <code>egse.settings</code> provides functions to handle user and configuration settings <code>egse.setup</code> defines the Setup, containing the complete configuration for a test <code>egse.state</code> classes and functions to handle state, e.g. the GlobalState <code>egse.system</code> convenience functions that provide information on system specific functionality <code>egse.version</code> functions to load specific version information <code>egse.zmq_ser</code> serialization function used in a ZeroMQ context"},{"location":"libs/cgse-common/settings/","title":"The Settings","text":"<p>The Settings class contains all static information needed to configure your system, the environment you are using and the test equipment. The Settings also contain all the IP addresses and port number for all the known devices, together with other static information like the device name, default settings for the device like speed, timeout, delay time, firmware version, etc. We will go into more details about the content later, let\u2019s now first look at the format and usage of the Settings.</p>"},{"location":"libs/cgse-common/settings/#loading-the-settings","title":"Loading the Settings","text":"<p>The Settings can be loaded as follows:</p> <pre><code>&gt;&gt;&gt; from egse.settings import Settings\n&gt;&gt;&gt; settings = Settings.load()\n</code></pre> <p>The <code>settings</code> object will be a dictionary where the keys are the top-level groups that are defined in the settings for each package. For a system that has only <code>cgse-common</code> and <code>cgse-core</code> installed, the <code>settings</code> will contain something like this:</p> <pre><code>&gt;&gt;&gt; print(settings)\nSettings\n\u251c\u2500\u2500 PACKAGES\n\u2502   \u251c\u2500\u2500 CGSE_COMMON: Common classes, functions, decorators, etc. for the CGSE\n\u2502   \u2514\u2500\u2500 CGSE_CORE: The core services of the CGSE\n\u251c\u2500\u2500 SITE\n\u2502   \u251c\u2500\u2500 ID: LAB42\n\u2502   \u251c\u2500\u2500 SSH_SERVER: localhost\n\u2502   \u2514\u2500\u2500 SSH_PORT: 22\n\u251c\u2500\u2500 PROCESS\n\u2502   \u2514\u2500\u2500 METRICS_INTERVAL: 10\n\u251c\u2500\u2500 Logging Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 LOGGING_PORT: 7000\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 7001\n\u2502   \u251c\u2500\u2500 METRICS_PORT: 7003\n\u2502   \u251c\u2500\u2500 MAX_NR_LOG_FILES: 20\n\u2502   \u251c\u2500\u2500 MAX_SIZE_LOG_FILES: 20\n\u2502   \u251c\u2500\u2500 TEXTUALOG_IP_ADDRESS: 127.0.0.1\n\u2502   \u2514\u2500\u2500 TEXTUALOG_LISTENING_PORT: 19996\n\u251c\u2500\u2500 Configuration Manager Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 6000\n\u2502   \u251c\u2500\u2500 MONITORING_PORT: 6001\n\u2502   \u251c\u2500\u2500 SERVICE_PORT: 6002\n\u2502   \u251c\u2500\u2500 METRICS_PORT: 6003\n\u2502   \u251c\u2500\u2500 DELAY: 1\n\u2502   \u2514\u2500\u2500 STORAGE_MNEMONIC: CM\n\u2514\u2500\u2500 Storage Control Server\n    \u251c\u2500\u2500 PROTOCOL: tcp\n    \u251c\u2500\u2500 HOSTNAME: localhost\n    \u251c\u2500\u2500 COMMANDING_PORT: 6100\n    \u251c\u2500\u2500 MONITORING_PORT: 6101\n    \u251c\u2500\u2500 SERVICE_PORT: 6102\n    \u251c\u2500\u2500 METRICS_PORT: 6103\n    \u2514\u2500\u2500 DELAY: 1\n</code></pre> <p>If you only need the settings for a particular component, specify that group's name:</p> <pre><code>&gt;&gt;&gt; storage_settings = Settings.load(\"Storage Control Server\")\n\n&gt;&gt;&gt; print(storage_settings)\nStorage\nControl\nServer\n\u251c\u2500\u2500 PROTOCOL: tcp\n\u251c\u2500\u2500 HOSTNAME: localhost\n\u251c\u2500\u2500 COMMANDING_PORT: 6100\n\u251c\u2500\u2500 MONITORING_PORT: 6101\n\u251c\u2500\u2500 SERVICE_PORT: 6102\n\u251c\u2500\u2500 METRICS_PORT: 6103\n\u2514\u2500\u2500 DELAY: 1\n</code></pre> <p>The values can be accessed as usual with a dictionary, by specifying the name of the parameter as the key:</p> <pre><code>&gt;&gt;&gt; print(storage_settings[\"COMMANDING_PORT\"])\n6100\n</code></pre> <p>We usually only go one level deep when defining settings, and as a convenience, that first level of variables can also be accessed with the dot-notation.</p> <pre><code>&gt;&gt;&gt; print(storage_settings.COMMANDING_PORT)\n6100\n</code></pre>"},{"location":"libs/cgse-common/settings/#entry-points","title":"Entry-points","text":"<p>The Settings are collected from a set of YAML files which are provided by the packages through the entry-point <code>cgse.settings</code>. The default Settings file is named <code>settings.yaml</code> but this can be changed by the entry-point (see below).</p> <p>Let's take a look at how the settings are provided for the <code>cgse-core</code> package. First, the <code>pyproject.toml</code> file of the project shall define the entry-point. In the snippet below, the entry-point <code>cgse-core</code> is defined for the group <code>cgse.settings</code>.</p> <pre><code>[project.entry-points.\"cgse.settings\"]\ncgse-core = \"cgse_core:settings.yaml\"\n</code></pre> <p>The entry-point itself has the following format: <code>&lt;name&gt; = \"&lt;module&gt;.&lt;filename&gt;\"</code>, where</p> <ul> <li><code>&lt;name&gt;</code> is the name of the entry-point given in the <code>pyproject.toml</code> file, usually this is the package name,</li> <li><code>&lt;module&gt;</code> is a valid module name that can be imported and from which the location can be determined, and</li> <li><code>&lt;filename&gt;</code> is the name of the target file, e.g. a YAML file.</li> </ul> <p>Note</p> <p>The module name for this entry point has an underscore instead of a dash, i.e. <code>cgse_core</code> instead of  <code>cgse-core</code>. The reason is that module names with a dash will generate a SyntaxError during import.</p> <p>The above example will load the settings for this package from the <code>settings.yaml</code> file that is located in the <code>cgse_core</code> module. That is, the package shall also provide this as follows:</p> <pre><code>cgse-core\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 cgse_core\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 settings.yaml\n</code></pre> <p>The <code>settigs.yaml</code> file for this module looks something like this:</p> <pre><code>PACKAGES:\n    CGSE_CORE: The core services of the CGSE\n\nLogging Control Server:                          # LOG_CS\n\n    PROTOCOL:                       tcp\n    HOSTNAME:                 localhost          # The hostname that client shall connect to, e.g. pleiad01 @ KU Leuven\n    LOGGING_PORT:                  7000\n    COMMANDING_PORT:               7001\n    METRICS_PORT:                  7003          # The HTTP port where Prometheus will connect to for retrieving metrics\n    MAX_NR_LOG_FILES:                20          # The maximum number of log files that will be maintained in a roll-over\n    MAX_SIZE_LOG_FILES:              20          # The maximum size one log file can become\n    TEXTUALOG_IP_ADDRESS:     127.0.0.1          # The IP address of the textualog listening server\n    TEXTUALOG_LISTENING_PORT:     19996          # The port number on which the textualog server is listening\n\nConfiguration Manager Control Server:            # CM_CS\n\n    ...\n</code></pre> <p>Warning</p> <p>Please note that the module where the Settings YAML file resides is a Python package and not  a namespace. That means it shall have a <code>__init__.py</code> file as shown in the example of the  <code>cgse_core</code> module above.</p> <p>If the <code>__init__.py</code> file is not there, you will get an error like below:</p> <pre><code>ERROR:egse.plugin:The entry-point 'cgse-coordinates' is ill defined. The module part doesn't \nexist or is a namespace. No settings are loaded for this entry-point.\n</code></pre>"},{"location":"libs/cgse-common/settings/#local-settings","title":"Local Settings","text":"<p>You can, and you should, define local settings for your project and put those settings in a known folder on your system. The usual place is <code>~/cgse/local-settings.yaml</code>. This file will be automatically loaded by the <code>Settings.load()</code> function when you define the local settings environment variable. That variable name is <code>&lt;PROJECT&gt;_LOCAL_SETTINGS</code> where <code>&lt;PROJECT&gt;</code> is the name of your project as defined by the <code>PROJECT</code> environment variable. For a <code>PROJECT=LAB23</code> the local settings would be defined as follows:</p> <pre><code>$ export LAB23_LOCAL_SETTINGS=~/cgse/local-settings-lab23.yaml\n</code></pre> <p>The local settings take higher precedence that will overwrite the global settings when loaded. You only need to define the settings that actually change for your local installation, respect the full hierarchy when specifying those settings. You are allowed to define new entries at any level in the Settings hierarchy.</p> <p>The usual parameters to put into a local settings file are:</p> <ul> <li>the SITE ID</li> <li>the hostnames of the different devices that you use</li> <li>the hostname of the server where core services or device control servers are running</li> <li>port numbers that have been changed from the default</li> </ul>"},{"location":"libs/cgse-common/settings/#terminal-command","title":"Terminal Command","text":"<p>You can check the current settings from the terminal with the following command:</p> <pre><code>$ py -m egse.settings\nSettings\n\u251c\u2500\u2500 PACKAGES\n\u2502   \u251c\u2500\u2500 CGSE_COMMON: Common classes, functions, decorators, etc. for the CGSE\n\u2502   \u2514\u2500\u2500 CGSE_CORE: The core services of the CGSE\n\u251c\u2500\u2500 SITE\n\u2502   \u251c\u2500\u2500 ID: LAB42\n\u2502   \u251c\u2500\u2500 SSH_SERVER: localhost\n\u2502   \u2514\u2500\u2500 SSH_PORT: 22\n\u251c\u2500\u2500 PROCESS\n\u2502   \u2514\u2500\u2500 METRICS_INTERVAL: 10\n\u251c\u2500\u2500 Logging Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 LOGGING_PORT: 7000\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 7001\n... ...\n\u2514\u2500\u2500 Storage Control Server\n    \u251c\u2500\u2500 PROTOCOL: tcp\n    \u251c\u2500\u2500 HOSTNAME: localhost\n    \u251c\u2500\u2500 COMMANDING_PORT: 6100\n    \u251c\u2500\u2500 MONITORING_PORT: 6101\n    \u251c\u2500\u2500 SERVICE_PORT: 6102\n    \u251c\u2500\u2500 METRICS_PORT: 6103\n    \u2514\u2500\u2500 DELAY: 1\nMemoized locations:\n['/Users/rik/github/cgse/libs/cgse-common/src/cgse_common/settings.yaml', '/Users/rik/github/cgse/libs/cgse-core/src/cgse_core/settings.yaml', '/Users/rik/cgse/local_settings_ariel.yaml']\n</code></pre> <p>The memoized locations are the settings files that have been loaded and cached. Once the application has started and the settings have been loaded, they can only be reloaded by explicitly forcing a reload as follows:</p> <pre><code>&gt;&gt;&gt; settings = Settings.load(force=True)\n</code></pre> <p>Warning</p> <p>The <code>force</code> reload does however not guarantee that the settings will propagate properly throughout the application or to client apps. Settings can be saved in local variables or class instances that have no knowledge of a Settings reload. So, be careful when changing your Settings. If there are parameters that change often and are not as  static as thought, maybe they belong in the Setup instead of the Settings. Examples are:</p> <ul> <li>calibration parameters</li> <li>SUT parameters</li> <li>conversion functions</li> <li>coordinates and reference frames</li> <li>models</li> </ul>"},{"location":"libs/cgse-common/settings/#the-design-of-the-load-method","title":"The design of the <code>load()</code> method","text":"<p>A word about the <code>Settings.load()</code> method. Depending on the parameters provided, this method either loads all  settings, a group of settings or just one single YAML file. We have already explained how to load a specific group  of settings by giving the name of the group as a parameter. When you want to load just one YAML file, you need to  specify its location also. When a location is given as a str or a Path, the Settings will be loaded from that file  only, using the default <code>settings.yaml</code> name or another name given through the <code>filename</code> argument.</p> <p>This can be used to e.g. load command files for a device:</p> <pre><code>&gt;&gt;&gt; commands = Settings.load(location=\"~\", filename=\"DAQ5610.yaml\")\n</code></pre> <p>The mechanism behind the <code>Settings.load()</code> method is shown in the following diagram. For simplicity, parameters are  not shown and only the success path is presented, not any exceptions or error handling.</p> <p></p>"},{"location":"libs/cgse-common/setup/","title":"The Setup","text":""},{"location":"libs/cgse-coordinates/","title":"Reference Coordinates","text":""},{"location":"libs/cgse-core/","title":"Core Services","text":""},{"location":"libs/cgse-core/registry/","title":"The Service Registry","text":"<p>The service registry is a centralised database that keeps track of all active services in our distributed CGSE system. It acts as a dynamic directory where services can register themselves upon startup and de-register when shutting down. Any other service, script or app can use the service registry to retrieve information about a registered service.</p> <p>The service registry currently provides the following:</p> <ul> <li>It enables service discovery, allowing applications to find and connect to   services without hardcoded hostnames and port numbers.</li> <li>It provides health monitoring and improves system resilience by automatically   routing requests away from failed services.</li> <li>It facilitates dynamic scaling, as new service instances can register   themselves automatically.</li> <li>It simplifies configuration management by centralizing service information.</li> </ul> <p>The service registry is a critical component in our distributed system that helps manage complexity, improve reliability, and enable elasticity. Functionality will be gradually improved over time, e.g. by implementing load balancing for storage services, or by adding security features like service authentication to protect services.</p>"},{"location":"libs/cgse-core/registry/#the-registry-service-client","title":"The Registry Service Client","text":"<p>A service registry client is a component that is part of an application or microservice (e.g. a device driver) and is used to communicate with the service registry server and discover available services. Microservices like device drivers and core services that need to be discovered shall register to the service registry. Applications can use the registry client without registration.</p> <p>The registry client:</p> <ul> <li>Registers and de-registers itself to the service registry.</li> <li>Queries the service registry to discover a required service.</li> <li>Check the health of the service registry server.</li> <li>Can act on certain types of events from the registry server.</li> <li>Sends a heartbeat to the registry server to keep the registration alive.</li> </ul> <p>A microservice can register as follows:</p> <pre><code>from egse.registry.client import AsyncRegistryClient\n\nregistry_client = AsyncRegistryClient()\nregistry_client.connect()\n\nservice_id = await registry_client.register(\n    name=service_name,\n    host=hostname,\n    port=port_number,\n    service_type=service_type,\n    metadata={},\n    ttl=30,\n)\n</code></pre> <p>Notice that the client operates asynchronously and is designed to run within an asynchronous microservice or application. If your application or microservice follows a synchronous execution model and cannot be converted to an asynchronous approach, we also provide a synchronous version of the client through the <code>RegistryClient()</code> class. This synchronous alternative offers the same core functionality but blocks execution until operations complete, making it compatible with traditional synchronous codebases while still leveraging the service registry infrastructure.</p> <p>The <code>service_name</code> must be a unique identifier for your specific service instance. The <code>host</code> and <code>port</code> arguments specify the network location (hostname and port number) where your microservice can be reached. These values enable other services and applications to locate and communicate with your microservice. The <code>service_type</code> parameter is a category identifier that groups services providing equivalent functionality and compatible communication interfaces. Services sharing the same <code>service_type</code> are considered interchangeable from a client perspective. While this categorization primarily facilitates service discovery in the current implementation, it also forms the foundation for future enhancements such as intelligent load-balancing, failover mechanisms, and service redundancy. When registering your service, ensure these parameters accurately reflect your service's identity, location, and capabilities.</p> <p>The <code>metadata</code> parameter accepts a dictionary containing service-specific information that complements the core registration details. While optional and potentially empty, this field provides valuable extensibility for conveying additional service characteristics. Common metadata includes version numbers ( enabling version-aware client routing), supplementary endpoints (such as ports for monitoring, health checks, or event notifications), current load metrics ( facilitating intelligent load distribution), and capability flags (indicating supported features). The <code>ttl</code> (Time To Live) parameter defines the maximum duration, in seconds, that a service can remain unresponsive before the registry automatically deregisters it. This mechanism ensures the registry maintains an accurate representation of available services by removing instances that have crashed or become network-isolated without proper deregistration.</p> <p>Service discovery can be done as follows:</p> <pre><code>registry_client = AsyncRegistryClient()\n\ntry:\n    service = await registry_client.discover_service(service_type)\n\n    if not service:\n        logger.warning(f\"No service of type '{service_type}' found\")\n        return None\n\n    ...\n\n    socket = context.socket(zmq.REQ)\n    socket.setsockopt(zmq.RCVTIMEO, 5000)  # 5 second timeout\n\n    try:\n        # Connect to the service\n        socket.connect(f\"tcp://{service['host']}:{service['port']}\")\n\n        ...\n\n    finally:\n        socket.close()\nfinally:\n    await registry_client.close()\n</code></pre> <p>The <code>AsyncRegistryClient</code> locates available services based on service type. Only one service will be returned, even if more than one service was registered to the same <code>service_type</code>. Once the service is discovered, the application can use the information in the response to connect to and query the microservice, e.g. using the service's <code>host</code> and <code>port</code> a ZeroMQ endpoint can be created.</p> <p>The above code implements proper resource management by ensuring both the ZeroMQ socket and registry client are closed, even if exceptions occur during service discovery or communication.</p>"},{"location":"libs/cgse-core/registry/#the-registry-service-server","title":"The Registry Service server","text":"<p>The <code>AsyncRegistryServer</code> is an asynchronous service registry implementation for microservices architectures that are using ZeroMQ for communication and providing persistent storage through pluggable backends. It enables service discovery, registration, and health monitoring in distributed systems.</p> <p>The server exposes two ZeroMQ sockets:</p> <ul> <li>A REQ-REP socket for service registration, discovery, and management</li> <li>A PUB-SUB socket for broadcasting service events (registrations,   de-registrations, expirations)</li> </ul> <p>The server uses a pluggable backend for storing the service registrations. An <code>AsyncInMemoryBackend</code> is provided for in-memory storage as long as the server is running. For persistent storage of service registrations, use the <code>AsyncSLQiteBackend</code>.</p> <p>Although, the server is integrated in the CGSE core services, the basic usage is as follows:</p> <pre><code>import asyncio\n\nfrom egse.registry.server import AsyncSQLiteBackend\nfrom egse.registry.server import AsyncRegistryServer\n\n\nasync def run_server():\n    # Create and initialize a backend\n    backend = AsyncSQLiteBackend(\"service_registry.db\")\n    await backend.initialize()\n\n    # Create the server\n    server = AsyncRegistryServer(\n        req_port=4242,\n        pub_port=4243,\n        backend=backend\n    )\n\n    # Start the server\n    await server.start()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(run_server())\n</code></pre> <p>The <code>req_port</code> and <code>pub_port</code> parameters specify the network ports for the two communication channels provided by the registry: the REQ-REP socket (handling service requests and responses) and the PUB-SUB socket (broadcasting event notifications). Both parameters are optional; if omitted, the system will use the default values defined as constants <code>egse.registry.DEFAULT_RS_REQ_PORT</code> and <code>egse.registry.DEFAULT_RS_PUB_PORT</code> respectively. The <code>backend</code> parameter determines which <code>RegistryBackend</code> implementation will store and manage the service registration data. This allows flexibility in how service information is persisted (e.g., in-memory, file-based, or database-backed storage). An additional optional parameter, <code>cleanup_interval</code>, controls how frequently (in seconds) the registry scans for and removes expired service registrations whose TTL has elapsed. This automatic cleanup mechanism ensures the registry maintains an accurate representation of available services.</p>"},{"location":"libs/cgse-core/registry/#storage-backends","title":"Storage Backends","text":"<p>The server works with any backend that implements the <code>AsyncRegistryBackend</code> protocol. Two implementations are provided:</p> <ul> <li><code>AsyncSQLiteBackend</code>: Persistent storage using SQLite</li> <li><code>AsyncInMemoryBackend</code>: In-memory storage for testing or simple deployments</li> </ul>"},{"location":"libs/cgse-core/registry/#service-registration-protocol","title":"Service Registration Protocol","text":"<p>The server accepts requests in JSON format through its REQ-REP socket. Each request must have an <code>action</code> field specifying the operation.</p>"},{"location":"libs/cgse-core/registry/#registration","title":"Registration","text":"<pre><code>{\n  \"action\": \"register\",\n  \"service_info\": {\n    \"name\": \"example-service\",\n    \"host\": \"192.168.1.10\",\n    \"port\": 8080,\n    \"type\": \"web\",\n    \"tags\": [\n      \"web\",\n      \"api\"\n    ],\n    \"metadata\": {\n      \"version\": \"1.0.0\"\n    }\n  },\n  \"ttl\": 30\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"service_id\": \"example-service-f47ac10b-58cc-4372-a567-0e02b2c3d479\",\n  \"message\": \"Service registered successfully\"\n}\n</code></pre>"},{"location":"libs/cgse-core/registry/#de-registration","title":"De-registration","text":"<pre><code>{\n  \"action\": \"deregister\",\n  \"service_id\": \"example-service-f47ac10b-58cc-4372-a567-0e02b2c3d479\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"message\": \"Service deregistered successfully\"\n}\n</code></pre>"},{"location":"libs/cgse-core/registry/#service-renewal-heartbeat","title":"Service Renewal (Heartbeat)","text":"<pre><code>{\n  \"action\": \"renew\",\n  \"service_id\": \"example-service-f47ac10b-58cc-4372-a567-0e02b2c3d479\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"message\": \"Service renewed successfully\"\n}\n</code></pre>"},{"location":"libs/cgse-core/registry/#get-service","title":"Get Service","text":"<pre><code>{\n  \"action\": \"get\",\n  \"service_id\": \"example-service-f47ac10b-58cc-4372-a567-0e02b2c3d479\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"service\": {\n    \"id\": \"example-service-f47ac10b-58cc-4372-a567-0e02b2c3d479\",\n    \"name\": \"example-service\",\n    \"host\": \"192.168.1.10\",\n    \"port\": 8080,\n    \"type\": \"web\",\n    \"tags\": [\n      \"web\",\n      \"api\"\n    ],\n    \"metadata\": {\n      \"version\": \"1.0.0\"\n    },\n    \"ttl\": 30,\n    \"last_heartbeat\": 1617293054,\n    \"health\": \"passing\"\n  }\n}\n</code></pre>"},{"location":"libs/cgse-core/registry/#list-services","title":"List Services","text":"<pre><code>{\n  \"action\": \"list\",\n  \"service_type\": \"web\"  // Optional, filter by type\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"services\": [\n    {\n      \"id\": \"service-1\",\n      \"name\": \"example-service\",\n      \"host\": \"192.168.1.10\",\n      \"port\": 8080,\n      \"type\": \"web\",\n      \"tags\": [\n        \"web\",\n        \"api\"\n      ],\n      \"metadata\": {\n        \"version\": \"1.0.0\"\n      },\n      \"ttl\": 30,\n      \"last_heartbeat\": 1617293054,\n      \"health\": \"passing\"\n    },\n    ...  // ... more services\n  ]\n}\n</code></pre>"},{"location":"libs/cgse-core/registry/#discover-service","title":"Discover Service","text":"<pre><code>{\n  \"action\": \"discover\",\n  \"service_type\": \"web\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"service\": {\n    \"id\": \"service-1\",\n    \"name\": \"example-service\",\n    \"host\": \"192.168.1.10\",\n    \"port\": 8080,\n    \"type\": \"web\",\n    \"tags\": [\n      \"web\",\n      \"api\"\n    ],\n    \"metadata\": {\n      \"version\": \"1.0.0\"\n    },\n    \"ttl\": 30,\n    \"last_heartbeat\": 1617293054,\n    \"health\": \"passing\"\n  }\n}\n</code></pre>"},{"location":"libs/cgse-core/registry/#health-check","title":"Health Check","text":"<pre><code>{\n  \"action\": \"health\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"status\": \"ok\",\n  \"timestamp\": 1617293054\n}\n</code></pre>"},{"location":"libs/cgse-core/registry/#event-broadcasting","title":"Event Broadcasting","text":"<p>The server publishes events to its PUB socket whenever services are registered, deregistered, or expire. Events have the following format:</p> <pre><code>{\n  \"type\": \"register\",  // or \"deregister\", \"expire\"\n  \"timestamp\": 1617293054,\n  \"data\": {\n    \"service_id\": \"service-1\",\n    \"service_info\": {\n      ... // Service information\n    }\n  }\n}\n</code></pre> <p>Clients can subscribe to these events to maintain a local cache of service information.</p>"},{"location":"libs/cgse-core/registry/#service-discovery-patterns","title":"Service Discovery Patterns","text":""},{"location":"libs/cgse-core/registry/#load-balancing","title":"Load Balancing","text":"<p>The <code>discover_service</code> action implements a simple load balancing strategy by default, returning a random healthy service of the requested type. For more advanced load balancing strategies, we could:</p> <ol> <li>Extend <code>AsyncRegistryBackend</code> with custom discovery logic</li> <li>Implement client-side load balancing in your service clients</li> <li>Use a dedicated load balancer in front of your services</li> </ol>"},{"location":"libs/cgse-core/registry/#circuit-breaking","title":"Circuit Breaking","text":"<p>When services become unhealthy (failing to send heartbeats), they will be automatically marked as \"critical\" and excluded from discovery results. This provides a basic circuit breaking mechanism.</p>"},{"location":"libs/cgse-core/registry/#troubleshooting","title":"Troubleshooting","text":""},{"location":"libs/cgse-core/registry/#resource-temporarily-unavailable-error","title":"\"Resource temporarily unavailable\" Error","text":"<p>This typically indicates a ZeroMQ socket is in an invalid state or connection issues:</p> <ul> <li>Ensure ports are not in use by other applications</li> <li>Check network connectivity between services</li> <li>Use longer timeouts for high-latency environments</li> </ul>"},{"location":"libs/cgse-core/registry/#services-not-being-discovered","title":"Services Not Being Discovered","text":"<p>If services register successfully but can't be discovered:</p> <ul> <li>Verify services are sending heartbeats regularly</li> <li>Check that services include the proper type and tags</li> <li>Ensure TTL values are appropriate for your environment</li> </ul>"},{"location":"libs/cgse-core/registry/#performance-considerations","title":"Performance Considerations","text":""},{"location":"libs/cgse-core/registry/#scaling","title":"Scaling","text":"<p>For high-scale deployments:</p> <ul> <li>Use a more robust backend like a dedicated database server</li> <li>Deploy multiple registry servers behind a load balancer</li> </ul>"},{"location":"libs/cgse-core/registry/#resource-usage","title":"Resource Usage","text":"<p>The server's resource consumption is primarily affected by:</p> <ul> <li>Number of registered services</li> <li>Frequency of service heartbeats</li> <li>Cleanup interval for expired services</li> </ul> <p>For large deployments, monitor memory usage and adjust these parameters accordingly.</p>"},{"location":"libs/cgse-core/registry/#zeromq-socket-configuration","title":"ZeroMQ Socket Configuration","text":"<p>For high-throughput environments, consider tuning ZeroMQ socket options:</p> <pre><code>socket.setsockopt(zmq.RCVHWM, 10000)  # Receive high-water mark\nsocket.setsockopt(zmq.SNDHWM, 10000)  # Send high-water mark\n</code></pre>"},{"location":"libs/cgse-core/registry/#security-considerations","title":"Security Considerations","text":"<p>The basic implementation does not include authentication or encryption. For production use, consider:</p> <ul> <li>Using ZeroMQ's built-in security mechanisms (CurveZMQ)</li> <li>Placing the registry server in a secure network segment</li> <li>Implementing application-level authentication for service registration</li> </ul> <p>Example with CurveZMQ (requires additional setup):</p> <pre><code>public_key, secret_key = zmq.curve_keypair()\nsocket.setsockopt(zmq.CURVE_SECRETKEY, secret_key)\nsocket.setsockopt(zmq.CURVE_PUBLICKEY, public_key)\nsocket.setsockopt(zmq.CURVE_SERVER, True)\n</code></pre>"},{"location":"libs/cgse-gui/","title":"GUI Components","text":""},{"location":"projects/","title":"Projects","text":"<p>The projects are those packages that add functionality to the CGSE framework.</p> <p>The projects live under the folder <code>projects</code>, and they are organised in generic and specific projects. Generic  projects do not have an implementation that is specific for one particular project, while, obviously, specific  projects have. We currently have the following generic packages:</p> <ul> <li><code>cgse-tools</code></li> <li><code>symetrie-hexapod</code></li> <li><code>keithley-tempcontrol</code></li> </ul> <p>and then there are the project specific packages:</p> <ul> <li><code>plato-fits</code></li> <li><code>plato-hdf5</code></li> <li><code>plato-spw</code></li> </ul>"},{"location":"projects/cgse-tools/","title":"Tools for the CGSE framework","text":""},{"location":"projects/symetrie-hexapod/","title":"The Sym\u00e9trie Hexapods","text":""},{"location":"projects/symetrie-hexapod/#settings-up-your-system-for-the-puna-hexapod","title":"Settings up your system for the PUNA Hexapod","text":"<p>Warning</p> <p>We need some work here... we want to be able to use multiple hexapods in the same Setup and  they can be the same type or different types. So, how do we specify two PUNA hexapods used  to position two different parts of your test equiopment?  </p> <p>The system needs to know the following information on the hexapod:</p> <ul> <li>device name: specified in the Setup under <code>setup.gse.hexapod.device_args.device_name</code></li> <li>device id: specified in the Setup under <code>setup.gse.hexapod.device_args.device_id</code></li> </ul> <p>These above settings can olso be specified in the environment variables:</p> <ul> <li>SYMETRIE_HEXAPOD_NAME</li> <li>SYMETRIE_HEXAPOD_ID</li> </ul>"},{"location":"user_guide/","title":"User Guide","text":"<p>Welcome to the CGSE user guide! An in-depth reference on how to use the CGSE.</p>"}]}