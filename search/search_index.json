{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Tip</p> <p>See the navigation links in the header or side-bar.</p> <p>Click  (top left) on mobile.</p>"},{"location":"#welcome","title":"Welcome","text":"<p>Welcome to the CGSE framework documentation.</p> <p>Get started or go straight to the Tutorial</p>"},{"location":"#what-is-the-cgse","title":"What is the CGSE?","text":"<p>The CGSE is short for Common-EGSE, a framework for managing and running test equipment in a lab. The EGSE stands for  Electrical Ground Support Equipment, and this includes all equipment that is used to test or calibration an instrument.</p> <ul> <li>computers: a server running the CGSE and archiving test data and a client to control the test equipment</li> <li>temperature controllers: control heaters and monitor temperature sensors</li> <li>mechanisms: control mechanisms like hexapods or linear stages </li> <li>optics: control optical equipment like lasers and attenuators</li> <li>any other device that can be connected through an Ethernet or USB connection and with a open API.</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":"<p>All you need to get started using and building the CGSE.</p>"},{"location":"getting_started/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9.x (we do not yet support higher versions, but are working to extend the list)</li> <li>macOS or Linux</li> </ul>"},{"location":"getting_started/#virtual-environment","title":"Virtual environment","text":"<p>You should always work inside a virtual environment to somehow containerize your project such that it doesn't  pollute your global environment and you can run different projects next to each other. Create and activate a new  virtual environment as follows. It should be Python &gt;= 3.9</p> <pre><code>$ python -m venv venv\n$ source venv/bin/activate\n</code></pre>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>The easiest way to install the CGSE is to use the <code>pip</code> command. Since the CGSE is a monorepo and consists of  several packages, you will need to make your choice which package you need for your project. You can however start  with the <code>cgse-common</code> which contains all common code that is generic and useful as a basis for other packages.</p> <pre><code>$ pip install cgse-common\n</code></pre> <p>Check the list of packages that are part of the CGSE repo and can be installed with <code>pip</code>. The  packages are described in more detail in the sections Libs and Projects.</p>"},{"location":"getting_started/#set-up-your-environment","title":"Set up your environment","text":"<p>To check your installation and set up your environment, here are a few tips.</p> <p>The version of the core packages and any plugin packages can be verified as follows. The version you installed will  probably be higher and more lines will appear when other packages are installed.</p> <pre><code>$ py -m egse.version\nCGSE version in Settings: 2025.0.5\nInstalled version for cgse-common= 2025.0.5\n</code></pre> <p>Check your environment with the command below. This will probably print out some warning since you have not defined  the expected environment variables yet. There are two mandatory environment variables: <code>PROJECT</code> and <code>SITE_ID</code>. The  former shall contain the name of your project without spaces and preferably a single word or an acronym like PLATO,  ARIEL, MARVEL, MERCATOR. The latter is the name of the site or lab where the tests will be performed. Good names are  KUL, ESA, LAB23.</p> <p>The other environment variables follow the pattern <code>&lt;PROJECT&gt;_...</code>, i.e. they all start with the project name as  defined  in the PROJECT environment variable. You should define at least <code>&lt;PROJECT&gt;_DATA_STORAGE_LOCATION</code>. The configuration  data and log file location will be derived from it unless they are explicitly set themselves. </p> <p>Let's define the three expected environment variables:</p> <pre><code>$ export PROJECT=ARIEL\n$ export SITE_ID=VACUUM_LAB\n$ export ARIEL_DATA_STORAGE_LOCATION=~/data\n</code></pre> <p>Rerunning the above command now gives:</p> <pre><code>$ py -m egse.env\nEnvironment variables:\n    PROJECT = ARIEL\n    SITE_ID = VACUUM_LAB\n    ARIEL_DATA_STORAGE_LOCATION = /Users/rik/data\n    ARIEL_CONF_DATA_LOCATION = not set\n    ARIEL_CONF_REPO_LOCATION = not set\n    ARIEL_LOG_FILE_LOCATION = not set\n    ARIEL_LOCAL_SETTINGS = not set\n\nGenerated locations and filenames\n    get_data_storage_location() = '/Users/rik/data/VACUUM_LAB'  \u27f6 ERROR: The data storage location doesn't exist!\n    get_conf_data_location() = '/Users/rik/data/VACUUM_LAB/conf'  \u27f6 ERROR: The configuration data location doesn't exist!\n    get_conf_repo_location() = None  \u27f6 ERROR: The configuration repository location doesn't exist!\n    get_log_file_location() = '/Users/rik/data/VACUUM_LAB/log'  \u27f6 ERROR: The log files location doesn't exist!\n    get_local_settings() = None  \u27f6 ERROR: The local settings file is not defined or doesn't exist!\n\nuse the '--full' flag to get a more detailed report, '--doc' for help on the variables.\n</code></pre> <p>Note</p> <p>The folders that do not exist (and are not None) can be created by adding the option <code>--mkdir</code> to the above  command.</p>"},{"location":"getting_started/#check-your-settings","title":"Check your Settings","text":"<p>Settings contains the static configuration of your system, test setup, equipment, including the System Under Test  (SUT). You can test your settings with the command below. Let's first also set the <code>ARIEL_LOCALSETTINGS</code> environment  variables:</p> <p><pre><code>$ export ARIEL_LOCAL_SETTINGS=~/cgse/local_settings_ariel_vacuum_lab.yaml\n$ py -m egse.settings\nSettings\n\u251c\u2500\u2500 PACKAGES\n\u2502   \u2514\u2500\u2500 CGSE_COMMON: Common classes, functions, decorators, etc. for the CGSE\n\u251c\u2500\u2500 SITE\n\u2502   \u251c\u2500\u2500 ID: VACUUM_LAB\n\u2502   \u251c\u2500\u2500 SSH_SERVER: localhost\n\u2502   \u2514\u2500\u2500 SSH_PORT: 22\n\u2514\u2500\u2500 PROCESS\n    \u2514\u2500\u2500 METRICS_INTERVAL: 10\nMemoized locations:\n['/Users/rik/tmp/gettings-started/venv/lib/python3.9/site-packages/cgse_common/settings.yaml', \n'/Users/rik/cgse/local_settings_ariel_vacuum_lab.yaml']\n</code></pre> These Settings will grow when you add more packages to your installation or when you define settings yourself in the  local settings file.</p>"},{"location":"help/","title":"Help","text":"<p>The best way to get help for something that you couldn't find in the documentation on this site, is to contact one of  the authors.</p>"},{"location":"help/#bugs-and-feature-requests","title":"Bugs and Feature requests","text":"<p>Report any bugs or issues through GitHub on the CGSE issues page.  </p>"},{"location":"initialize/","title":"Initialize your project","text":"<p>So, we have seen how to get started with some basic commands and only the <code>cgse-common</code> package. It's time now to  initialize your project properly with all the necessary services.</p>"},{"location":"initialize/#set-up-your-environment","title":"Set up your environment","text":"<p>I assume you are in the same environment that we have set up in the previous section where  also the <code>cgse-common</code> package was installed. We will install another package that will provide us with the full  functionality of the <code>cgse</code> command. Install the <code>cgse-tools</code> package which depends on <code>cgse-core</code> and will also  install that package.</p> <pre><code>$ pip install cgse-tools\n</code></pre> <p>You should now have at least the follow three packages installed in your virtual environment:</p> <pre><code>$ pip list | grep cgse\ncgse-common       2025.0.8\ncgse-core         2025.0.8\ncgse-tools        2025.0.8\n</code></pre>"},{"location":"initialize/#the-cgse-command","title":"The <code>cgse</code> command","text":"<p>The two new packages that have been installed (<code>cgse-core</code> and <code>cgse-tools</code>) provide the <code>cgse</code> command that we will  use to initialize your environment, but this command is also used to inspect different parts of the system, manage core  services and device drivers, etc.</p> <p>When you run the <code>cgse</code> command without any arguments, it will show something like this:</p> <p><pre><code>$ cgse\n\n Usage: cgse [OPTIONS] COMMAND [ARGS]...\n\n The main cgse command to inspect, configure, monitor the core services and device control servers.\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --install-completion          Install completion for the current shell.                                                                                      \u2502\n\u2502 --show-completion             Show completion for the current shell, to copy it or customize the installation.                                               \u2502\n\u2502 --help                        Show this message and exit.                                                                                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 version   Prints the version of the cgse-core and other registered packages.                                                                                 \u2502\n\u2502 init      Initialize your project.                                                                                                                           \u2502\n\u2502 top       A top-like interface for core services and device control servers.                                                                                 \u2502\n\u2502 core      handle core services: start, stop, status                                                                                                          \u2502\n\u2502 show      Show information about settings, environment, setup, ...                                                                                           \u2502\n\u2502 check     Check installation, settings, required files, etc.                                                                                                 \u2502\n\u2502 dev-x     device-x is an imaginary device that serves as an example                                                                                          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> The <code>cgse</code> command is actually an app that is the starting point for a number of commands that can be used to maintain  the system, manage and inspect services and devices. For example, to check the version of the different components,  use:</p> <pre><code>$ cgse version\nCGSE-COMMON installed version = 2025.0.8\nCGSE-CORE installed version = 2025.0.8\nCGSE-TOOLS installed version = 2025.0.8\n</code></pre> <p>We will for now concentrate on the <code>init</code> command. This command will guide us through a number of steps to define  the location of our device data, configuration data, etc. We will basically define some environment variables that  are used by the CGSE framework. The PROJECT is he name of the project your will be working on, the SITE_ID is the  identifier for the LAB or Setup that you are using to perform the tests. As you see below, the environment  variables all start with the project name allowing you to work on different projects simultaneously. If you accept all  the defaults, the result of the <code>cgse init</code> command will look something like this:</p> <p><pre><code>$ cgse init --project marvel\nPlease note default values are given between [brackets].\nWhat is the name of the project [MARVEL] ?:\nWhat is the site identifier ?: lab02\nWhere can the project data be stored [~/data/MARVEL/LAB02/] ?:\nWhere will the configuration data be located [~/data/MARVEL/LAB02/conf/] ?:\nWhere will the logging messages be stored [~/data/MARVEL/LAB02/log/] ?:\nWhere shall I create a local settings YAML file [~/data/MARVEL/LAB02/local_settings.yaml] ?:\nShall I add the environment to your ~/bash_profile ? [y/n]: n\n\n# -&gt; Add the following lines to your bash profile or equivalent\n\nexport PROJECT=MARVEL\nexport SITE_ID=LAB02\nexport MARVEL_DATA_STORAGE_LOCATION=~/data/MARVEL/LAB02/\nexport MARVEL_CONF_DATA_LOCATION=~/data/MARVEL/LAB02/conf/\nexport MARVEL_LOG_FILE_LOCATION=~/data/MARVEL/LAB02/log/\nexport MARVEL_LOCAL_SETTINGS=~/data/MARVEL/LAB02/local_settings.yaml\n</code></pre> If you answered 'Y' to the last question, you should log in to the shell again with <code>exec bash -login</code> or a similar  command for other shells, or you should start a new terminal to activate the environment variables.</p> <p>Add this point you are ready to go and start the core services and any device control servers that you need. You can explore other commands of the <code>cgse</code> app in the user guide.</p>"},{"location":"package_list/","title":"Packages in the CGSE","text":"<p>The CGSE is a monorepo and consists of numerous packages. Each of these packages are individually installable from  PyPI. We maintain a list here with all the packages in the monorepo.</p> Package Description <code>cgse-common</code> The common code used by all other packages <code>cgse-core</code> The core services <code>cgse-coordinates</code> Coordinate reference Frames <code>cgse-gui</code> GUI components and styles (PyQt5) <code>cgse-tools</code> Plugin that adds functions to the <code>cgse</code> command <code>symetrie-hexapod</code> Device drivers for the Sym\u00e9trie Hexapods <code>plato-fits</code> FITS driver with PLATO specific format <code>plato-hdf5</code> HDF5 driver with PLATO specific format <code>plato-spw</code> SpaceWire driver with PATO specific packets"},{"location":"tutorial/","title":"Tutorial","text":"<p>Welcome to the CGSE Tutorial!</p> <p>By the end of this page you should have a solid understanding of the core features of the CGSE.</p>"},{"location":"dev_guide/","title":"Developer Guide","text":"<p>Welcome to the CGSE developer guide! An in-depth reference on how to contribute to the CGSE.</p> <p>First thing to know is that this repository is actually a monorepo, meaning it contains a bunch of related but  self-standing packages with a minimum of interdependencies. These packages are  </p>"},{"location":"dev_guide/coding_style/","title":"Style Guide","text":"<p>This part of the developer guide contains instructions for coding styles that are adopted for this project.</p> <p>The style guide that we use for this project is PEP8. This is the standard for Python code and all IDEs, parsers and code formatters understand and work with this standard. PEP8 leaves room for project specific styles. A good style guide that we can follow is the Google Style Guide.</p> <p>The following sections will give the most used conventions with a few examples of good and bad.</p>"},{"location":"dev_guide/coding_style/#tldr","title":"TL;DR","text":"Type Style Example Classes CapWords ProcessManager, ImageViewer, CommandList, Observation, MetaData Methods &amp; Functions lowercase with underscores get_value, set_mask, create_image Variables lowercase with underscores key, last_value, model, index, user_info Constants UPPERCASE with underscores MAX_LINES, BLACK, COMMANDING_PORT Modules &amp; packages lowercase no underscores dataset, commanding, multiprocessing"},{"location":"dev_guide/coding_style/#general","title":"General","text":"<ul> <li>Name the class or variable or function with what it is, what it does or what it contains. A variable named <code>user_list</code> might look good at first, but what if at some point you want to change the list to a set so it can not contain duplicates. Are you going to rename everything into <code>user_set</code> or would <code>user_info</code> be a better name?</li> <li>Never use dashes in any name, they will raise a <code>SyntaxError: invalid syntax</code>.</li> <li>We introduce a number of relaxations to not break backward compatibility for the sake of a naming convention. As described in A Foolish Consistency is the Hobgoblin of Little Minds: Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important. [...] do not break backwards compatibility just to comply with this PEP!</li> </ul>"},{"location":"dev_guide/coding_style/#classes","title":"Classes","text":"<p>Always use CamelCase (Python uses CapWords) for class names. When using acronyms, keep them all UPPER case.</p> <ul> <li>Class names should be nouns, like Observation</li> <li>Make sure to name classes distinctively</li> <li>Stick to one word for a concept when naming classes, i.e. words like <code>Manager</code> or <code>Controller</code> or <code>Organizer</code> all mean similar things. Choose one word for the concept and stick to it.</li> <li>If a word is already part of a package or module, don't use the same word in the class name again.</li> </ul> <p>Good names are: <code>Observation</code>, <code>CalibrationFile</code>, <code>MetaData</code>, <code>Message</code>, <code>ReferenceFrame</code>, <code>URLParser</code>.</p>"},{"location":"dev_guide/coding_style/#methods-and-functions","title":"Methods and Functions","text":"<p>A function or a method does something (and should only do one thing, SRP=Single Responsibility Principle), it is an action, so the name should reflect that action.</p> <p>Always use lowercase words separated with underscores.</p> <p>Good names are: <code>get_time_in_ms()</code>, <code>get_commanding_port()</code>, <code>is_connected()</code>, <code>parse_time()</code>, <code>setup_mask()</code>.</p> <p>When working with legacy code or code from another project, names may be in camelCase (with the first letter a lower case letter). So we can in this case use also <code>getCommandPort()</code> or <code>isConnected()</code> as method and function names.</p>"},{"location":"dev_guide/coding_style/#variables","title":"Variables","text":"<p>Use the same naming convention as functions and methods, i.e. lowercase with underscores.</p> <p>Good names are: <code>key</code>, <code>value</code>, <code>user_info</code>, <code>model</code>, <code>last_value</code></p> <p>Bad names: <code>NSegments</code>, <code>outNoise</code></p> <p>Take care not to use builtins: <code>list</code>, <code>type</code>, <code>filter</code>, <code>lambda</code>, <code>map</code>, <code>dict</code>, ...</p> <p>Private variables (for classes) start with an underscore: <code>_name</code> or <code>_total_n_args</code>.</p> <p>In the same spirit as method and function names, the variables can also be in camelCase for specific cases.</p>"},{"location":"dev_guide/coding_style/#constants","title":"CONSTANTS","text":"<p>Use ALL_UPPER_CASE with underscores for constants. Use constants always within a name space, not globally.</p> <p>Good names: <code>MAX_LINES</code>, <code>BLACK</code>, <code>YELLOW</code>, <code>ESL_LINK_MODE_DISABLED</code></p>"},{"location":"dev_guide/coding_style/#modules-and-packages","title":"Modules and Packages","text":"<p>Use simple words for modules, preferably just one word like <code>datasets</code> or <code>commanding</code> or <code>storage</code> or <code>extensions</code>. If two words are unavoidable, just concatenate them, like <code>multiprocessing</code> or <code>sampledata</code> or <code>testdata</code>. If needed for readability, use an underscore to separate the words, e.g. <code>image_analysis</code>.</p>"},{"location":"dev_guide/coding_style/#import-statements","title":"Import Statements","text":"<ul> <li>Group and sort import statements</li> <li>Never use the form <code>from &lt;module&gt; import *</code></li> <li>Always use absolute imports in scripts</li> </ul> <p>Be careful that you do not name any modules the same as a module in the Python standard library. This can result in strange effects and may result in an <code>AttributeError</code>. Suppose you have named a module <code>math</code> in the <code>egse</code> directory and it is imported and used further in the code as follows:</p> <pre><code>from egse import math\n\n# in some expression further down the code you might use\n\nmath.exp(a)\n</code></pre> <p>This will result in the following runtime error:</p> <pre><code>File \"some_module.py\", line 8, in &lt;module&gt;\n  print(math.exp(a))\nAttributeError: module 'egse.math' has no attribute 'exp'\n</code></pre> <p>Of course this is an obvious example, but it might be more obscure like e.g. in this GitHub issue: 'module'  object has no attribute 'Cmd'.</p>"},{"location":"dev_guide/docs/","title":"Building the documentation","text":"<ul> <li>Make sure you are in a virtual environment with Python 3.10+</li> <li>Run the <code>mkdocs serve</code> from the project root older</li> <li>Create new pages by adding folder and Markdown files inside <code>docs/*</code></li> </ul>"},{"location":"dev_guide/docs/#set-up-your-environment","title":"Set up your environment","text":"<p>I created a virtual environment using <code>pyenv</code> and when I'm working on the documentation, I start up a shell with  this environment. Currently, only <code>mkdocs</code> and <code>mkdocs-material</code> are needed. Of course, you need to install these  only once.</p> <pre><code>$ pyenv virtualenv 3.10 cgse-doc-3.10\n$ pyenv shell cgse-doc-3.10\n$ pip install --upgrade pip setuptools wheel\n$ pip install mkdocs\n$ pip install mkdocs-material\n</code></pre> <p>From this shell, navigate to the project root folder and start the live-reload server of <code>mkdocs</code>.</p> <pre><code>$ cd ~/github/cgse\n$ mkdocs serve\n</code></pre> <p>Now you can update files, create new folders in <code>docs/*</code>, create new Markdown files and all changes will be reloaded  live in the browser.</p> <p>When you are ready with updating, you will need to build the site and publish it on GitHub pages:</p> <pre><code>$ mkdocs build\n$ mkdocs gh-deploy -r upstream -m \"documentation update on ..\"\n</code></pre>"},{"location":"dev_guide/docs/#commands","title":"Commands","text":"<ul> <li><code>mkdocs serve</code> \u2014 start the live-reloading docs server</li> <li><code>mkdocs build</code> \u2014 build the documentation site</li> <li><code>mkdocs deploy</code> \u2014 publish your documentation on GitHub pages</li> <li><code>mkdocs -h</code> \u2014 print a help message for more options</li> </ul>"},{"location":"dev_guide/docs/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml     # the mkdocs configuration file\ndocs/\n    index.md   # the documentation homepage\n    ...        # other markdown pages, image, folders, ...\n</code></pre>"},{"location":"dev_guide/installation/","title":"Installation Guide for Developers","text":""},{"location":"dev_guide/plugins/","title":"Plugins","text":"<p>The CGSE is designed to be extensible and uses a few plugin mechanisms to extend its functionally with external contributions. Also within the <code>cgse</code> monorepo we use the plugin mechanism at several places. The following entry-points are currently defined:</p> <ul> <li><code>cgse.version</code>: Each package that provides functionality within the CGSE or adds a device driver   registers itself to provide version information.</li> <li><code>cgse.command.plugins</code>: Packages can add commands or sub-commands to the <code>cgse</code> app to manage   their functionality from within the <code>cgse</code> app, e.g. to start or stop the service or to report on   its status.</li> <li><code>cgse.settings</code>: Package can add their own settings.</li> <li><code>cgse.resource</code>: Packages can register resources.</li> </ul> <p>Each of the entry-points knows how to load a module or object and each entry-point group is connected to a specific action or plugin hook like, e.g. add a command or command group to the <code>cgse</code> app, add package specific settings to the global settings.</p>"},{"location":"dev_guide/plugins/#version-discovery","title":"Version discovery","text":"<p>When you write a package that you want to integrate with the CGSE, provide a <code>cgse.version</code> entry-point. The name of the entry-point shall match the package name and is used to read the version from the importlib metadata. The entry-point value is currently not used. The entry-point value can optionally provide additional information about the package, but that is currently not specified.</p> <p>Add the following to your <code>pyproject.toml</code> file in your project's root folder, replacing package-name with the name of your project. The entry-point value is currently not used, but you want to use a valid format, the value below is always valid.</p> <pre><code>[project.entry-points.\"cgse.version\"]\npackage-name = 'egse.version:get_version_installed'\n</code></pre>"},{"location":"dev_guide/plugins/#extending-the-cgse-app","title":"Extending the <code>cgse</code> app","text":""},{"location":"dev_guide/plugins/#add-a-command","title":"Add a Command","text":"<p>If your package provides specific functionality that can be added as a command or a command group to the <code>cgse</code> app, use the <code>cgse.command</code> entry-point group. Since the <code>cgse</code> app uses the Typer package to build its commandline interface, adding a command is as simple as writing a function. The function will be added to the <code>cgse</code> app using the <code>app.command()</code> function of <code>Typer</code>, making the function a top-level command of the <code>cgse</code> app. The function can be defined as a plain function or with Typer's <code>@app.command</code> decorator.</p> <p>In the <code>pyproject.toml</code> file of your project, add the following lines to add the CGSE command:</p> <pre><code>[project.entry-points.\"cgse.command\"]\nname = 'module:object'\n</code></pre> <p>Where:</p> <ul> <li><code>name</code> is the name of the command</li> <li><code>module</code> is a fully qualified module name for your package, a module that can be imported</li> <li><code>object</code> is the name of the function that you want to add as a command</li> </ul> <p>As an example, for the <code>cgse-tools</code> package, the <code>init</code> command of the <code>cgse</code> app is listed in the <code>pyproject.toml</code> file as follows:</p> <pre><code>[project.entry-points.\"cgse.command\"]\ninit = 'cgse_tools.cgse_commands:init'\n</code></pre> <p>The <code>init</code> function is defined in the <code>cgse_commands.py</code> module which is located in the <code>cgse_tools</code> module in the <code>src</code> folder of the package:</p> <pre><code>src\n\u251c\u2500\u2500 cgse_tools\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 cgse_commands.py\n...\n</code></pre>"},{"location":"dev_guide/plugins/#add-a-command-group","title":"Add a Command group","text":"<p>Some commands are more complicated and define a number of sub-commands. An example is the <code>show</code> command where you currently have the sub-commands <code>env</code> and <code>settings</code></p> <pre><code>$ cgse show --help\n\n Usage: cgse show [OPTIONS] COMMAND [ARGS]...\n\n Show information about settings, environment, setup, ...\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                           \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 settings   Show the settings that are defined by the installed packages.              \u2502\n\u2502 env        Show the environment variables that are defined for the project.           \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>The <code>show</code> command is defined as a <code>typer.Typer()</code> object where <code>env</code> and <code>settings</code> are added using the decorator <code>@&lt;app&gt;.command()</code>.</p> <pre><code>import typer\n\nshow = typer.Typer(help=\"Show information about settings, environment, setup, ...\")\n\n\n@show.command(name=\"settings\")\ndef show_settings():\n    ...\n\n\n@show.command(name=\"env\")\ndef show_env():\n    ...\n</code></pre> <p>To add this command group to the <code>cgse</code> app, the following entry was used in the <code>pyproject. toml</code> file of the <code>cgse-tools</code> project. Notice the <code>[group]</code> at the end of the entry which indicates this is a command group instead of a single command.</p> <pre><code>[project.entry-points.\"cgse.command\"]\nshow = 'cgse_tools.cgse_commands:show[group]'\n</code></pre>"},{"location":"dev_guide/plugins/#add-a-service","title":"Add a Service","text":"<p>If your package provides a device driver or a specific service, use the <code>cgse.service</code> entry-point group. Service entry-points follow the same scheme as command groups, i.e. they are added to the <code>cgse</code> app as a <code>Typer()</code> object. Use the following entry in your <code>pyproject.toml</code> file:</p> <pre><code>[project.entry-points.\"cgse.service\"]\nname = 'module:object'\n</code></pre> <p>where:</p> <ul> <li><code>name</code> is the name of the service or device driver</li> <li><code>module</code> is a fully qualified module name for your package, a module that can be imported</li> <li><code>object</code> is the name of the <code>Typer()</code> object that you want to add as a service</li> </ul>"},{"location":"dev_guide/plugins/#register-resources","title":"Register resources","text":"<p>TODO: what if two packages provide a resource <code>icons</code> ?</p> <ul> <li>known resources: icons, styles</li> </ul>"},{"location":"dev_guide/uv/","title":"Working with <code>uv</code>","text":"<p><code>uv</code> is an extremely fast Python package and project manager, written in Rust. We will use <code>uv</code> as the single tool that replaces <code>pip</code>, <code>virtualenv</code>, <code>pyenv</code>, and more. The main tasks for which we will use <code>uv</code> are:</p> <ul> <li>run and install Python versions</li> <li>installing and managing a virtual environment</li> <li>build all the packages in the workspace or monorepo</li> <li>publish all the packages to PyPI</li> <li>run scripts and apps</li> </ul>"},{"location":"dev_guide/uv/#installing-uv","title":"Installing <code>uv</code>","text":"<p>On macOS and Linux you can install <code>uv</code> using <code>curl</code>:</p> <pre><code>$ curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>If you need more specific information on installing and upgrading <code>uv</code>, please refer to the official documentation.</p>"},{"location":"dev_guide/uv/#installing-a-python-version","title":"Installing a Python version","text":"<p>The CGSE is guaranteed to work with Python 3.9.x. We will gradually include higher versions of Python, but currently  these have not been tested. So, we will for the moment stick with Python 3.9.20. Install this version as follows:</p> <pre><code>$ uv python install 3.9.20\n</code></pre> <p><code>pyenv</code></p> <p>When using <code>pyenv</code> to manage your Python versions, make sure you also have the same Python version installed  with <code>pyenv</code> and <code>uv</code>. Otherwise you will run into the following error. This is a known issue with <code>uv</code>.</p> <pre><code>pyenv: version `3.9.20' is not installed (set by /Users/rik/github/cgse/libs/cgse-common/.python-version)\n</code></pre> <p>You can check which Python versions are installed already on your system:</p> CommandOutput <pre><code>$ uv python list --only-installed\n</code></pre> <pre><code>cpython-3.12.8-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.12.8-macos-aarch64-none/bin/python3.12\ncpython-3.10.16-macos-aarch64-none    /Users/rik/Library/Application Support/uv/python/cpython-3.10.16-macos-aarch64-none/bin/python3.10\ncpython-3.9.21-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.9.21-macos-aarch64-none/bin/python3.9\ncpython-3.9.20-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.9.20-macos-aarch64-none/bin/python3.9\ncpython-3.9.6-macos-aarch64-none      /Library/Developer/CommandLineTools/usr/bin/python3 -&gt; ../../Library/Frameworks/Python3.framework/Versions/3.9/bin/python3\ncpython-3.8.17-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.8.17-macos-aarch64-none/bin/python3.8\n</code></pre>"},{"location":"dev_guide/uv/#create-a-virtual-environment","title":"Create a virtual environment","text":"<p>Pin a Python version</p> <p>You can pin a python version with the command:</p> <pre><code>$ uv python pin 3.9.20\n</code></pre> <p><code>uv</code> will search for a pinned version in the parent folders up to the root folder or your home directory.</p> <p>You can create a virtual environment with <code>uv</code> for the specific Python version as follows. The '<code>--python</code>' is optional  and <code>uv</code> will use the default (pinned) Python version when creating a <code>venv</code> without this option. When creating a  virtual environment make sure you are in the package root, e.g. <code>~/github/cgse/libs/cgse-common</code>.</p> <pre><code>$ cd ~/github/cgse/libs/cgse-common\n$ uv venv --python 3.9.20\n</code></pre> <p>Assuming you are in the package root where you created the virtual environment, you can now install its dependencies  with <code>pip install</code> as follows:</p> <pre><code>$ uv pip install -r pyproject.toml\n</code></pre> <p>To install the current project as an editable package:</p> <pre><code>$ uv pip install -e .\n</code></pre> <p>Note</p> <p>If you don't want to use the <code>uv</code> commands, you can activate the virtual environment and use the original <code>pip</code>  and <code>python</code> commands as you are used to.</p> <pre><code>$ source .venv/bin/activate\n</code></pre> <p>Info</p> <p>In a workspace, maintaining a virtual environment per package might be a hassle and most of the time that is not  needed. A good approach is to always use the virtual environment at the workspace root. This <code>venv</code> which will be  automatically created if you run a command or if you use <code>uv sync</code> in the package folder. With <code>uv sync</code> you can  make sure the virtual environment is up-to-date and contains only those dependencies that are required for the  package you are in. So, each time you switch to another package and want to run a comand or a test for that  package, use </p> <pre><code>$ uv sync\n</code></pre>"},{"location":"dev_guide/uv/#building-and-publishing-all-packages","title":"Building and publishing all packages","text":"<p>We have chosen for one and the same version number for all packages in the <code>cgse</code> monorepo. That means that whenever  we make a change to one of the packages and want to release that change, all packages shall be rebuild and published.</p> <p>Inline</p> <p>When working in a workspace, keep in mind that the commands <code>uv run</code> and <code>uv sync</code> by default work on the  workspace root. That means that when you run the <code>uv run pip install &lt;package&gt;</code> command, the <code>.venv</code> at the  workspace root will be updated or created if it didn't exist. Similar for the <code>uv sync</code> command, there is only  one <code>uv.lock</code> file at the root of the workspace.  </p> <p>Fortunately, with <code>uv</code>, that is done in a few commands.</p> <p>When you are in the monorepo root folder, you can build all packages at once. They will be placed in the <code>dist</code> folder  of the root package. Before building, make sure you update the version in the <code>pyproject.toml</code> of the root package  and then bump the versions. Before building, clean up the <code>dist</code> folder, then you can do a default <code>uv publish</code> afterwards.</p> <pre><code>$ cd &lt;monorepo root&gt;\n$ uv run bump.py\n$ rm -r dist\n$ uv build --all-packages\n</code></pre> <p>Publish all packages in the root dist folder to PyPI. The UV_PUBLISH_TOKEN can be defined in a (read protected) ~/. setenv.bash file:</p> <pre><code>$ uv publish --token $UV_PUBLISH_TOKEN\n</code></pre> <p>The above command will publish all package to PyPI. If you don't want the token to be in a shell variable, you can  omit the <code>--token</code> in the command above. You will then be asked for a username, use <code>__token__</code> as the username and  then provide the token as a password.</p>"},{"location":"libs/","title":"Libraries","text":"<p>The libraries are those packages that make up the CGSE framework.</p> <p>The libraries are located under the <code>libs</code> folder, and we currently find the following packages there:</p> <ul> <li><code>cgse-common</code></li> <li><code>cgse-core</code></li> <li><code>cgse-coordinates</code></li> <li><code>cgse-gui</code></li> </ul>"},{"location":"libs/cgse-common/","title":"Common Code","text":"<p>This package <code>cgse-common</code> contains modules that are used by all other packages. </p> Module Name Description <code>egse.bits</code> convenience functions to work with bits, bytes and integers <code>egse.calibration</code> functions to handle conversions and apply correction <code>egse.command</code> classes and functions to work with commands that operate hardware devices <code>egse.config</code> convenience functions to configure the system and find folders and files <code>egse.control</code> defines abstract classes and convenience functions for any control server <code>egse.decorators</code> a collection of useful decorator functions <code>egse.device</code> defines the generic interfaces to connect devices <code>egse.env</code> functionality to work with and check your environment variables <code>egse.exceptions</code> common Exceptions and Errors <code>egse.hk</code> functions to retrieve and convert housekeping parameter values <code>egse.metrics</code> functions to define and update metrics <code>egse.mixin</code> defines the mixin classes for dynamic commanding <code>egse.monitoring</code> the monitoring application / function <code>egse.observer</code> the classic observer and observable <code>egse.obsid</code> functions to define and work with the OBSID <code>egse.persistence</code> the persistence layer interface <code>egse.plugin</code> functions to load plugins and settings from entry-points <code>egse.process</code> functions and classes to work with processes and sub-processes <code>egse.protocol</code> base class for communicating commands with the hardware or the control server <code>egse.proxy</code> base class for the Proxy objects for each device controller <code>egse.reload</code> a slightly better approach to reloading modules and function <code>egse.resource</code> convenience functions to use resources in your code <code>egse.response</code> defines the classes to handle responses from the control servers <code>egse.services</code> provides the services to the control servers <code>egse.settings</code> provides functions to handle user and configuration settings <code>egse.setup</code> defines the Setup, containing the complete configuration for a test <code>egse.state</code> classes and functions to handle state, e.g. the GlobalState <code>egse.system</code> convenience functions that provide information on system specific functionality <code>egse.version</code> functions to load specific version information <code>egse.zmq_ser</code> serialization function used in a ZeroMQ context"},{"location":"libs/cgse-common/settings/","title":"The Settings","text":"<p>The Settings class contains all static information needed to configure your system, the environment you are using and the test equipment. The Settings also contain all the IP addresses and port number for all the known devices, together with other static information like the device name, default settings for the device like speed, timeout, delay time, firmware version, etc. We will go into more details about the content later, let\u2019s now first look at the format and usage of the Settings.</p>"},{"location":"libs/cgse-common/settings/#loading-the-settings","title":"Loading the Settings","text":"<p>The Settings can be loaded as follows:</p> <pre><code>&gt;&gt;&gt; from egse.settings import Settings\n&gt;&gt;&gt; settings = Settings.load()\n</code></pre> <p>The <code>settings</code> object will be a dictionary where the keys are the top-level groups that are defined in the settings for each package. For a system that has only <code>cgse-common</code> and <code>cgse-core</code> installed, the <code>settings</code> will contain something like this:</p> <pre><code>&gt;&gt;&gt; print(settings)\nSettings\n\u251c\u2500\u2500 PACKAGES\n\u2502   \u251c\u2500\u2500 CGSE_COMMON: Common classes, functions, decorators, etc. for the CGSE\n\u2502   \u2514\u2500\u2500 CGSE_CORE: The core services of the CGSE\n\u251c\u2500\u2500 SITE\n\u2502   \u251c\u2500\u2500 ID: LAB42\n\u2502   \u251c\u2500\u2500 SSH_SERVER: localhost\n\u2502   \u2514\u2500\u2500 SSH_PORT: 22\n\u251c\u2500\u2500 PROCESS\n\u2502   \u2514\u2500\u2500 METRICS_INTERVAL: 10\n\u251c\u2500\u2500 Logging Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 LOGGING_PORT: 7000\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 7001\n\u2502   \u251c\u2500\u2500 METRICS_PORT: 7003\n\u2502   \u251c\u2500\u2500 MAX_NR_LOG_FILES: 20\n\u2502   \u251c\u2500\u2500 MAX_SIZE_LOG_FILES: 20\n\u2502   \u251c\u2500\u2500 TEXTUALOG_IP_ADDRESS: 127.0.0.1\n\u2502   \u2514\u2500\u2500 TEXTUALOG_LISTENING_PORT: 19996\n\u251c\u2500\u2500 Configuration Manager Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 6000\n\u2502   \u251c\u2500\u2500 MONITORING_PORT: 6001\n\u2502   \u251c\u2500\u2500 SERVICE_PORT: 6002\n\u2502   \u251c\u2500\u2500 METRICS_PORT: 6003\n\u2502   \u251c\u2500\u2500 DELAY: 1\n\u2502   \u2514\u2500\u2500 STORAGE_MNEMONIC: CM\n\u2514\u2500\u2500 Storage Control Server\n    \u251c\u2500\u2500 PROTOCOL: tcp\n    \u251c\u2500\u2500 HOSTNAME: localhost\n    \u251c\u2500\u2500 COMMANDING_PORT: 6100\n    \u251c\u2500\u2500 MONITORING_PORT: 6101\n    \u251c\u2500\u2500 SERVICE_PORT: 6102\n    \u251c\u2500\u2500 METRICS_PORT: 6103\n    \u2514\u2500\u2500 DELAY: 1\n</code></pre> <p>If you only need the settings for a particular component, specify that group's name:</p> <pre><code>&gt;&gt;&gt; storage_settings = Settings.load(\"Storage Control Server\")\n\n&gt;&gt;&gt; print(storage_settings)\nStorage\nControl\nServer\n\u251c\u2500\u2500 PROTOCOL: tcp\n\u251c\u2500\u2500 HOSTNAME: localhost\n\u251c\u2500\u2500 COMMANDING_PORT: 6100\n\u251c\u2500\u2500 MONITORING_PORT: 6101\n\u251c\u2500\u2500 SERVICE_PORT: 6102\n\u251c\u2500\u2500 METRICS_PORT: 6103\n\u2514\u2500\u2500 DELAY: 1\n</code></pre> <p>The values can be accessed as usual with a dictionary, by specifying the name of the parameter as the key:</p> <pre><code>&gt;&gt;&gt; print(storage_settings[\"COMMANDING_PORT\"])\n6100\n</code></pre> <p>We usually only go one level deep when defining settings, and as a convenience, that first level of variables can also be accessed with the dot-notation.</p> <pre><code>&gt;&gt;&gt; print(storage_settings.COMMANDING_PORT)\n6100\n</code></pre>"},{"location":"libs/cgse-common/settings/#entry-points","title":"Entry-points","text":"<p>The Settings are collected from a set of YAML files which are provided by the packages through the entry-point <code>cgse.settings</code>. The default Settings file is named <code>settings.yaml</code> but this can be changed by the entry-point (see below).</p> <p>Let's take a look at how the settings are provided for the <code>cgse-core</code> package. First, the <code>pyproject.toml</code> file of the project shall define the entry-point. In the snippet below, the entry-point <code>cgse-core</code> is defined for the group <code>cgse.settings</code>.</p> <pre><code>[project.entry-points.\"cgse.settings\"]\ncgse-core = \"cgse_core:settings.yaml\"\n</code></pre> <p>The entry-point itself has the following format: <code>&lt;name&gt; = \"&lt;module&gt;.&lt;filename&gt;\"</code>, where</p> <ul> <li><code>&lt;name&gt;</code> is the name of the entry-point given in the <code>pyproject.toml</code> file, usually this is the package name,</li> <li><code>&lt;module&gt;</code> is a valid module name that can be imported and from which the location can be determined, and</li> <li><code>&lt;filename&gt;</code> is the name of the target file, e.g. a YAML file.</li> </ul> <p>Note</p> <p>The module name for this entry point has an underscore instead of a dash, i.e. <code>cgse_core</code> instead of  <code>cgse-core</code>. The reason is that module names with a dash will generate a SyntaxError during import.</p> <p>The above example will load the settings for this package from the <code>settings.yaml</code> file that is located in the <code>cgse_core</code> module. That is, the package shall also provide this as follows:</p> <pre><code>cgse-core\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 cgse_core\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 settings.yaml\n</code></pre> <p>The <code>settigs.yaml</code> file for this module looks something like this:</p> <pre><code>PACKAGES:\n    CGSE_CORE: The core services of the CGSE\n\nLogging Control Server:                          # LOG_CS\n\n    PROTOCOL:                       tcp\n    HOSTNAME:                 localhost          # The hostname that client shall connect to, e.g. pleiad01 @ KU Leuven\n    LOGGING_PORT:                  7000\n    COMMANDING_PORT:               7001\n    METRICS_PORT:                  7003          # The HTTP port where Prometheus will connect to for retrieving metrics\n    MAX_NR_LOG_FILES:                20          # The maximum number of log files that will be maintained in a roll-over\n    MAX_SIZE_LOG_FILES:              20          # The maximum size one log file can become\n    TEXTUALOG_IP_ADDRESS:     127.0.0.1          # The IP address of the textualog listening server\n    TEXTUALOG_LISTENING_PORT:     19996          # The port number on which the textualog server is listening\n\nConfiguration Manager Control Server:            # CM_CS\n\n    ...\n</code></pre>"},{"location":"libs/cgse-common/settings/#local-settings","title":"Local Settings","text":"<p>You can, and you should, define local settings for your project and put those settings in a known folder on your system. The usual place is <code>~/cgse/local-settings.yaml</code>. This file will be automatically loaded by the <code>Settings.load()</code> function when you define the local settings environment variable. That variable name is <code>&lt;PROJECT&gt;_LOCAL_SETTINGS</code> where <code>&lt;PROJECT&gt;</code> is the name of your project as defined by the <code>PROJECT</code> environment variable. For a <code>PROJECT=LAB23</code> the local settings would be defined as follows:</p> <pre><code>$ export LAB23_LOCAL_SETTINGS=~/cgse/local-settings-lab23.yaml\n</code></pre> <p>The local settings take higher precedence that will overwrite the global settings when loaded. You only need to define the settings that actually change for your local installation, respect the full hierarchy when specifying those settings. You are allowed to define new entries at any level in the Settings hierarchy.</p> <p>The usual parameters to put into a local settings file are:</p> <ul> <li>the SITE ID</li> <li>the hostnames of the different devices that you use</li> <li>the hostname of the server where core services or device control servers are running</li> <li>port numbers that have been changed from the default</li> </ul>"},{"location":"libs/cgse-common/settings/#terminal-command","title":"Terminal Command","text":"<p>You can check the current settings from the terminal with the following command:</p> <pre><code>$ py -m egse.settings\nSettings\n\u251c\u2500\u2500 PACKAGES\n\u2502   \u251c\u2500\u2500 CGSE_COMMON: Common classes, functions, decorators, etc. for the CGSE\n\u2502   \u2514\u2500\u2500 CGSE_CORE: The core services of the CGSE\n\u251c\u2500\u2500 SITE\n\u2502   \u251c\u2500\u2500 ID: LAB42\n\u2502   \u251c\u2500\u2500 SSH_SERVER: localhost\n\u2502   \u2514\u2500\u2500 SSH_PORT: 22\n\u251c\u2500\u2500 PROCESS\n\u2502   \u2514\u2500\u2500 METRICS_INTERVAL: 10\n\u251c\u2500\u2500 Logging Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 LOGGING_PORT: 7000\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 7001\n... ...\n\u2514\u2500\u2500 Storage Control Server\n    \u251c\u2500\u2500 PROTOCOL: tcp\n    \u251c\u2500\u2500 HOSTNAME: localhost\n    \u251c\u2500\u2500 COMMANDING_PORT: 6100\n    \u251c\u2500\u2500 MONITORING_PORT: 6101\n    \u251c\u2500\u2500 SERVICE_PORT: 6102\n    \u251c\u2500\u2500 METRICS_PORT: 6103\n    \u2514\u2500\u2500 DELAY: 1\nMemoized locations:\n['/Users/rik/github/cgse/libs/cgse-common/src/cgse_common/settings.yaml', '/Users/rik/github/cgse/libs/cgse-core/src/cgse_core/settings.yaml', '/Users/rik/cgse/local_settings_ariel.yaml']\n</code></pre> <p>The memoized locations are the settings files that have been loaded and cached. Once the application has started and the settings have been loaded, they can only be reloaded by explicitly forcing a reload as follows:</p> <pre><code>&gt;&gt;&gt; settings = Settings.load(force=True)\n</code></pre> <p>Warning</p> <p>The <code>force</code> reload does however not guarantee that the settings will propagate properly throughout the application or to client apps. Settings can be saved in local variables or class instances that have no knowledge of a Settings reload. So, be careful when changing your Settings. If there are parameters that change often and are not as  static as thought, maybe they belong in the Setup instead of the Settings. Examples are:</p> <ul> <li>calibration parameters</li> <li>SUT parameters</li> <li>conversion functions</li> <li>coordinates and reference frames</li> <li>models</li> </ul>"},{"location":"libs/cgse-common/settings/#the-design-of-the-load-method","title":"The design of the <code>load()</code> method","text":"<p>A word about the <code>Settings.load()</code> method. Depending on the parameters provided, this method either loads all  settings, a group of settings or just one single YAML file. We have already explained how to load a specific group  of settings by giving the name of the group as a parameter. When you want to load just one YAML file, you need to  specify its location also. When a location is given as a str or a Path, the Settings will be loaded from that file  only, using the default <code>settings.yaml</code> name or another name given through the <code>filename</code> argument.</p> <p>This can be used to e.g. load command files for a device:</p> <pre><code>&gt;&gt;&gt; commands = Settings.load(location=\"~\", filename=\"DAQ5610.yaml\")\n</code></pre> <p>The mechanism behind the <code>Settings.load()</code> method is shown in the following diagram. For simplicity, parameters are  not shown and only the success path is presented, not any exceptions or error handling.</p> <p></p>"},{"location":"libs/cgse-common/setup/","title":"The Setup","text":""},{"location":"libs/cgse-coordinates/","title":"Reference Coordinates","text":""},{"location":"libs/cgse-core/","title":"Core Services","text":""},{"location":"libs/cgse-gui/","title":"GUI Components","text":""},{"location":"projects/","title":"Projects","text":"<p>The projects are those packages that add functionality to the CGSE framework.</p> <p>The projects live under the folder <code>projects</code>, and they are organised in generic and specific projects. Generic  projects do not have an implementation that is specific for one particular project, while, obviously, specific  projects have. We currently have the following generic packages:</p> <ul> <li><code>cgse-tools</code></li> <li><code>symetrie-hexapod</code></li> </ul> <p>and then there are the project specific packages:</p> <ul> <li><code>plato-fits</code></li> <li><code>plato-hdf5</code></li> <li><code>plato-spw</code></li> </ul>"},{"location":"projects/cgse-tools/","title":"Tools for the CGSE framework","text":""},{"location":"projects/symetrie-hexapod/","title":"The Sym\u00e9trie Hexapods","text":""},{"location":"user_guide/","title":"User Guide","text":"<p>Welcome to the CGSE user guide! An in-depth reference on how to use the CGSE.</p>"}]}