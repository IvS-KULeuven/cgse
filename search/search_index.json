{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Tip</p> <p>See the navigation links in the header or side-bar.</p> <p>Click  (top left) on mobile.</p>"},{"location":"#welcome","title":"Welcome","text":"<p>Welcome to the CGSE framework documentation.</p> <p>Get started or go straight to the Tutorial</p>"},{"location":"#what-is-the-cgse","title":"What is the CGSE?","text":"<p>The CGSE is short for Common-EGSE, a framework for managing and running test equipment in a lab. The EGSE stands for  Electrical Ground Support Equipment, and this includes all equipment that is used to test or calibration an instrument.</p> <ul> <li>computers: a server running the CGSE and archiving test data and a client to control the test equipment</li> <li>temperature controllers: control heaters and monitor temperature sensors</li> <li>mechanisms: control mechanisms like hexapods or linear stages </li> <li>optics: control optical equipment like lasers and attenuators</li> <li>any other device that can be connected through an Ethernet or USB connection and with a open API.</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":"<p>All you need to get started using and building the CGSE.</p>"},{"location":"getting_started/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9.x (we do not yet support higher versions, but are working to extend the list)</li> <li>macOS or Linux</li> </ul>"},{"location":"help/","title":"Help","text":"<p>The best way to get help for something that you couldn't find in the documentation on this site, is to contact one of  the authors.</p>"},{"location":"help/#bugs-and-feature-requests","title":"Bugs and Feature requests","text":"<p>Report any bugs or issues through GitHub on the CGSE issues page.  </p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Welcome to the CGSE Tutorial!</p> <p>By the end of this page you should have a solid understanding of the core features of the CGSE.</p>"},{"location":"dev_guide/","title":"Developer Guide","text":"<p>Welcome to the CGSE developer guide! An in-depth reference on how to contribute to the CGSE.</p> <p>First thing to know is that this repository is actually a monorepo, meaning it contains a bunch of related but  self-standing packages with a minimum of interdependencies. These packages are  </p>"},{"location":"dev_guide/coding_style/","title":"Style Guide","text":"<p>This part of the developer guide contains instructions for coding styles that are adopted for this project.</p> <p>The style guide that we use for this project is PEP8. This is the standard for Python code and all IDEs, parsers and code formatters understand and work with this standard. PEP8 leaves room for project specific styles. A good style guide that we can follow is the Google Style Guide.</p> <p>The following sections will give the most used conventions with a few examples of good and bad.</p>"},{"location":"dev_guide/coding_style/#tldr","title":"TL;DR","text":"Type Style Example Classes CapWords ProcessManager, ImageViewer, CommandList, Observation, MetaData Methods &amp; Functions lowercase with underscores get_value, set_mask, create_image Variables lowercase with underscores key, last_value, model, index, user_info Constants UPPERCASE with underscores MAX_LINES, BLACK, COMMANDING_PORT Modules &amp; packages lowercase no underscores dataset, commanding, multiprocessing"},{"location":"dev_guide/coding_style/#general","title":"General","text":"<ul> <li>Name the class or variable or function with what it is, what it does or what it contains. A variable named <code>user_list</code> might look good at first, but what if at some point you want to change the list to a set so it can not contain duplicates. Are you going to rename everything into <code>user_set</code> or would <code>user_info</code> be a better name?</li> <li>Never use dashes in any name, they will raise a <code>SyntaxError: invalid syntax</code>.</li> <li>We introduce a number of relaxations to not break backward compatibility for the sake of a naming convention. As described in A Foolish Consistency is the Hobgoblin of Little Minds: Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important. [...] do not break backwards compatibility just to comply with this PEP!</li> </ul>"},{"location":"dev_guide/coding_style/#classes","title":"Classes","text":"<p>Always use CamelCase (Python uses CapWords) for class names. When using acronyms, keep them all UPPER case.</p> <ul> <li>Class names should be nouns, like Observation</li> <li>Make sure to name classes distinctively</li> <li>Stick to one word for a concept when naming classes, i.e. words like <code>Manager</code> or <code>Controller</code> or <code>Organizer</code> all mean similar things. Choose one word for the concept and stick to it.</li> <li>If a word is already part of a package or module, don't use the same word in the class name again.</li> </ul> <p>Good names are: <code>Observation</code>, <code>CalibrationFile</code>, <code>MetaData</code>, <code>Message</code>, <code>ReferenceFrame</code>, <code>URLParser</code>.</p>"},{"location":"dev_guide/coding_style/#methods-and-functions","title":"Methods and Functions","text":"<p>A function or a method does something (and should only do one thing, SRP=Single Responsibility Principle), it is an action, so the name should reflect that action.</p> <p>Always use lowercase words separated with underscores.</p> <p>Good names are: <code>get_time_in_ms()</code>, <code>get_commanding_port()</code>, <code>is_connected()</code>, <code>parse_time()</code>, <code>setup_mask()</code>.</p> <p>When working with legacy code or code from another project, names may be in camelCase (with the first letter a lower case letter). So we can in this case use also <code>getCommandPort()</code> or <code>isConnected()</code> as method and function names.</p>"},{"location":"dev_guide/coding_style/#variables","title":"Variables","text":"<p>Use the same naming convention as functions and methods, i.e. lowercase with underscores.</p> <p>Good names are: <code>key</code>, <code>value</code>, <code>user_info</code>, <code>model</code>, <code>last_value</code></p> <p>Bad names: <code>NSegments</code>, <code>outNoise</code></p> <p>Take care not to use builtins: <code>list</code>, <code>type</code>, <code>filter</code>, <code>lambda</code>, <code>map</code>, <code>dict</code>, ...</p> <p>Private variables (for classes) start with an underscore: <code>_name</code> or <code>_total_n_args</code>.</p> <p>In the same spirit as method and function names, the variables can also be in camelCase for specific cases.</p>"},{"location":"dev_guide/coding_style/#constants","title":"CONSTANTS","text":"<p>Use ALL_UPPER_CASE with underscores for constants. Use constants always within a name space, not globally.</p> <p>Good names: <code>MAX_LINES</code>, <code>BLACK</code>, <code>YELLOW</code>, <code>ESL_LINK_MODE_DISABLED</code></p>"},{"location":"dev_guide/coding_style/#modules-and-packages","title":"Modules and Packages","text":"<p>Use simple words for modules, preferably just one word like <code>datasets</code> or <code>commanding</code> or <code>storage</code> or <code>extensions</code>. If two words are unavoidable, just concatenate them, like <code>multiprocessing</code> or <code>sampledata</code> or <code>testdata</code>. If needed for readability, use an underscore to separate the words, e.g. <code>image_analysis</code>.</p>"},{"location":"dev_guide/coding_style/#import-statements","title":"Import Statements","text":"<ul> <li>Group and sort import statements</li> <li>Never use the form <code>from &lt;module&gt; import *</code></li> <li>Always use absolute imports in scripts</li> </ul> <p>Be careful that you do not name any modules the same as a module in the Python standard library. This can result in strange effects and may result in an <code>AttributeError</code>. Suppose you have named a module <code>math</code> in the <code>egse</code> directory and it is imported and used further in the code as follows:</p> <pre><code>from egse import math\n\n# in some expression further down the code you might use\n\nmath.exp(a)\n</code></pre> <p>This will result in the following runtime error:</p> <pre><code>File \"some_module.py\", line 8, in &lt;module&gt;\n  print(math.exp(a))\nAttributeError: module 'egse.math' has no attribute 'exp'\n</code></pre> <p>Of course this is an obvious example, but it might be more obscure like e.g. in this GitHub issue: 'module'  object has no attribute 'Cmd'.</p>"},{"location":"dev_guide/docs/","title":"Building the documentation","text":"<ul> <li>Make sure you are in a virtual environment with Python 3.10+</li> <li>Run the <code>mkdocs serve</code> from the project root older</li> <li>Create new pages by adding folder and Markdown files inside <code>docs/*</code></li> </ul>"},{"location":"dev_guide/docs/#set-up-your-environment","title":"Set up your environment","text":"<p>I created a virtual environment using <code>pyenv</code> and when I'm working on the documentation, I start up a shell with  this environment. Currently, only <code>mkdocs</code> and <code>mkdocs-material</code> are needed. Of course, you need to install these  only once.</p> <pre><code>$ pyenv virtualenv 3.10 cgse-doc-3.10\n$ pyenv shell cgse-doc-3.10\n$ pip install --upgrade pip setuptools wheel\n$ pip install mkdocs\n$ pip install mkdocs-material\n</code></pre> <p>From this shell, navigate to the project root folder and start the live-reload server of <code>mkdocs</code>.</p> <pre><code>$ cd ~/github/cgse\n$ mkdocs serve\n</code></pre> <p>Now you can update files, create new folders in <code>docs/*</code>, create new Markdown files and all changes will be reloaded  live in the browser.</p> <p>When you are ready with updating, you will need to build the site and publish it on GitHub pages:</p> <pre><code>$ mkdocs build\n$ mkdocs gh-deploy -r upstream -m \"documentation update on ..\"\n</code></pre>"},{"location":"dev_guide/docs/#commands","title":"Commands","text":"<ul> <li><code>mkdocs serve</code> \u2014 start the live-reloading docs server</li> <li><code>mkdocs build</code> \u2014 build the documentation site</li> <li><code>mkdocs deploy</code> \u2014 publish your documentation on GitHub pages</li> <li><code>mkdocs -h</code> \u2014 print a help message for more options</li> </ul>"},{"location":"dev_guide/docs/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml     # the mkdocs configuration file\ndocs/\n    index.md   # the documentation homepage\n    ...        # other markdown pages, image, folders, ...\n</code></pre>"},{"location":"dev_guide/installation/","title":"Installation Guide for Developers","text":""},{"location":"dev_guide/uv/","title":"Working with <code>uv</code>","text":"<p><code>uv</code> is an extremely fast Python package and project manager, written in Rust. We will use <code>uv</code> as the single tool that replaces <code>pip</code>, <code>virtualenv</code>, <code>pyenv</code>, and more. The main tasks for which we will use <code>uv</code> are:</p> <ul> <li>run and install Python versions</li> <li>installing and managing a virtual environment</li> <li>build all the packages in the workspace or monorepo</li> <li>publish all the packages to PyPI</li> <li>run scripts and apps</li> </ul>"},{"location":"dev_guide/uv/#installing-uv","title":"Installing <code>uv</code>","text":"<p>On macOS and Linux you can install <code>uv</code> using <code>curl</code>:</p> <pre><code>$ curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>If you need more specific information on installing and upgrading <code>uv</code>, please refer to the official documentation.</p>"},{"location":"dev_guide/uv/#installing-a-python-version","title":"Installing a Python version","text":"<p>The CGSE is guaranteed to work with Python 3.9.x. We will gradually include higher versions of Python, but currently  these have not been tested. So, we will for the moment stick with Python 3.9.20. Install this version as follows:</p> <pre><code>$ uv python install 3.9.20\n</code></pre> <p><code>pyenv</code></p> <p>When using <code>pyenv</code> to manage your Python versions, make sure you also have the same Python version installed  with <code>pyenv</code> and <code>uv</code>. Otherwise you will run into the following error. This is a known issue with <code>uv</code>.</p> <pre><code>pyenv: version `3.9.20' is not installed (set by /Users/rik/github/cgse/libs/cgse-common/.python-version)\n</code></pre> <p>You can check which Python versions are installed already on your system:</p> CommandOutput <pre><code>$ uv python list --only-installed\n</code></pre> <pre><code>cpython-3.12.8-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.12.8-macos-aarch64-none/bin/python3.12\ncpython-3.10.16-macos-aarch64-none    /Users/rik/Library/Application Support/uv/python/cpython-3.10.16-macos-aarch64-none/bin/python3.10\ncpython-3.9.21-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.9.21-macos-aarch64-none/bin/python3.9\ncpython-3.9.20-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.9.20-macos-aarch64-none/bin/python3.9\ncpython-3.9.6-macos-aarch64-none      /Library/Developer/CommandLineTools/usr/bin/python3 -&gt; ../../Library/Frameworks/Python3.framework/Versions/3.9/bin/python3\ncpython-3.8.17-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.8.17-macos-aarch64-none/bin/python3.8\n</code></pre>"},{"location":"dev_guide/uv/#create-a-virtual-environment","title":"Create a virtual environment","text":"<p>Pin a Python version</p> <p>You can pin a python version with the command:</p> <pre><code>$ uv python pin 3.9.20\n</code></pre> <p><code>uv</code> will search for a pinned version in the parent folders up to the root folder or your home directory.</p> <p>You can create a virtual environment with <code>uv</code> for the specific Python version as follows. The '<code>--python</code>' is optional  and <code>uv</code> will use the default (pinned) Python version when creating a <code>venv</code> without this option. When creating a  virtual environment make sure you are in the package root, e.g. <code>~/github/cgse/libs/cgse-common</code>.</p> <pre><code>$ cd ~/github/cgse/libs/cgse-common\n$ uv venv --python 3.9.20\n</code></pre> <p>Assuming you are in the package root where you created the virtual environment, you can now install its dependencies  with <code>pip install</code> as follows:</p> <pre><code>$ uv pip install -r pyproject.toml\n</code></pre> <p>To install the current project as an editable package:</p> <pre><code>$ uv pip install -e .\n</code></pre> <p>Note</p> <p>If you don't want to use the <code>uv</code> commands, you can activate the virtual environment and use the original <code>pip</code>  and <code>python</code> commands as you are used to.</p> <pre><code>$ source .venv/bin/activate\n</code></pre> <p>Info</p> <p>In a workspace, maintaining a virtual environment per package might be a hassle and most of the time that is not  needed. A good approach is to always use the virtual environment at the workspace root. This <code>venv</code> which will be  automatically created if you run a command or if you use <code>uv sync</code> in the package folder. With <code>uv sync</code> you can  make sure the virtual environment is up-to-date and contains only those dependencies that are required for the  package you are in. So, each time you switch to another package and want to run a comand or a test for that  package, use </p> <pre><code>$ uv sync\n</code></pre>"},{"location":"dev_guide/uv/#building-and-publishing-all-packages","title":"Building and publishing all packages","text":"<p>We have chosen for one and the same version number for all packages in the <code>cgse</code> monorepo. That means that whenever  we make a change to one of the packages and want to release that change, all packages shall be rebuild and published.</p> <p>Inline</p> <p>When working in a workspace, keep in mind that the commands <code>uv run</code> and <code>uv sync</code> by default work on the  workspace root. That means that when you run the <code>uv run pip install &lt;package&gt;</code> command, the <code>.venv</code> at the  workspace root will be updated or created if it didn't exist. Similar for the <code>uv sync</code> command, there is only  one <code>uv.lock</code> file at the root of the workspace.  </p> <p>Fortunately, with <code>uv</code>, that is done in a few commands.</p> <p>When you are in the monorepo root folder, you can build all packages at once. They will be placed in the <code>dist</code> folder  of the root package. Before building, make sure you update the version in the <code>pyproject.toml</code> of the root package  and then bump the versions. Before building, clean up the <code>dist</code> folder, then you can do a default <code>uv publish</code> afterwards.</p> <pre><code>$ cd &lt;monorepo root&gt;\n$ uv run bump.py\n$ rm -r dist\n$ uv build --all-packages\n</code></pre> <p>Publish all packages in the root dist folder to PyPI. The UV_PUBLISH_TOKEN can be defined in a (read protected) ~/. setenv.bash file:</p> <pre><code>$ uv publish --token $UV_PUBLISH_TOKEN\n</code></pre> <p>The above command will publish all package to PyPI. If you don't want the token to be in a shell variable, you can  omit the <code>--token</code> in the command above. You will then be asked for a username, use <code>__token__</code> as the username and  then provide the token as a password.</p>"},{"location":"libs/","title":"Libraries","text":"<p>The libraries are those packages that make up the CGSE framework.</p> <p>The libraries are located under the <code>libs</code> folder, and we currently find the following packages there:</p> <ul> <li><code>cgse-common</code></li> <li><code>cgse-core</code></li> <li><code>cgse-coordinates</code></li> <li><code>cgse-gui</code></li> </ul>"},{"location":"libs/cgse-common/","title":"Common Code","text":"<p>This package <code>cgse-common</code> contain modules that are used by all other packages. </p>"},{"location":"libs/cgse-common/#binary-egsebits","title":"Binary: <code>egse.bits</code>","text":"<p>TBW</p>"},{"location":"libs/cgse-common/#environment-egseenv","title":"Environment: <code>egse.env</code>","text":"<p>TBW</p>"},{"location":"libs/cgse-common/#system-egsesystem","title":"System: <code>egse.system</code>","text":"<p>TBW</p>"},{"location":"libs/cgse-common/#_1","title":"Common Code","text":""},{"location":"libs/cgse-common/settings/","title":"The Settings","text":"<p>The Settings class contains all static information needed to configure your system, the environment you are using and the test equipment. The Settings also contain all the IP addresses and port number for all the known devices, together with other static information like the device name, default settings for the device like speed, timeout, delay time, firmware version, etc. We will go into more details about the content later, let\u2019s now first look at the format and usage of the Settings.</p>"},{"location":"libs/cgse-common/settings/#loading-the-settings","title":"Loading the Settings","text":"<p>The Settings can be loaded as follows:</p> <pre><code>&gt;&gt;&gt; from egse.settings import Settings\n&gt;&gt;&gt; settings = Settings.load()\n</code></pre> <p>The <code>settings</code> object will be a dictionary where the keys are the top-level groups that are defined in the settings for each package. For a system that has only <code>cgse-common</code> and <code>cgse-core</code> installed, the <code>settings</code> will contain something like this:</p> <pre><code>&gt;&gt;&gt; print(settings)\nSettings\n\u251c\u2500\u2500 PACKAGES\n\u2502   \u251c\u2500\u2500 CGSE_COMMON: Common classes, functions, decorators, etc. for the CGSE\n\u2502   \u2514\u2500\u2500 CGSE_CORE: The core services of the CGSE\n\u251c\u2500\u2500 SITE\n\u2502   \u251c\u2500\u2500 ID: LAB42\n\u2502   \u251c\u2500\u2500 SSH_SERVER: localhost\n\u2502   \u2514\u2500\u2500 SSH_PORT: 22\n\u251c\u2500\u2500 PROCESS\n\u2502   \u2514\u2500\u2500 METRICS_INTERVAL: 10\n\u251c\u2500\u2500 Logging Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 LOGGING_PORT: 7000\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 7001\n\u2502   \u251c\u2500\u2500 METRICS_PORT: 7003\n\u2502   \u251c\u2500\u2500 MAX_NR_LOG_FILES: 20\n\u2502   \u251c\u2500\u2500 MAX_SIZE_LOG_FILES: 20\n\u2502   \u251c\u2500\u2500 TEXTUALOG_IP_ADDRESS: 127.0.0.1\n\u2502   \u2514\u2500\u2500 TEXTUALOG_LISTENING_PORT: 19996\n\u251c\u2500\u2500 Configuration Manager Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 6000\n\u2502   \u251c\u2500\u2500 MONITORING_PORT: 6001\n\u2502   \u251c\u2500\u2500 SERVICE_PORT: 6002\n\u2502   \u251c\u2500\u2500 METRICS_PORT: 6003\n\u2502   \u251c\u2500\u2500 DELAY: 1\n\u2502   \u2514\u2500\u2500 STORAGE_MNEMONIC: CM\n\u2514\u2500\u2500 Storage Control Server\n    \u251c\u2500\u2500 PROTOCOL: tcp\n    \u251c\u2500\u2500 HOSTNAME: localhost\n    \u251c\u2500\u2500 COMMANDING_PORT: 6100\n    \u251c\u2500\u2500 MONITORING_PORT: 6101\n    \u251c\u2500\u2500 SERVICE_PORT: 6102\n    \u251c\u2500\u2500 METRICS_PORT: 6103\n    \u2514\u2500\u2500 DELAY: 1\n</code></pre> <p>If you only need the settings for a particular component, specify that group's name:</p> <pre><code>&gt;&gt;&gt; storage_settings = Settings.load(\"Storage Control Server\")\n\n&gt;&gt;&gt; print(storage_settings)\nStorage\nControl\nServer\n\u251c\u2500\u2500 PROTOCOL: tcp\n\u251c\u2500\u2500 HOSTNAME: localhost\n\u251c\u2500\u2500 COMMANDING_PORT: 6100\n\u251c\u2500\u2500 MONITORING_PORT: 6101\n\u251c\u2500\u2500 SERVICE_PORT: 6102\n\u251c\u2500\u2500 METRICS_PORT: 6103\n\u2514\u2500\u2500 DELAY: 1\n</code></pre> <p>The values can be accessed as usual with a dictionary, by specifying the name of the parameter as the key:</p> <pre><code>&gt;&gt;&gt; print(storage_settings[\"COMMANDING_PORT\"])\n6100\n</code></pre> <p>We usually only go one level deep when defining settings, and as a convenience, that first level of variables can also be accessed with the dot-notation.</p> <pre><code>&gt;&gt;&gt; print(storage_settings.COMMANDING_PORT)\n6100\n</code></pre>"},{"location":"libs/cgse-common/settings/#entry-points","title":"Entry-points","text":"<p>The Settings are collected from a set of YAML files which are provided by the packages through the entry-point <code>cgse.settings</code>. The default Settings file is named <code>settings.yaml</code> but this can be changed by the entry-point (see below).</p> <p>Let's take a look at how the settings are provided for the <code>cgse-core</code> package. First, the <code>pyproject.toml</code> file of the project shall define the entry-point. In the snippet below, the entry-point <code>cgse-core</code> is defined for the group <code>cgse.settings</code>.</p> <pre><code>[project.entry-points.\"cgse.settings\"]\ncgse-core = \"cgse_core:settings.yaml\"\n</code></pre> <p>The entry-point itself has the following format: <code>&lt;name&gt; = \"&lt;module&gt;.&lt;filename&gt;\"</code>, where</p> <ul> <li><code>&lt;name&gt;</code> is the name of the entry-point given in the <code>pyproject.toml</code> file, usually this is the package name,</li> <li><code>&lt;module&gt;</code> is a valid module name that can be imported and from which the location can be determined, and</li> <li><code>&lt;filename&gt;</code> is the name of the target file, e.g. a YAML file.</li> </ul> <p>Note</p> <p>The module name for this entry point has an underscore instead of a dash, i.e. <code>cgse_core</code> instead of  <code>cgse-core</code>. The reason is that module names with a dash will generate a SyntaxError during import.</p> <p>The above example will load the settings for this package from the <code>settings.yaml</code> file that is located in the <code>cgse_core</code> module. That is, the package shall also provide this as follows:</p> <pre><code>cgse-core\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 cgse_core\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 settings.yaml\n</code></pre> <p>The <code>settigs.yaml</code> file for this module looks something like this:</p> <pre><code>PACKAGES:\n    CGSE_CORE: The core services of the CGSE\n\nLogging Control Server:                          # LOG_CS\n\n    PROTOCOL:                       tcp\n    HOSTNAME:                 localhost          # The hostname that client shall connect to, e.g. pleiad01 @ KU Leuven\n    LOGGING_PORT:                  7000\n    COMMANDING_PORT:               7001\n    METRICS_PORT:                  7003          # The HTTP port where Prometheus will connect to for retrieving metrics\n    MAX_NR_LOG_FILES:                20          # The maximum number of log files that will be maintained in a roll-over\n    MAX_SIZE_LOG_FILES:              20          # The maximum size one log file can become\n    TEXTUALOG_IP_ADDRESS:     127.0.0.1          # The IP address of the textualog listening server\n    TEXTUALOG_LISTENING_PORT:     19996          # The port number on which the textualog server is listening\n\nConfiguration Manager Control Server:            # CM_CS\n\n    ...\n</code></pre>"},{"location":"libs/cgse-common/settings/#local-settings","title":"Local Settings","text":"<p>You can, and you should, define local settings for your project and put those settings in a known folder on your system. The usual place is <code>~/cgse/local-settings.yaml</code>. This file will be automatically loaded by the <code>Settings.load()</code> function when you define the local settings environment variable. That variable name is <code>&lt;PROJECT&gt;_LOCAL_SETTINGS</code> where <code>&lt;PROJECT&gt;</code> is the name of your project as defined by the <code>PROJECT</code> environment variable. For a <code>PROJECT=LAB23</code> the local settings would be defined as follows:</p> <pre><code>$ export LAB23_LOCAL_SETTINGS=~/cgse/local-settings-lab23.yaml\n</code></pre> <p>The local settings take higher precedence that will overwrite the global settings when loaded. You only need to define the settings that actually change for your local installation, respect the full hierarchy when specifying those settings. You are allowed to define new entries at any level in the Settings hierarchy.</p> <p>The usual parameters to put into a local settings file are:</p> <ul> <li>the SITE ID</li> <li>the hostnames of the different devices that you use</li> <li>the hostname of the server where core services or device control servers are running</li> <li>port numbers that have been changed from the default</li> </ul>"},{"location":"libs/cgse-common/settings/#terminal-command","title":"Terminal Command","text":"<p>You can check the current settings from the terminal with the following command:</p> <pre><code>$ py -m egse.settings\nSettings\n\u251c\u2500\u2500 PACKAGES\n\u2502   \u251c\u2500\u2500 CGSE_COMMON: Common classes, functions, decorators, etc. for the CGSE\n\u2502   \u2514\u2500\u2500 CGSE_CORE: The core services of the CGSE\n\u251c\u2500\u2500 SITE\n\u2502   \u251c\u2500\u2500 ID: LAB42\n\u2502   \u251c\u2500\u2500 SSH_SERVER: localhost\n\u2502   \u2514\u2500\u2500 SSH_PORT: 22\n\u251c\u2500\u2500 PROCESS\n\u2502   \u2514\u2500\u2500 METRICS_INTERVAL: 10\n\u251c\u2500\u2500 Logging Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 LOGGING_PORT: 7000\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 7001\n... ...\n\u2514\u2500\u2500 Storage Control Server\n    \u251c\u2500\u2500 PROTOCOL: tcp\n    \u251c\u2500\u2500 HOSTNAME: localhost\n    \u251c\u2500\u2500 COMMANDING_PORT: 6100\n    \u251c\u2500\u2500 MONITORING_PORT: 6101\n    \u251c\u2500\u2500 SERVICE_PORT: 6102\n    \u251c\u2500\u2500 METRICS_PORT: 6103\n    \u2514\u2500\u2500 DELAY: 1\nMemoized locations:\n['/Users/rik/github/cgse/libs/cgse-common/src/cgse_common/settings.yaml', '/Users/rik/github/cgse/libs/cgse-core/src/cgse_core/settings.yaml', '/Users/rik/cgse/local_settings_ariel.yaml']\n</code></pre> <p>The memoized locations are the settings files that have been loaded and cached. Once the application has started and the settings have been loaded, they can only be reloaded by explicitly forcing a reload as follows:</p> <pre><code>&gt;&gt;&gt; settings = Settings.load(force=True)\n</code></pre> <p>Warning</p> <p>The <code>force</code> reload does however not guarantee that the settings will propagate properly throughout the application or to client apps. Settings can be saved in local variables or class instances that have no knowledge of a Settings reload. So, be careful when changing your Settings. If there are parameters that change often and are not as  static as thought, maybe they belong in the Setup instead of the Settings. Examples are:</p> <ul> <li>calibration parameters</li> <li>SUT parameters</li> <li>conversion functions</li> <li>coordinates and reference frames</li> <li>models</li> </ul>"},{"location":"libs/cgse-common/settings/#the-design-of-the-load-method","title":"The design of the <code>load()</code> method","text":"<p>A word about the <code>Settings.load()</code> method. Depending on the parameters provided, this method either loads all  settings, a group of settings or just one single YAML file. We have already explained how to load a specific group  of settings by giving the name of the group as a parameter. When you want to load just one YAML file, you need to  specify its location also. When a location is given as a str or a Path, the Settings will be loaded from that file  only, using the default <code>settings.yaml</code> name or another name given through the <code>filename</code> argument.</p> <p>This can be used to e.g. load command files for a device:</p> <pre><code>&gt;&gt;&gt; commands = Settings.load(location=\"~\", filename=\"DAQ5610.yaml\")\n</code></pre> <p>The mechanism behind the <code>Settings.load()</code> method is shown in the following diagram. For simplicity, parameters are  not shown and only the success path is presented, not any exceptions or error handling.</p> <p></p>"},{"location":"libs/cgse-common/setup/","title":"The Setup","text":""},{"location":"libs/cgse-coordinates/","title":"Reference Coordinates","text":""},{"location":"libs/cgse-core/","title":"Core Services","text":""},{"location":"libs/cgse-gui/","title":"GUI Components","text":""},{"location":"projects/","title":"Projects","text":"<p>The projects are those packages that add functionality to the CGSE framework.</p> <p>The projects live under the folder <code>projects</code>, and they are organised in generic and specific projects. Generic  projects do not have an implementation that is specific for one particular project, while, obviously, specific  projects have. We currently have the following generic packages:</p> <ul> <li><code>cgse-tools</code></li> <li><code>symetrie-hexapod</code></li> </ul> <p>and then there are the project specific packages:</p> <ul> <li><code>plato-fits</code></li> <li><code>plato-hdf5</code></li> <li><code>plato-spw</code></li> </ul>"},{"location":"projects/cgse-tools/","title":"Tools for the CGSE framework","text":""},{"location":"projects/symetrie-hexapod/","title":"The Sym\u00e9trie Hexapods","text":""},{"location":"user_guide/","title":"User Guide","text":"<p>Welcome to the CGSE user guide! An in-depth reference on how to use the CGSE.</p>"}]}