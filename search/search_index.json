{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Tip</p> <p>See the navigation links in the header or side-bar.</p> <p>Click  (top left) on mobile.</p>"},{"location":"#welcome","title":"Welcome","text":"<p>Welcome to the CGSE framework documentation.</p> <p>Get started or go straight to the Tutorial</p>"},{"location":"#what-is-the-cgse","title":"What is the CGSE?","text":"<p>The CGSE is short for Common-EGSE, a framework for managing and running test equipment in a lab. The EGSE stands for  Electrical Ground Support Equipment, and this includes all equipment that is used to test or calibration an instrument.</p> <ul> <li>computers: a server running the CGSE and archiving test data and a client to control the test equipment</li> <li>temperature controllers: control heaters and monitor temperature sensors</li> <li>mechanisms: control mechanisms like hexapods or linear stages </li> <li>optics: control optical equipment like lasers and attenuators</li> <li>any other device that can be connected through an Ethernet or USB connection and with a open API.</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":"<p>All you need to get started using and building the CGSE.</p>"},{"location":"getting_started/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9.x (we do not yet support higher versions, but are working to extend the list)</li> <li>macOS or Linux</li> </ul>"},{"location":"getting_started/#virtual-environment","title":"Virtual environment","text":"<p>You should always work inside a virtual environment to somehow containerize your project such that it doesn't  pollute your global environment and you can run different projects next to each other. Create and activate a new  virtual environment as follows. It should be Python &gt;= 3.9</p> <pre><code>$ python -m venv venv\n$ source venv/bin/activate\n</code></pre>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>The easiest way to install the CGSE is to use the <code>pip</code> command. Since the CGSE is a monorepo and consists of  several packages, you will need to make your choice which package you need for your project. You can however start  with the <code>cgse-common</code> which contains all common code that is generic and useful as a basis for other packages.</p> <pre><code>$ pip install cgse-common\n</code></pre> <p>Check the list of packages that are part of the CGSE repo and can be installed with <code>pip</code>. The  packages are described in more detail in the sections Libs and Projects.</p>"},{"location":"getting_started/#set-up-your-environment","title":"Set up your environment","text":"<p>To check your installation and set up your environment, here are a few tips.</p> <p>The version of the core packages and any plugin packages can be verified as follows. The version you installed will  probably be higher and more lines will appear when other packages are installed.</p> <pre><code>$ py -m egse.version\nCGSE version in Settings: 0.5.0\nInstalled version for cgse-common= 0.5.0\n</code></pre> <p>Check your environment with the command below. This will probably print out some warning since you have not defined  the expected environment variables yet. There are two mandatory environment variables: <code>PROJECT</code> and <code>SITE_ID</code>. The  former shall contain the name of your project without spaces and preferably a single word or an acronym like PLATO,  ARIEL, MARVEL, MERCATOR. The latter is the name of the site or lab where the tests will be performed. Good names are  KUL, ESA, LAB23.</p> <p>The other environment variables follow the pattern <code>&lt;PROJECT&gt;_...</code>, i.e. they all start with the project name as  defined  in the PROJECT environment variable. You should define at least <code>&lt;PROJECT&gt;_DATA_STORAGE_LOCATION</code>. The configuration  data and log file location will be derived from it unless they are explicitly set themselves. </p> <p>Let's define the three expected environment variables:</p> <pre><code>$ export PROJECT=ARIEL\n$ export SITE_ID=VACUUM_LAB\n$ export ARIEL_DATA_STORAGE_LOCATION=~/data\n</code></pre> <p>Rerunning the above command now gives:</p> <pre><code>$ py -m egse.env\nEnvironment variables:\n    PROJECT = ARIEL\n    SITE_ID = VACUUM_LAB\n    ARIEL_DATA_STORAGE_LOCATION = /Users/rik/data\n    ARIEL_CONF_DATA_LOCATION = not set\n    ARIEL_CONF_REPO_LOCATION = not set\n    ARIEL_LOG_FILE_LOCATION = not set\n    ARIEL_LOCAL_SETTINGS = not set\n\nGenerated locations and filenames\n    get_data_storage_location() = '/Users/rik/data/VACUUM_LAB'  \u27f6 ERROR: The data storage location doesn't exist!\n    get_conf_data_location() = '/Users/rik/data/VACUUM_LAB/conf'  \u27f6 ERROR: The configuration data location doesn't exist!\n    get_conf_repo_location() = None  \u27f6 ERROR: The configuration repository location doesn't exist!\n    get_log_file_location() = '/Users/rik/data/VACUUM_LAB/log'  \u27f6 ERROR: The log files location doesn't exist!\n    get_local_settings() = None  \u27f6 ERROR: The local settings file is not defined or doesn't exist!\n\nuse the '--full' flag to get a more detailed report, '--doc' for help on the variables.\n</code></pre> <p>Note</p> <p>The folders that do not exist (and are not None) can be created by adding the option <code>--mkdir</code> to the above  command.</p>"},{"location":"getting_started/#check-your-settings","title":"Check your Settings","text":"<p>Settings contains the static configuration of your system, test setup, equipment, including the System Under Test  (SUT). You can test your settings with the command below. Let's first also set the <code>ARIEL_LOCALSETTINGS</code> environment  variables:</p> <p><pre><code>$ export ARIEL_LOCAL_SETTINGS=~/cgse/local_settings_ariel_vacuum_lab.yaml\n$ py -m egse.settings\nSettings\n\u251c\u2500\u2500 PACKAGES\n\u2502   \u2514\u2500\u2500 CGSE_COMMON: Common classes, functions, decorators, etc. for the CGSE\n\u251c\u2500\u2500 SITE\n\u2502   \u251c\u2500\u2500 ID: VACUUM_LAB\n\u2502   \u251c\u2500\u2500 SSH_SERVER: localhost\n\u2502   \u2514\u2500\u2500 SSH_PORT: 22\n\u2514\u2500\u2500 PROCESS\n    \u2514\u2500\u2500 METRICS_INTERVAL: 10\nMemoized locations:\n['/Users/rik/tmp/gettings-started/venv/lib/python3.9/site-packages/cgse_common/settings.yaml', \n'/Users/rik/cgse/local_settings_ariel_vacuum_lab.yaml']\n</code></pre> These Settings will grow when you add more packages to your installation or when you define settings yourself in the  local settings file.</p>"},{"location":"help/","title":"Help","text":"<p>The best way to get help for something that you couldn't find in the documentation on this site, is to contact one of  the authors.</p>"},{"location":"help/#bugs-and-feature-requests","title":"Bugs and Feature requests","text":"<p>Report any bugs or issues through GitHub on the CGSE issues page.  </p>"},{"location":"initialize/","title":"Initialize your project","text":"<p>So, we have seen how to get started with some basic commands and only the <code>cgse-common</code> package. It's time now to initialize your project properly with all the necessary services.</p>"},{"location":"initialize/#set-up-your-environment","title":"Set up your environment","text":"<p>I assume you are in the same environment that we have set up in the previous section where also the <code>cgse-common</code> package was installed. We will install another package that will provide us with the full functionality of the <code>cgse</code> command. Install the <code>cgse-tools</code> and <code>cgse-core</code> packages which depends on <code>cgse-core</code> and will also install that package.</p> <pre><code>$ pip install cgse-tools cgse-core\n</code></pre> <p>You should now have at least the follow three packages installed in your virtual environment:</p> <pre><code>$ pip list | grep cgse\ncgse-common       0.5.0\ncgse-core         0.5.0\ncgse-tools        0.5.0\n</code></pre>"},{"location":"initialize/#the-cgse-command","title":"The <code>cgse</code> command","text":"<p>The two new packages that have been installed (<code>cgse-core</code> and <code>cgse-tools</code>) provide the <code>cgse</code> command that we will use to initialize your environment, but this command is also used to inspect different parts of the system, manage core services and device drivers, etc.</p> <p>When you run the <code>cgse</code> command without any arguments, it will show something like this:</p> <pre><code>$ cgse\n\n Usage: cgse [OPTIONS] COMMAND [ARGS]...\n\n The main cgse command to inspect, configure, monitor the core services and device control servers.\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --install-completion          Install completion for the current shell.                                                                                      \u2502\n\u2502 --show-completion             Show completion for the current shell, to copy it or customize the installation.                                               \u2502\n\u2502 --help                        Show this message and exit.                                                                                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 version   Prints the version of the cgse-core and other registered packages.                                                                                 \u2502\n\u2502 init      Initialize your project.                                                                                                                           \u2502\n\u2502 top       A top-like interface for core services and device control servers.                                                                                 \u2502\n\u2502 core      handle core services: start, stop, status                                                                                                          \u2502\n\u2502 show      Show information about settings, environment, setup, ...                                                                                           \u2502\n\u2502 check     Check installation, settings, required files, etc.                                                                                                 \u2502\n\u2502 dev-x     device-x is an imaginary device that serves as an example                                                                                          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>The <code>cgse</code> command is actually an app that is the starting point for a number of commands that can be used to maintain the system, manage and inspect services and devices. For example, to check the version of the different components, use:</p> <pre><code>$ cgse version\nCGSE-COMMON installed version = 0.5.0 \u2014 Software framework to support hardware testing\nCGSE-CORE installed version = 0.5.0 \u2014 Core services for the CGSE framework\nCGSE-TOOLS installed version = 0.5.0 \u2014 Tools for CGSE\n</code></pre> <p>We will for now concentrate on the <code>init</code> command. This command will guide us through a number of steps to define the location of our device data, configuration data, etc. We will basically define some environment variables that are used by the CGSE framework. The PROJECT is he name of the project your will be working on, the SITE_ID is the identifier for the LAB or Setup that you are using to perform the tests. As you see below, the environment variables all start with the project name allowing you to work on different projects simultaneously. If you accept all the defaults, the result of the <code>cgse init</code> command will look something like this:</p> <pre><code>$ cgse init --project marvel\nPlease note default values are given between [brackets].\nWhat is the name of the project [MARVEL] ?:\nWhat is the site identifier ?: lab02\nWhere can the project data be stored [~/data/MARVEL/LAB02/] ?:\nWhere will the configuration data be located [~/data/MARVEL/LAB02/conf/] ?:\nWhere will the logging messages be stored [~/data/MARVEL/LAB02/log/] ?:\nWhere shall I create a local settings YAML file [~/data/MARVEL/LAB02/local_settings.yaml] ?:\nShall I add the environment to your ~/bash_profile ? [y/n]: n\n\n# -&gt; Add the following lines to your bash profile or equivalent\n\nexport PROJECT=MARVEL\nexport SITE_ID=LAB02\nexport MARVEL_DATA_STORAGE_LOCATION=~/data/MARVEL/LAB02/\nexport MARVEL_CONF_DATA_LOCATION=~/data/MARVEL/LAB02/conf/\nexport MARVEL_LOG_FILE_LOCATION=~/data/MARVEL/LAB02/log/\nexport MARVEL_LOCAL_SETTINGS=~/data/MARVEL/LAB02/local_settings.yaml\n</code></pre> <p>If you answered 'Y' to the last question, you should log in to the shell again with <code>exec bash -login</code> or a similar command for other shells, or you should start a new terminal to activate the environment variables.</p> <p>Add this point you are ready to go and start the core services and any device control servers that you need. You can explore other commands of the <code>cgse</code> app in the user guide.</p>"},{"location":"package_list/","title":"Packages in the CGSE","text":"<p>The CGSE is a monorepo and consists of numerous packages. Each of these packages are individually installable from  PyPI. We maintain a list here with all the packages in the monorepo.</p> Package Description <code>cgse-common</code> The common code used by all other packages <code>cgse-core</code> The core services <code>cgse-coordinates</code> Coordinate reference Frames <code>cgse-gui</code> GUI components and styles (PyQt5) <code>cgse-tools</code> Plugin that adds functions to the <code>cgse</code> command <code>symetrie-hexapod</code> Device drivers for the Sym\u00e9trie Hexapods <code>keithley-tempcontrol</code> Device driver for the Keithley temperature controller <code>plato-fits</code> FITS driver with PLATO specific format <code>plato-hdf5</code> HDF5 driver with PLATO specific format <code>plato-spw</code> SpaceWire driver with PATO specific packets <p>The following is a non-exhaustive list of known external packages that work well with the CGSE  in terms of commanding and monitoring.</p> Package Description <code>cgse-dummy</code> Provides a dummy device driver to demonstrate plugins, commands and how to develop an external package for the CGSE."},{"location":"roadmap/","title":"Roadmap","text":"<p>Don't worry, the feature set will grow..</p>"},{"location":"roadmap/#features","title":"Features","text":""},{"location":"roadmap/#the-cgse-command","title":"The <code>cgse</code> Command","text":"<p>Provide a <code>cgse</code> command that is extensible with new commands and command groups:</p> <ul> <li> a command to initialise your environment.</li> <li> a command to check versions of installed packages.</li> <li> a command to check your installation, settings, setups, environment ..</li> <li> a command group to handle core services</li> <li> a command to list running CGSE processes.</li> <li> device drivers shall be able to plug in their own command groups.</li> </ul>"},{"location":"roadmap/#settings-setup-and-the-environment","title":"Settings, Setup and the environment","text":"<ul> <li> A modular/decomposed <code>settings.yaml</code> file.</li> <li> A clear set of environment variables.</li> <li> automatic submit of new Setups to GitHub.</li> <li> a TUI for inspecting the loaded Setup.</li> </ul>"},{"location":"roadmap/#common-functionality","title":"Common functionality","text":"<ul> <li> Reference Frames and coordinate transformations -&gt; Graphs</li> <li> Metrics for all devices will be handled using InfluxDB</li> <li> Use of Grafana to visualize the metrics</li> </ul>"},{"location":"roadmap/#devices","title":"Devices","text":"<ul> <li> The Sym\u00e9trie Hexapods: PUNA, ZONDA, JORAN</li> <li> The Keithley Data Acquisition Multimeter</li> <li> The Lakeshore temperature controller</li> </ul>"},{"location":"roadmap/#projects","title":"Projects","text":"<ul> <li> Ariel HDF5 format plugin</li> <li> Ariel FITS format plugin</li> </ul>"},{"location":"roadmap/#guis-and-tuis","title":"GUIs and TUIs","text":"<ul> <li> A Process Manager TUI</li> <li> <code>tui-executor</code> integration</li> </ul>"},{"location":"roadmap/#removals","title":"Removals","text":"<ul> <li> The <code>get_common_egse_root()</code> is of no use anymore and needs to be removed or replaced in    some cases.</li> </ul>"},{"location":"roadmap/#testing","title":"Testing","text":"<ul> <li> Add proper unit tests for all packages \u2013 using <code>pytest</code></li> <li> Add a CI test suite</li> <li> Use GitHub Actions for running tests before merging</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Welcome to the CGSE Tutorial!</p> <p>By the end of this page you should have a solid understanding of the core features of the CGSE.</p>"},{"location":"dev_guide/","title":"Developer Guide","text":"<p>Welcome to the CGSE developer guide! An in-depth reference on how to contribute to the CGSE.</p> <p>First thing to know is that this repository is actually a monorepo, meaning it contains a bunch of related but self-standing packages with a minimum of interdependencies. A monorepo can grow quite big and can contain a lot of packages that even different groups are working on. What they have in common is that they use the same guidelines and have the same or a very similar development  workflow.</p> <p>Don't confuse a monorepo with a monolith or a monolithic architecture. While a monorepo holds multiple related but more-or-less independent projects, a monolith is a traditional software application or architecture which is an often huge, self-contained and independent unit of code that is highly coupled and difficult to maintain.</p> <p>Don't confuse a monorepo with microservices either. A microservice architecture contains units that run independently and are developed, scaled and deployed without affecting the other units or services. You can set up a monorepo containing all of your microservices with ease, one does not need the other, but they can perfectly go together.</p>"},{"location":"dev_guide/coding_style/","title":"Style Guide","text":"<p>This part of the developer guide contains instructions for coding styles that are adopted for this project.</p> <p>The style guide that we use for this project is PEP8. This is the standard for Python code and all IDEs, parsers and code formatters understand and work with this standard. PEP8 leaves room for project specific styles. A good style guide that we can follow is the Google Style Guide.</p> <p>The following sections will give the most used conventions with a few examples of good and bad.</p>"},{"location":"dev_guide/coding_style/#tldr","title":"TL;DR","text":"Type Style Example Classes CapWords ProcessManager, ImageViewer, CommandList, Observation, MetaData Methods &amp; Functions lowercase with underscores get_value, set_mask, create_image Variables lowercase with underscores key, last_value, model, index, user_info Constants UPPERCASE with underscores MAX_LINES, BLACK, COMMANDING_PORT Modules &amp; packages lowercase no underscores dataset, commanding, multiprocessing"},{"location":"dev_guide/coding_style/#general","title":"General","text":"<ul> <li> <p>Name the class or variable or function with what it is, what it does or what it contains. A variable named <code>user_list</code> might look good at first, but what if at some point you want to change the list to a set so it can not contain duplicates. Are you going to rename everything into <code>user_set</code> or would <code>user_info</code> be a better name?</p> </li> <li> <p>Never use dashes in any name that will be interpreted by Python, they will raise a <code>SyntaxError:    invalid syntax</code>.</p> </li> <li> <p>We introduce a number of relaxations to not break backward compatibility for the sake of a naming convention. As described in A Foolish Consistency is the Hobgoblin of Little Minds: Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important. [...] do not break backwards compatibility just to comply with this PEP!</p> </li> </ul> <p>Note</p> <p>You will sometimes see that we use one or two words between <code>&lt; &gt;</code> angle brakcets. That means  you will have to replace that text AND the brackets with your own text. As an example, if you see <code>--prompt &lt;venv name&gt;</code>, replace this with something like <code>--prompt cgse-venv</code>.  </p>"},{"location":"dev_guide/coding_style/#classes","title":"Classes","text":"<p>Always use CamelCase (Python uses CapWords) for class names. When using acronyms, keep them all UPPER case.</p> <ul> <li>Class names should be nouns, like Observation</li> <li>Make sure to name classes distinctively</li> <li>Stick to one word for a concept when naming classes, i.e. words like <code>Manager</code> or <code>Controller</code> or <code>Organizer</code> all mean similar things. Choose one word for the concept and stick to it.</li> <li>If a word is already part of a package or module, don't use the same word in the class name again.</li> </ul> <p>Good names are: <code>Observation</code>, <code>CalibrationFile</code>, <code>MetaData</code>, <code>Message</code>, <code>ReferenceFrame</code>, <code>URLParser</code>.</p>"},{"location":"dev_guide/coding_style/#methods-and-functions","title":"Methods and Functions","text":"<p>A function or a method does something (and should only do one thing, SRP=Single Responsibility Principle), it is an action, so the name should reflect that action.</p> <p>Always use lowercase words separated with underscores.</p> <p>Good names are: <code>get_time_in_ms()</code>, <code>get_commanding_port()</code>, <code>is_connected()</code>, <code>parse_time()</code>, <code>setup_mask()</code>.</p> <p>When working with legacy code or code from another project, names may be in camelCase (with the first letter a lower case letter). So we can in this case use also <code>getCommandPort()</code> or <code>isConnected()</code> as method and function names.</p>"},{"location":"dev_guide/coding_style/#variables","title":"Variables","text":"<p>Use the same naming convention as functions and methods, i.e. lowercase with underscores.</p> <p>Good names are: <code>key</code>, <code>value</code>, <code>user_info</code>, <code>model</code>, <code>last_value</code></p> <p>Bad names: <code>NSegments</code>, <code>outNoise</code></p> <p>Take care not to use builtins: <code>list</code>, <code>type</code>, <code>filter</code>, <code>lambda</code>, <code>map</code>, <code>dict</code>, ...</p> <p>Private variables (for classes) start with an underscore: <code>_name</code> or <code>_total_n_args</code>.</p> <p>In the same spirit as method and function names, the variables can also be in camelCase for specific cases.</p>"},{"location":"dev_guide/coding_style/#constants","title":"CONSTANTS","text":"<p>Use ALL_UPPER_CASE with underscores for constants. Use constants always within a name space, not globally.</p> <p>Good names: <code>MAX_LINES</code>, <code>BLACK</code>, <code>YELLOW</code>, <code>ESL_LINK_MODE_DISABLED</code></p>"},{"location":"dev_guide/coding_style/#modules-and-packages","title":"Modules and Packages","text":"<p>Use simple words for modules, preferably just one word like <code>datasets</code> or <code>commanding</code> or <code>storage</code> or <code>extensions</code>. If two words are unavoidable, just concatenate them, like <code>multiprocessing</code> or <code>sampledata</code> or <code>testdata</code>. If needed for readability, use an underscore to separate the words, e.g. <code>image_analysis</code>.</p>"},{"location":"dev_guide/coding_style/#import-statements","title":"Import Statements","text":"<ul> <li>Group and sort import statements</li> <li>Never use the form <code>from &lt;module&gt; import *</code></li> <li>Always use absolute imports in scripts</li> </ul> <p>Be careful that you do not name any modules the same as a module in the Python standard library. This can result in strange effects and may result in an <code>AttributeError</code>. Suppose you have named a module <code>math</code> in the <code>egse</code> directory and it is imported and used further in the code as follows:</p> <pre><code>from egse import math\n\n# in some expression further down the code you might use\n\nmath.exp(a)\n</code></pre> <p>This will result in the following runtime error:</p> <pre><code>File \"some_module.py\", line 8, in &lt;module&gt;\n  print(math.exp(a))\nAttributeError: module 'egse.math' has no attribute 'exp'\n</code></pre> <p>Of course this is an obvious example, but it might be more obscure like e.g. in this GitHub issue: 'module'  object has no attribute 'Cmd'.</p>"},{"location":"dev_guide/docs/","title":"Building the documentation","text":"<ul> <li>Make sure you are in a virtual environment with Python 3.9+ or use the <code>uv</code> commands as   demonstrated below.</li> <li>Run the <code>mkdocs serve</code> from the project root older</li> <li>Create new pages by adding folder and Markdown files inside <code>docs/*</code></li> </ul>"},{"location":"dev_guide/docs/#set-up-your-environment","title":"Set up your environment","text":"<p>The <code>pyproject.toml</code> file of the <code>cgse</code> root contains additional dependencies for running the <code>mkdocs</code> commands. When working on the documentation, make sure you have installed the 'docs' dependency group. Currently, only <code>mkdocs</code> and <code>mkdocs-material</code> are needed. Of course, you need to install these only once.</p> <pre><code>$ cd ~/github/cgse\n$ uv sync --only-group docs\n</code></pre> <p>Now you can start the live-reload server of <code>mkdocs</code>. This will recreate the documentation  whenever you make a change in the files below the <code>docs</code> folder. After starting this command,  navigate to the <code>http://127.0.0.1:8000/cgse/</code> site in your favorite browser.</p> <pre><code>$ uv run mkdocs serve\n</code></pre> <p>Now you can update files, create new folders in <code>docs/*</code>, create new Markdown files and all changes will be reloaded live in the browser.</p> <p>When you are ready with updating, you will need to build the site and publish it on GitHub pages:</p> <pre><code>$ uv run mkdocs build\n$ uv run mkdocs gh-deploy -r upstream -m \"documentation update on ..\"\n</code></pre>"},{"location":"dev_guide/docs/#commands","title":"Commands","text":"<ul> <li><code>mkdocs serve</code> \u2014 start the live-reloading docs server</li> <li><code>mkdocs build</code> \u2014 build the documentation site</li> <li><code>mkdocs deploy</code> \u2014 publish your documentation on GitHub pages</li> <li><code>mkdocs -h</code> \u2014 print a help message for more options</li> </ul>"},{"location":"dev_guide/docs/#project-layout","title":"Project layout","text":"<p>The documentation pages follow more or less the structure of the code in terms of libs and  projects. Below I have laid out this structure leaving out less important files and folders. </p> <pre><code>mkdocs.yml         # the mkdocs configuration file\ndocs\n\u251c\u2500\u2500 index.md       # the documentation homepage\n\u251c\u2500\u2500 initialize.md\n\u251c\u2500\u2500 getting_started.md\n\u251c\u2500\u2500 package_list.md\n\u251c\u2500\u2500 dev_guide/\n\u251c\u2500\u2500 user_guide/\n\u251c\u2500\u2500 libs\n\u2502   \u251c\u2500\u2500 cgse-common/\n\u2502   \u251c\u2500\u2500 cgse-coordinates/\n\u2502   \u251c\u2500\u2500 cgse-core/\n\u2502   \u251c\u2500\u2500 cgse-gui/\n\u2502   \u2514\u2500\u2500 index.md\n\u251c\u2500\u2500 projects/\n\u2502   \u251c\u2500\u2500 cgse-tools.md\n\u2502   \u251c\u2500\u2500 symetrie-hexapod.md\n\u2502   \u2514\u2500\u2500 index.md\n\u251c\u2500\u2500 images/\n\u2514\u2500\u2500 roadmap.md\n</code></pre>"},{"location":"dev_guide/installation/","title":"Installation Guide for Developers","text":""},{"location":"dev_guide/installation/#github","title":"GitHub","text":"<p>Before starting, make sure you have a fork of the <code>cgse</code> repository. Through this fork (which  resides on the GitHub  server) you will create pull requests. Install a clone of your fork on  your local machine or laptop.</p> <p> </p> <p>So, when you have created a fork in your GitHub account, clone the repository on your local  machine.  For the purpose of this guide we will clone the repo in the <code>~/github/cgse</code> folder.  The following commands will create the required folders and clone the repo.</p> <pre><code>$ mkdir -p ~/github\n$ cd ~/github\n$ git clone git@github.com:IvS-KULeuven/cgse.git\n$ cd ~/github/cgse\n</code></pre> <p>Now you will have to create a virtual environment and populated it with all the dependencies. </p> <p>Note</p> <p>The following three commands will get you going quickly: <pre><code>$ uv venv --python 3.9.20\n$ uv sync --all-packages\n$ uv run cgse\n\nUsage: cgse [OPTIONS] COMMAND [ARGS]...\n\nThe main cgse command to inspect, configure, monitor the core services and device control \nservers.\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --install-completion          Install completion for the current shell.                                        \u2502\n\u2502 --show-completion             Show completion for the current shell, to copy it or customize the installation. \u2502\n\u2502 --help                        Show this message and exit.                                                      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 version   Prints the version of the cgse-core and other registered packages.                                   \u2502\n\u2502 top       A top-like interface for core services and device control servers.                                   \u2502\n\u2502 clock     Showcase for running an in-line Textual App.                                                         \u2502\n\u2502 init      Initialize your project.                                                                             \u2502\n\u2502 show      Show information about settings, environment, setup, ...                                             \u2502\n\u2502 check     Check installation, settings, required files, etc.                                                   \u2502\n\u2502 dev-x     device-x is an imaginary device that serves as an example                                            \u2502\n\u2502 core      handle core services: start, stop, status                                                            \u2502\n\u2502 puna      PUNA Positioning Hexapod, Sym\u00e9trie                                                                   \u2502\n\u2502 daq6510   DAQ6510 Data Acquisition Unit, Keithley, temperature monitoring                                      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre></p>"},{"location":"dev_guide/monorepo/","title":"The structure of this monorepo","text":"<p>Currently, the structure starts with two main folders in the root, i.e. <code>libs</code> and <code>projects</code>. Where libs contains library type packages like common modules, small generic gui and tui functions, reference frames, ... and projects contain packages that build upon these libraries and can be device drivers or stand-alone applications.</p> <p>There is one package that I think doesn't fit into this picture, that is <code>cgse-core</code>. This is not a library, but a \u2013 collection of \u2013 service(s). So, we might want to add a third top-level folder <code>services</code> but I also fear that this again more complicates the monorepo.</p> <p>Anyway, the overall structure of the monorepo is depicted below:</p> <pre><code>cgse/\n\u2502\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 libs/\n\u2502   \u251c\u2500\u2500 cgse-common/\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u2514\u2500\u2500 pyproject.toml\n\u2502   \u251c\u2500\u2500 cgse-core/\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u2514\u2500\u2500 pyproject.toml\n\u2502   \u251c\u2500\u2500 cgse-coordinates/\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u2514\u2500\u2500 pyproject.toml\n\u2502   \u2514\u2500\u2500 cgse-gui/\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u2514\u2500\u2500 pyproject.toml\n\u2502\n\u2514\u2500\u2500 projects/\n    \u251c\u2500\u2500 generic/\n    \u2502   \u251c\u2500\u2500 cgse-tools/\n    \u2502   \u251c\u2500\u2500 keithley-tempcontrol/\n    \u2502   \u2514\u2500\u2500 symetrie-hexapod/\n    \u2514\u2500\u2500 plato/\n        \u251c\u2500\u2500 plato-spw/\n        \u251c\u2500\u2500 plato-fits/\n        \u2514\u2500\u2500 plato-hdf5/\n</code></pre> <p>We will discuss the structure of individual packages in a later section, for now let's look at the root of the monorepo. The root also contains a <code>pyproject.toml</code> file although this is not a package that will be build and published. The purpose of this root <code>pyproject.toml</code> file is to define properties that are used to build the full repo or any individual package in it. In the root folder we will also put some maintenance/management scripts to help you maintain and bump versions of the projects, build and publish all projects, create and maintain a changelog etc.</p>"},{"location":"dev_guide/monorepo/#package-structure","title":"Package Structure","text":"<p>We try to keep the package structure as standard as possible and consistent over the whole monorepo. The structure currently is as follows (example from cgse-common):</p> <pre><code>\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 egse/  # namespace, i.e. there shall not be a __init__.py in this folder\n\u2502       \u251c\u2500\u2500 modules (*.py)\n\u2502       \u2514\u2500\u2500 &lt;sub-packages&gt;/  # these do contain a __init__.py\n\u2514\u2500\u2500 tests/\n    \u251c\u2500\u2500 data\n    \u2514\u2500\u2500 pytest modules (test_*.py)\n</code></pre> <p>Note that each library or project is a standalone Python package with its own <code>pyproject.toml</code> file, source code and unit tests.</p>"},{"location":"dev_guide/monorepo/#package-versions","title":"Package versions","text":"<p>All packages in the monorepo will have the same version. This can be maintained with the <code>bump.py</code> script. This script will read the version from the <code>pyproject.toml</code> file at the root of the monorepo and propagate the version to all libs and projects in the monorepo. Note that you \u2013for now\u2013 will have to update the version number in the <code>pyproject.toml</code> file located at the monorepo root folder manually.</p>"},{"location":"dev_guide/monorepo/#the-egse-namespace","title":"The egse namespace","text":"<p>You might have notices that all packages in this monorepo have a <code>src/egse</code> folder in which they maintain their source code, preferably in a sub-package. Note that the <code>egse</code> folder is not a normal Python package but a namespace. There are two important facts you need to remember about namespaces:</p> <ol> <li>A namespace package does not contain an <code>__init__.py</code> module, never, in any of the packages    in this or any other repo. If you place an <code>__init__.py</code> module in one of your <code>egse</code> package    folders, you will break the namespace and therefore also the external contributions in plugins    etc.</li> <li>A namespace package is spread out over several directories that can reside in different packages    as distributed by PyPI.</li> </ol>"},{"location":"dev_guide/monorepo/#egse-versus-cgse","title":"<code>egse</code> versus <code>cgse</code>","text":"<p>Why is there sometimes <code>egse</code> and sometimes <code>cgse</code> used in documentation, folder names etc.? The acronym EGSE stands for Electric Ground Support Equipment and the CGSE stands for Common-EGSE. So, the latter, CGSE, is what we use for the project name, to emphasise its common purpose as a framework for testing instrumentation and for external packages and device drivers to emphasise that they are intended to be common and work well with the CGSE framework. The <code>egse</code> is what the software is about, the electric ground support equipment, and therefore we use this for the namespace, i.e. the root of the library and projects. Using <code>egse</code> as the namespace also avoid  any conflicts with the <code>cgse</code> monorepo name.</p>"},{"location":"dev_guide/plugins/","title":"Plugins","text":"<p>The CGSE is designed to be extensible and uses a few plugin mechanisms to extend its functionally with external contributions. Also within the <code>cgse</code> monorepo we use the plugin mechanism at several places. The following entry-points are currently defined:</p> <ul> <li><code>cgse.version</code>: Each package that provides functionality within the CGSE or adds a device driver   registers itself to provide version information.</li> <li><code>cgse.command</code>: Packages can add commands or sub-commands to the <code>cgse</code> app to manage   their functionality from within the <code>cgse</code> app, e.g. to start or stop the service or to report on   its status.</li> <li><code>cgse.service</code>: Package provides a device driver or another service.</li> <li><code>cgse.settings</code>: Package can add their own settings.</li> <li><code>cgse.explore</code>: Package provides a set of functions to explore, e.g. if any of the processes    it provides are running.</li> <li><code>cgse.resource</code>: Packages can register resources.</li> </ul> <p>Each of the entry-points knows how to load a module or object and each entry-point group is connected to a specific action or plugin hook like, e.g. add a command or command group to the <code>cgse</code> app, add package specific settings to the global settings.</p>"},{"location":"dev_guide/plugins/#version-discovery","title":"Version discovery","text":"<p>When you write a package that you want to integrate with the CGSE, provide a <code>cgse.version</code> entry-point. The name of the entry-point shall match the package name and is used to read the version from the importlib metadata. The entry-point value is currently not used. The entry-point value can optionally provide additional information about the package, but that is currently not specified.</p> <p>Add the following to your <code>pyproject.toml</code> file in your project's root folder, replacing package-name with the name of your project. The entry-point value is currently not used, but you want to use a valid format, the value below is always valid.</p> <pre><code>[project.entry-points.\"cgse.version\"]\npackage-name = 'egse.version:get_version_installed'\n</code></pre>"},{"location":"dev_guide/plugins/#extending-the-cgse-app","title":"Extending the <code>cgse</code> app","text":""},{"location":"dev_guide/plugins/#add-a-command","title":"Add a Command","text":"<p>If your package provides specific functionality that can be added as a command or a command group to the <code>cgse</code> app, use the <code>cgse.command</code> entry-point group. Since the <code>cgse</code> app uses the Typer package to build its commandline interface, adding a command is as simple as writing a function. The function will be added to the <code>cgse</code> app using the <code>app.command()</code> function of <code>Typer</code>, making the function a top-level command of the <code>cgse</code> app. The function can be defined as a plain function or with Typer's <code>@app.command</code> decorator.</p> <p>In the <code>pyproject.toml</code> file of your project, add the following lines to add the CGSE command:</p> <pre><code>[project.entry-points.\"cgse.command\"]\nname = 'module:object'\n</code></pre> <p>Where:</p> <ul> <li><code>name</code> is the name of the command</li> <li><code>module</code> is a fully qualified module name for your package, a module that can be imported</li> <li><code>object</code> is the name of the function that you want to add as a command</li> </ul> <p>As an example, for the <code>cgse-tools</code> package, the <code>init</code> command of the <code>cgse</code> app is listed in the <code>pyproject.toml</code> file as follows:</p> <pre><code>[project.entry-points.\"cgse.command\"]\ninit = 'cgse_tools.cgse_commands:init'\n</code></pre> <p>The <code>init</code> function is defined in the <code>cgse_commands.py</code> module which is located in the <code>cgse_tools</code> module in the <code>src</code> folder of the package:</p> <pre><code>src\n\u251c\u2500\u2500 cgse_tools\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 cgse_commands.py\n...\n</code></pre>"},{"location":"dev_guide/plugins/#add-a-command-group","title":"Add a Command group","text":"<p>Some commands are more complicated and define a number of sub-commands. An example is the <code>show</code> command where you currently have the sub-commands <code>env</code> and <code>settings</code></p> <pre><code>$ cgse show --help\n\n Usage: cgse show [OPTIONS] COMMAND [ARGS]...\n\n Show information about settings, environment, setup, ...\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                           \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 settings   Show the settings that are defined by the installed packages.              \u2502\n\u2502 env        Show the environment variables that are defined for the project.           \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>The <code>show</code> command is defined as a <code>typer.Typer()</code> object where <code>env</code> and <code>settings</code> are added using the decorator <code>@&lt;app&gt;.command()</code>.</p> <pre><code>import typer\n\nshow = typer.Typer(help=\"Show information about settings, environment, setup, ...\")\n\n\n@show.command(name=\"settings\")\ndef show_settings():\n    ...\n\n\n@show.command(name=\"env\")\ndef show_env():\n    ...\n</code></pre> <p>To add this command group to the <code>cgse</code> app, the following entry was used in the <code>pyproject. toml</code> file of the <code>cgse-tools</code> project. Notice the <code>[group]</code> at the end of the entry which indicates this is a command group instead of a single command.</p> <pre><code>[project.entry-points.\"cgse.command\"]\nshow = 'cgse_tools.cgse_commands:show[group]'\n</code></pre>"},{"location":"dev_guide/plugins/#add-a-service","title":"Add a Service","text":"<p>If your package provides a device driver or a specific service, use the <code>cgse.service</code> entry-point group. Service entry-points follow the same scheme as command groups, i.e. they are added to the <code>cgse</code> app as a <code>Typer()</code> object. Use the following entry in your <code>pyproject.toml</code> file:</p> <pre><code>[project.entry-points.\"cgse.service\"]\nname = 'module:object'\n</code></pre> <p>where:</p> <ul> <li><code>name</code> is the name of the service or device driver</li> <li><code>module</code> is a fully qualified module name for your package, a module that can be imported</li> <li><code>object</code> is the name of the <code>Typer()</code> object that you want to add as a service</li> </ul>"},{"location":"dev_guide/plugins/#explore","title":"Explore","text":"<p>The entry-point <code>cgse.explore</code> can be used to extend functionality without adding a new command  or sub-command to the <code>cgse</code> app. The idea is that commands that work on different packages can  use this entry-point to perform certain tasks on the package. This is currently used for the  <code>show procs</code> command (see below).</p> <p>The entry-point has the following format:</p> <pre><code>[project.entry-points.\"cgse.explore\"]\nexplore = \"&lt;package&gt;.cgse_explore\"\n</code></pre> <p>So, what happens is that a command that wants to apply a functionality on an external package  loads the <code>cgse_explore.py</code> module for that package and checks if a function with a specific  name exists in that module. It then executes that function. For the <code>show procs</code> command, the  function <code>show_processes</code> is expected and it shall return a list of strings which currently are  printed to the terminal. This entry-point is currently implemented for <code>cgse-core</code> and  <code>cgse-dummy</code> (an external demo package) and when you run the <code>cgse show procs</code> command it looks  something like below (the format is from the unix <code>ps -ef</code> command). </p> <pre><code>\u279c  cgse show procs\n459800007 76849     1   0 11:07PM ttys003    0:03.53 /Users/rik/tmp/test_dummy/venv/bin/python3.9 -m egse.logger.log_cs start\n459800007 76850     1   0 11:07PM ttys003    2:18.60 /Users/rik/tmp/test_dummy/venv/bin/python3.9 -m egse.storage.storage_cs start\n459800007 76851     1   0 11:07PM ttys003    2:20.10 /Users/rik/tmp/test_dummy/venv/bin/python3.9 -m egse.confman.confman_cs start\n459800007 13825     1   0  4:31PM ttys003    0:02.97 /Users/rik/tmp/test_dummy/venv/bin/python3.9 -m cgse_dummy.dummy_sim start\n</code></pre>"},{"location":"dev_guide/plugins/#register-resources","title":"Register resources","text":"<p>TODO: what if two packages provide a resource <code>icons</code> ?</p> <ul> <li>known resources: icons, styles</li> </ul>"},{"location":"dev_guide/unit_testing/","title":"Testing the Software","text":"<p>We use the <code>pytest</code> package to unit test our modules and packages. The <code>pyproject.toml</code> files are configured for  each package to perform the testing. This section will guide you through the steps to run the tests and also explain  how we configured the tests and some guidelines we used.</p>"},{"location":"dev_guide/unit_testing/#running-the-unit-test-for-each-package-separately","title":"Running the unit test for each package separately","text":"<p>If you are working on a particular package and want to run its unit test, make sure you are in the root folder of  that package, e.g. for the <code>cgse-common</code> package, do the following:</p> <pre><code>$ cd ~/github/cgse/libs/cgse-common/\n$ uv sync\n$ uv run pytest -v\n================================================================ test session starts =================================================================\nplatform darwin -- Python 3.9.20, pytest-8.3.4, pluggy-1.5.0 -- /Users/rik/github/cgse/.venv/bin/python3\ncachedir: .pytest_cache\nrootdir: /Users/rik/github/cgse/libs/cgse-common\nconfigfile: pyproject.toml\nplugins: cov-6.0.0, mock-3.14.0\ncollected 161 items\n\ntest_bits.py::test_clear_bit PASSED                                                                                                            [  0%]\ntest_bits.py::test_set_bit PASSED                                                                                                              [  1%]\ntest_bits.py::test_toggle_bit PASSED                                                                                                           [  1%]\ntest_bits.py::test_beautify_binary PASSED                                                                                                      [  2%]\ntest_bits.py::test_set_bits PASSED                                                                                                             [  3%]\ntest_bits.py::test_alternative_set_bits PASSED                                                                                                 [  3%]\ntest_bits.py::test_clear_bits PASSED                                                                                                           [  4%]\ntest_bits.py::test_crc_calc PASSED                                                                                                             [  4%]\ntest_bits.py::test_humanize_bytes PASSED                                                                                                       [  5%]\ntest_bits.py::test_s16 PASSED                                                                                                                  [  6%]\ntest_bits.py::test_s32 PASSED                                                                                                                  [  6%]\ntest_command.py::test_dry_run PASSED                                                                                                           [  7%]\ntest_command.py::test_command_class PASSED                                                                                                     [  8%]\ntest_command.py::test_return_code_of_execute PASSED                                                                                            [  8%]\n...\n</code></pre>"},{"location":"dev_guide/unit_testing/#running-the-unit-tests-of-all-packages","title":"Running the unit tests of all packages","text":"<p>Before releasing the software, we should run all the unit tests of all the packages in the monorepo and have green  light \ud83d\udfe2. Running these unit tests is as simple as for the individual packages. You will need to be in the root folder  of the monorepo and sync your virtual environment for all the packages in the workspace.</p> <pre><code>$ cd ~/gitbug/cgse\n$ uv sync --all-packages\n$ uv run pytest -v\n</code></pre>"},{"location":"dev_guide/uv/","title":"Working with <code>uv</code>","text":"<p><code>uv</code> is an extremely fast Python package and project manager, written in Rust. We will use <code>uv</code> as the single tool that replaces <code>pip</code>, <code>virtualenv</code>, <code>pyenv</code>, and more. The main tasks for which we will use <code>uv</code> are:</p> <ul> <li>run and install Python versions</li> <li>installing and managing a virtual environment</li> <li>build all the packages in the workspace or monorepo</li> <li>publish all the packages to PyPI</li> <li>run scripts and apps</li> </ul>"},{"location":"dev_guide/uv/#installing-uv","title":"Installing <code>uv</code>","text":"<p>On macOS and Linux you can install <code>uv</code> using <code>curl</code>:</p> <pre><code>$ curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>If you need more specific information on installing and upgrading <code>uv</code>, please refer to the official documentation.</p>"},{"location":"dev_guide/uv/#installing-a-python-version","title":"Installing a Python version","text":"<p>The CGSE is guaranteed to work with Python 3.9.x. We will gradually include higher versions of Python, but currently  these have not been tested. So, we will for the moment stick with Python 3.9.20. Install this version as follows:</p> <pre><code>$ uv python install 3.9.20\n</code></pre> <p><code>pyenv</code></p> <p>When you are using <code>pyenv</code> to manage your Python versions, make sure you also have the same  Python version installed with <code>pyenv</code> and <code>uv</code>. Otherwise you will run into the following  error. This is a known issue with <code>uv</code>.</p> <pre><code>pyenv: version `3.9.20' is not installed (set by /Users/rik/github/cgse/libs/cgse-common/.python-version)\n</code></pre> <p>You can check which Python versions are installed already on your system:</p> CommandOutput <pre><code>$ uv python list --only-installed\n</code></pre> <pre><code>cpython-3.12.8-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.12.8-macos-aarch64-none/bin/python3.12\ncpython-3.10.16-macos-aarch64-none    /Users/rik/Library/Application Support/uv/python/cpython-3.10.16-macos-aarch64-none/bin/python3.10\ncpython-3.9.21-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.9.21-macos-aarch64-none/bin/python3.9\ncpython-3.9.20-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.9.20-macos-aarch64-none/bin/python3.9\ncpython-3.9.6-macos-aarch64-none      /Library/Developer/CommandLineTools/usr/bin/python3 -&gt; ../../Library/Frameworks/Python3.framework/Versions/3.9/bin/python3\ncpython-3.8.17-macos-aarch64-none     /Users/rik/Library/Application Support/uv/python/cpython-3.8.17-macos-aarch64-none/bin/python3.8\n</code></pre>"},{"location":"dev_guide/uv/#create-a-virtual-environment","title":"Create a virtual environment","text":"<p>Pin a Python version</p> <p>You can pin a python version with the command:</p> <pre><code>$ uv python pin 3.9.20\n</code></pre> <p><code>uv</code> will search for a pinned version in the parent folders up to the root folder or your home directory.</p> <p>You can create a virtual environment with <code>uv</code> for the specific Python version as follows. The  '<code>--python</code>' is optional  and <code>uv</code> will use the default (pinned) Python version when creating a  <code>venv</code> without this option. We are working in a monorepo or what <code>uv</code> calls a workspace. There  will be only one virtual environment at the root of the monorepo, despite the fact that we have  several individual packages in our workspace. Don't worry, <code>uv</code> will always use the virtual  environment at the root and keep it up-to-date with the project your are currently working in.</p> <p>When creating a virtual environment make sure you are in the root folder, e.g. <code>~/github/cgse</code>.</p> <p><pre><code>$ cd ~/github/cgse\n$ uv venv --python 3.9.20\n</code></pre> If you want to name your virtual environment, use the optional argument <code>--prompt &lt;venv name&gt;</code> in  the above command, otherwise the virtual environment will get the same name as the project, i.e.  <code>cgse</code>.</p> <p>Now, navigate to the package you will be working in and update the projects' environment,  assuming you are going to work in <code>cgse-core</code>, this will be:</p> <pre><code>$ cd ~/github/cgse/libs/cgse-core\n$ uv sync\n</code></pre> <p>Your package(s) from the workspace should be installed as an editable install. You can check  this with the command:</p> <pre><code>$ uv pip list -v\nUsing Python 3.9.20 environment at: /Users/rik/github/cgse/.venv\nPackage           Version     Editable project location\n----------------- ----------- ---------------------------------------\napscheduler       3.11.0\ncgse-common       0.4.0       /Users/rik/github/cgse/libs/cgse-common\ncgse-core         0.4.0       /Users/rik/github/cgse/libs/cgse-core\n...\n</code></pre> <p>To install any other project as an editable package:</p> <pre><code>$ uv pip install -e &lt;project location&gt;\n</code></pre> <p>Note</p> <p>If you don't want to use the <code>uv</code> commands, you can activate the virtual environment and use the original <code>pip</code>  and <code>python</code> commands as you are used to, but I would recommend you try to get used to <code>uv</code>  for a while to experience its benefits.</p> <pre><code>$ source ~/github/cgse/.venv/bin/activate\n</code></pre> <p>Info</p> <p>In a workspace, maintaining a virtual environment per package might be a hassle and most of the time that is not  needed. A good approach is to always use the virtual environment at the workspace root. This <code>venv</code> which will be  automatically created if you run a command or if you use <code>uv sync</code> in the package folder. With <code>uv sync</code> you can  make sure the virtual environment is up-to-date and contains only those dependencies that are required for the  package you are in. So, each time you switch to another package and want to run a comand or a test for that  package, use </p> <pre><code>$ uv sync\n</code></pre>"},{"location":"dev_guide/uv/#building-and-publishing-all-packages","title":"Building and publishing all packages","text":"<p>We have chosen for one and the same version number for all packages in the <code>cgse</code> monorepo. That means that whenever  we make a change to one of the packages and want to release that change, all packages shall be rebuild and published.</p> <p>Inline</p> <p>When working in a workspace, keep in mind that the commands <code>uv run</code> and <code>uv sync</code> by default work on the  workspace root. That means that when you run the <code>uv run pip install &lt;package&gt;</code> command, the <code>.venv</code> at the  workspace root will be updated or created if it didn't exist. Similar for the <code>uv sync</code> command, there is only  one <code>uv.lock</code> file at the root of the workspace.  </p> <p>Fortunately, with <code>uv</code>, that is done in a few commands.</p> <p>When you are in the monorepo root folder, you can build all packages at once. They will be placed in the <code>dist</code> folder  of the root package. Before building, make sure you update the version in the <code>pyproject.toml</code> of the root package  and then bump the versions. Before building, clean up the <code>dist</code> folder, then you can do a default <code>uv publish</code> afterwards.</p> <pre><code>$ cd &lt;monorepo root&gt;\n$ uv run bump.py\n$ rm -r dist\n$ uv build --all-packages\n</code></pre> <p>Publish all packages in the root dist folder to PyPI. The UV_PUBLISH_TOKEN can be defined in a (read protected) ~/. setenv.bash file:</p> <pre><code>$ uv publish --token $UV_PUBLISH_TOKEN\n</code></pre> <p>The above command will publish all package to PyPI. If you don't want the token to be in a shell variable, you can  omit the <code>--token</code> in the command above. You will then be asked for a username, use <code>__token__</code> as the username and  then provide the token as a password.</p>"},{"location":"dev_guide/versioning/","title":"Semantic Versioning","text":"<p>We use semantic versioning, aka semver, for our releases and patches. Please follow the rules that are described on their site.</p> <p>TL;DR</p> <p>The version number has the format <code>MAJOR.MINOR.PATH</code>, we increment the</p> <ul> <li>MAJOR version when we make incompatible changes</li> <li>MINOR version when we add or change functionality in a backward compatible manner</li> <li>PATCH version when we make backward compatible bug fixes</li> </ul> <p>The rules above apply when MAJOR &gt;= 1, which are considered stable releases.</p> <p>As long as MAJOR == 0, we are in initial development and anything may change. The MINOR number will be increased for adding or removing functionality and the PATCH number will be increased for all kinds of fixes.</p> <p>You might occasionally see pre-release and build metadata added to the version number. We will use the following metadata:</p> <ul> <li><code>-dev.X</code> \u2014 a development release where X &gt;= 1. This will be used for releases where we need to   test PyPI installations and/or GitHub actions. A development release can be added to any PATCH    number. An example development release: <code>2.3.1-dev.1</code>.</li> <li><code>-rc.X</code> \u2014 a release candidate where X &gt;= 1. This is a pre-release and contains all the intended   features. The release is believed to be stable enough for public testing, but isn't yet considered   the final production version. There might be more than one release candidate. Release    candidates are usually used for releases where PATCH == 0. For example, when we   have a third release candidate <code>1.2.0-rc.3</code> the actual released version will then be <code>1.2.0</code>.</li> </ul>"},{"location":"dev_guide/versioning/#why-not-calver","title":"Why not CalVer?","text":"<p>We do not use Calendar Versioning for the following reason:</p> <ul> <li>Calendar versioning is preferred for projects that have a release schedule that is based on dates,   like every week or every three months.</li> <li>Semantic versioning is preferred when no date related release schedule is foreseen, also major   version 0 means that API is not yet fixed and everything can change. Our project is in that state   right now.</li> </ul>"},{"location":"libs/","title":"Libraries","text":"<p>The libraries are those packages that make up the CGSE framework.</p> <p>The libraries are located under the <code>libs</code> folder, and we currently find the following packages there:</p> <ul> <li><code>cgse-common</code></li> <li><code>cgse-core</code></li> <li><code>cgse-coordinates</code></li> <li><code>cgse-gui</code></li> </ul>"},{"location":"libs/cgse-common/","title":"Common Code","text":"<p>This package <code>cgse-common</code> contains modules that are used by all other packages. </p> Module Name Description <code>egse.bits</code> convenience functions to work with bits, bytes and integers <code>egse.calibration</code> functions to handle conversions and apply correction <code>egse.command</code> classes and functions to work with commands that operate hardware devices <code>egse.config</code> convenience functions to configure the system and find folders and files <code>egse.control</code> defines abstract classes and convenience functions for any control server <code>egse.decorators</code> a collection of useful decorator functions <code>egse.device</code> defines the generic interfaces to connect devices <code>egse.env</code> functionality to work with and check your environment variables <code>egse.exceptions</code> common Exceptions and Errors <code>egse.hk</code> functions to retrieve and convert housekeping parameter values <code>egse.metrics</code> functions to define and update metrics <code>egse.mixin</code> defines the mixin classes for dynamic commanding <code>egse.monitoring</code> the monitoring application / function <code>egse.observer</code> the classic observer and observable <code>egse.obsid</code> functions to define and work with the OBSID <code>egse.persistence</code> the persistence layer interface <code>egse.plugin</code> functions to load plugins and settings from entry-points <code>egse.process</code> functions and classes to work with processes and sub-processes <code>egse.protocol</code> base class for communicating commands with the hardware or the control server <code>egse.proxy</code> base class for the Proxy objects for each device controller <code>egse.reload</code> a slightly better approach to reloading modules and function <code>egse.resource</code> convenience functions to use resources in your code <code>egse.response</code> defines the classes to handle responses from the control servers <code>egse.services</code> provides the services to the control servers <code>egse.settings</code> provides functions to handle user and configuration settings <code>egse.setup</code> defines the Setup, containing the complete configuration for a test <code>egse.state</code> classes and functions to handle state, e.g. the GlobalState <code>egse.system</code> convenience functions that provide information on system specific functionality <code>egse.version</code> functions to load specific version information <code>egse.zmq_ser</code> serialization function used in a ZeroMQ context"},{"location":"libs/cgse-common/settings/","title":"The Settings","text":"<p>The Settings class contains all static information needed to configure your system, the environment you are using and the test equipment. The Settings also contain all the IP addresses and port number for all the known devices, together with other static information like the device name, default settings for the device like speed, timeout, delay time, firmware version, etc. We will go into more details about the content later, let\u2019s now first look at the format and usage of the Settings.</p>"},{"location":"libs/cgse-common/settings/#loading-the-settings","title":"Loading the Settings","text":"<p>The Settings can be loaded as follows:</p> <pre><code>&gt;&gt;&gt; from egse.settings import Settings\n&gt;&gt;&gt; settings = Settings.load()\n</code></pre> <p>The <code>settings</code> object will be a dictionary where the keys are the top-level groups that are defined in the settings for each package. For a system that has only <code>cgse-common</code> and <code>cgse-core</code> installed, the <code>settings</code> will contain something like this:</p> <pre><code>&gt;&gt;&gt; print(settings)\nSettings\n\u251c\u2500\u2500 PACKAGES\n\u2502   \u251c\u2500\u2500 CGSE_COMMON: Common classes, functions, decorators, etc. for the CGSE\n\u2502   \u2514\u2500\u2500 CGSE_CORE: The core services of the CGSE\n\u251c\u2500\u2500 SITE\n\u2502   \u251c\u2500\u2500 ID: LAB42\n\u2502   \u251c\u2500\u2500 SSH_SERVER: localhost\n\u2502   \u2514\u2500\u2500 SSH_PORT: 22\n\u251c\u2500\u2500 PROCESS\n\u2502   \u2514\u2500\u2500 METRICS_INTERVAL: 10\n\u251c\u2500\u2500 Logging Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 LOGGING_PORT: 7000\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 7001\n\u2502   \u251c\u2500\u2500 METRICS_PORT: 7003\n\u2502   \u251c\u2500\u2500 MAX_NR_LOG_FILES: 20\n\u2502   \u251c\u2500\u2500 MAX_SIZE_LOG_FILES: 20\n\u2502   \u251c\u2500\u2500 TEXTUALOG_IP_ADDRESS: 127.0.0.1\n\u2502   \u2514\u2500\u2500 TEXTUALOG_LISTENING_PORT: 19996\n\u251c\u2500\u2500 Configuration Manager Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 6000\n\u2502   \u251c\u2500\u2500 MONITORING_PORT: 6001\n\u2502   \u251c\u2500\u2500 SERVICE_PORT: 6002\n\u2502   \u251c\u2500\u2500 METRICS_PORT: 6003\n\u2502   \u251c\u2500\u2500 DELAY: 1\n\u2502   \u2514\u2500\u2500 STORAGE_MNEMONIC: CM\n\u2514\u2500\u2500 Storage Control Server\n    \u251c\u2500\u2500 PROTOCOL: tcp\n    \u251c\u2500\u2500 HOSTNAME: localhost\n    \u251c\u2500\u2500 COMMANDING_PORT: 6100\n    \u251c\u2500\u2500 MONITORING_PORT: 6101\n    \u251c\u2500\u2500 SERVICE_PORT: 6102\n    \u251c\u2500\u2500 METRICS_PORT: 6103\n    \u2514\u2500\u2500 DELAY: 1\n</code></pre> <p>If you only need the settings for a particular component, specify that group's name:</p> <pre><code>&gt;&gt;&gt; storage_settings = Settings.load(\"Storage Control Server\")\n\n&gt;&gt;&gt; print(storage_settings)\nStorage\nControl\nServer\n\u251c\u2500\u2500 PROTOCOL: tcp\n\u251c\u2500\u2500 HOSTNAME: localhost\n\u251c\u2500\u2500 COMMANDING_PORT: 6100\n\u251c\u2500\u2500 MONITORING_PORT: 6101\n\u251c\u2500\u2500 SERVICE_PORT: 6102\n\u251c\u2500\u2500 METRICS_PORT: 6103\n\u2514\u2500\u2500 DELAY: 1\n</code></pre> <p>The values can be accessed as usual with a dictionary, by specifying the name of the parameter as the key:</p> <pre><code>&gt;&gt;&gt; print(storage_settings[\"COMMANDING_PORT\"])\n6100\n</code></pre> <p>We usually only go one level deep when defining settings, and as a convenience, that first level of variables can also be accessed with the dot-notation.</p> <pre><code>&gt;&gt;&gt; print(storage_settings.COMMANDING_PORT)\n6100\n</code></pre>"},{"location":"libs/cgse-common/settings/#entry-points","title":"Entry-points","text":"<p>The Settings are collected from a set of YAML files which are provided by the packages through the entry-point <code>cgse.settings</code>. The default Settings file is named <code>settings.yaml</code> but this can be changed by the entry-point (see below).</p> <p>Let's take a look at how the settings are provided for the <code>cgse-core</code> package. First, the <code>pyproject.toml</code> file of the project shall define the entry-point. In the snippet below, the entry-point <code>cgse-core</code> is defined for the group <code>cgse.settings</code>.</p> <pre><code>[project.entry-points.\"cgse.settings\"]\ncgse-core = \"cgse_core:settings.yaml\"\n</code></pre> <p>The entry-point itself has the following format: <code>&lt;name&gt; = \"&lt;module&gt;.&lt;filename&gt;\"</code>, where</p> <ul> <li><code>&lt;name&gt;</code> is the name of the entry-point given in the <code>pyproject.toml</code> file, usually this is the package name,</li> <li><code>&lt;module&gt;</code> is a valid module name that can be imported and from which the location can be determined, and</li> <li><code>&lt;filename&gt;</code> is the name of the target file, e.g. a YAML file.</li> </ul> <p>Note</p> <p>The module name for this entry point has an underscore instead of a dash, i.e. <code>cgse_core</code> instead of  <code>cgse-core</code>. The reason is that module names with a dash will generate a SyntaxError during import.</p> <p>The above example will load the settings for this package from the <code>settings.yaml</code> file that is located in the <code>cgse_core</code> module. That is, the package shall also provide this as follows:</p> <pre><code>cgse-core\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 cgse_core\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 settings.yaml\n</code></pre> <p>The <code>settigs.yaml</code> file for this module looks something like this:</p> <pre><code>PACKAGES:\n    CGSE_CORE: The core services of the CGSE\n\nLogging Control Server:                          # LOG_CS\n\n    PROTOCOL:                       tcp\n    HOSTNAME:                 localhost          # The hostname that client shall connect to, e.g. pleiad01 @ KU Leuven\n    LOGGING_PORT:                  7000\n    COMMANDING_PORT:               7001\n    METRICS_PORT:                  7003          # The HTTP port where Prometheus will connect to for retrieving metrics\n    MAX_NR_LOG_FILES:                20          # The maximum number of log files that will be maintained in a roll-over\n    MAX_SIZE_LOG_FILES:              20          # The maximum size one log file can become\n    TEXTUALOG_IP_ADDRESS:     127.0.0.1          # The IP address of the textualog listening server\n    TEXTUALOG_LISTENING_PORT:     19996          # The port number on which the textualog server is listening\n\nConfiguration Manager Control Server:            # CM_CS\n\n    ...\n</code></pre> <p>Warning</p> <p>Please note that the module where the Settings YAML file resides is a Python package and not  a namespace. That means it shall have a <code>__init__.py</code> file as shown in the example of the  <code>cgse_core</code> module above.</p> <p>If the <code>__init__.py</code> file is not there, you will get an error like below:</p> <pre><code>ERROR:egse.plugin:The entry-point 'cgse-coordinates' is ill defined. The module part doesn't \nexist or is a namespace. No settings are loaded for this entry-point.\n</code></pre>"},{"location":"libs/cgse-common/settings/#local-settings","title":"Local Settings","text":"<p>You can, and you should, define local settings for your project and put those settings in a known folder on your system. The usual place is <code>~/cgse/local-settings.yaml</code>. This file will be automatically loaded by the <code>Settings.load()</code> function when you define the local settings environment variable. That variable name is <code>&lt;PROJECT&gt;_LOCAL_SETTINGS</code> where <code>&lt;PROJECT&gt;</code> is the name of your project as defined by the <code>PROJECT</code> environment variable. For a <code>PROJECT=LAB23</code> the local settings would be defined as follows:</p> <pre><code>$ export LAB23_LOCAL_SETTINGS=~/cgse/local-settings-lab23.yaml\n</code></pre> <p>The local settings take higher precedence that will overwrite the global settings when loaded. You only need to define the settings that actually change for your local installation, respect the full hierarchy when specifying those settings. You are allowed to define new entries at any level in the Settings hierarchy.</p> <p>The usual parameters to put into a local settings file are:</p> <ul> <li>the SITE ID</li> <li>the hostnames of the different devices that you use</li> <li>the hostname of the server where core services or device control servers are running</li> <li>port numbers that have been changed from the default</li> </ul>"},{"location":"libs/cgse-common/settings/#terminal-command","title":"Terminal Command","text":"<p>You can check the current settings from the terminal with the following command:</p> <pre><code>$ py -m egse.settings\nSettings\n\u251c\u2500\u2500 PACKAGES\n\u2502   \u251c\u2500\u2500 CGSE_COMMON: Common classes, functions, decorators, etc. for the CGSE\n\u2502   \u2514\u2500\u2500 CGSE_CORE: The core services of the CGSE\n\u251c\u2500\u2500 SITE\n\u2502   \u251c\u2500\u2500 ID: LAB42\n\u2502   \u251c\u2500\u2500 SSH_SERVER: localhost\n\u2502   \u2514\u2500\u2500 SSH_PORT: 22\n\u251c\u2500\u2500 PROCESS\n\u2502   \u2514\u2500\u2500 METRICS_INTERVAL: 10\n\u251c\u2500\u2500 Logging Control Server\n\u2502   \u251c\u2500\u2500 PROTOCOL: tcp\n\u2502   \u251c\u2500\u2500 HOSTNAME: localhost\n\u2502   \u251c\u2500\u2500 LOGGING_PORT: 7000\n\u2502   \u251c\u2500\u2500 COMMANDING_PORT: 7001\n... ...\n\u2514\u2500\u2500 Storage Control Server\n    \u251c\u2500\u2500 PROTOCOL: tcp\n    \u251c\u2500\u2500 HOSTNAME: localhost\n    \u251c\u2500\u2500 COMMANDING_PORT: 6100\n    \u251c\u2500\u2500 MONITORING_PORT: 6101\n    \u251c\u2500\u2500 SERVICE_PORT: 6102\n    \u251c\u2500\u2500 METRICS_PORT: 6103\n    \u2514\u2500\u2500 DELAY: 1\nMemoized locations:\n['/Users/rik/github/cgse/libs/cgse-common/src/cgse_common/settings.yaml', '/Users/rik/github/cgse/libs/cgse-core/src/cgse_core/settings.yaml', '/Users/rik/cgse/local_settings_ariel.yaml']\n</code></pre> <p>The memoized locations are the settings files that have been loaded and cached. Once the application has started and the settings have been loaded, they can only be reloaded by explicitly forcing a reload as follows:</p> <pre><code>&gt;&gt;&gt; settings = Settings.load(force=True)\n</code></pre> <p>Warning</p> <p>The <code>force</code> reload does however not guarantee that the settings will propagate properly throughout the application or to client apps. Settings can be saved in local variables or class instances that have no knowledge of a Settings reload. So, be careful when changing your Settings. If there are parameters that change often and are not as  static as thought, maybe they belong in the Setup instead of the Settings. Examples are:</p> <ul> <li>calibration parameters</li> <li>SUT parameters</li> <li>conversion functions</li> <li>coordinates and reference frames</li> <li>models</li> </ul>"},{"location":"libs/cgse-common/settings/#the-design-of-the-load-method","title":"The design of the <code>load()</code> method","text":"<p>A word about the <code>Settings.load()</code> method. Depending on the parameters provided, this method either loads all  settings, a group of settings or just one single YAML file. We have already explained how to load a specific group  of settings by giving the name of the group as a parameter. When you want to load just one YAML file, you need to  specify its location also. When a location is given as a str or a Path, the Settings will be loaded from that file  only, using the default <code>settings.yaml</code> name or another name given through the <code>filename</code> argument.</p> <p>This can be used to e.g. load command files for a device:</p> <pre><code>&gt;&gt;&gt; commands = Settings.load(location=\"~\", filename=\"DAQ5610.yaml\")\n</code></pre> <p>The mechanism behind the <code>Settings.load()</code> method is shown in the following diagram. For simplicity, parameters are  not shown and only the success path is presented, not any exceptions or error handling.</p> <p></p>"},{"location":"libs/cgse-common/setup/","title":"The Setup","text":""},{"location":"libs/cgse-coordinates/","title":"Reference Coordinates","text":""},{"location":"libs/cgse-core/","title":"Core Services","text":""},{"location":"libs/cgse-gui/","title":"GUI Components","text":""},{"location":"projects/","title":"Projects","text":"<p>The projects are those packages that add functionality to the CGSE framework.</p> <p>The projects live under the folder <code>projects</code>, and they are organised in generic and specific projects. Generic  projects do not have an implementation that is specific for one particular project, while, obviously, specific  projects have. We currently have the following generic packages:</p> <ul> <li><code>cgse-tools</code></li> <li><code>symetrie-hexapod</code></li> <li><code>keithley-tempcontrol</code></li> </ul> <p>and then there are the project specific packages:</p> <ul> <li><code>plato-fits</code></li> <li><code>plato-hdf5</code></li> <li><code>plato-spw</code></li> </ul>"},{"location":"projects/cgse-tools/","title":"Tools for the CGSE framework","text":""},{"location":"projects/symetrie-hexapod/","title":"The Sym\u00e9trie Hexapods","text":""},{"location":"projects/symetrie-hexapod/#settings-up-your-system-for-the-puna-hexapod","title":"Settings up your system for the PUNA Hexapod","text":"<p>Warning</p> <p>We need some work here... we want to be able to use multiple hexapods in the same Setup and  they can be the same type or different types. So, how do we specify two PUNA hexapods used  to position two different parts of your test equiopment?  </p> <p>The system needs to know the following information on the hexapod:</p> <ul> <li>device name: specified in the Setup under <code>setup.gse.hexapod.device_args.device_name</code></li> <li>device id: specified in the Setup under <code>setup.gse.hexapod.device_args.device_id</code></li> </ul> <p>These above settings can olso be specified in the environment variables:</p> <ul> <li>SYMETRIE_HEXAPOD_NAME</li> <li>SYMETRIE_HEXAPOD_ID</li> </ul>"},{"location":"user_guide/","title":"User Guide","text":"<p>Welcome to the CGSE user guide! An in-depth reference on how to use the CGSE.</p>"}]}